// Copyright Â©2021 The star-tex Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by [web2go -lib -pkg xtex -type Context -o /home/binet/tmp/xtex.go tex.web], DO NOT EDIT.

// This program is copyright (C) 1982 by D. E. Knuth; all rights are reserved.
// Unlimited copying and redistribution of this file are permitted as long
// as this file is not modified. Modifications are permitted, but only if
// the resulting file is not named tex.web. (The WEB system provides
// for alterations via an auxiliary file; the master file should stay intact.)
// See Appendix H of the WEB manual for hints on how to install this program.
// And see Appendix A of the TRIP manual for details about how to validate it.
//
// TeX is a trademark of the American Mathematical Society.
// METAFONT is a trademark of Addison-Wesley Publishing Company.
//
// Version 0 was released in September 1982 after it passed a variety of tests.
// Version 1 was released in November 1983 after thorough testing.
// Version 1.1 fixed ``disappearing font identifiers'' et alia (July 1984).
// Version 1.2 allowed `0' in response to an error, et alia (October 1984).
// Version 1.3 made memory allocation more flexible and local (November 1984).
// Version 1.4 fixed accents right after line breaks, et alia (April 1985).
// Version 1.5 fixed \the\toks after other expansion in \edefs (August 1985).
// Version 2.0 (almost identical to 1.5) corresponds to "Volume B" (April 1986).
// Version 2.1 corrected anomalies in discretionary breaks (January 1987).
// Version 2.2 corrected "(Please type...)" with null \endlinechar (April 1987).
// Version 2.3 avoided incomplete page in premature termination (August 1987).
// Version 2.4 fixed \noaligned rules in indented displays (August 1987).
// Version 2.5 saved cur_order when expanding tokens (September 1987).
// Version 2.6 added 10sp slop when shipping leaders (November 1987).
// Version 2.7 improved rounding of negative-width characters (November 1987).
// Version 2.8 fixed weird bug if no \patterns are used (December 1987).
// Version 2.9 made \csname\endcsname's "relax" local (December 1987).
// Version 2.91 fixed \outer\def\a0{}\a\a bug (April 1988).
// Version 2.92 fixed \patterns, also file names with complex macros (May 1988).
// Version 2.93 fixed negative halving in allocator when mem_min<0 (June 1988).
// Version 2.94 kept open_log_file from calling fatal_error (November 1988).
// Version 2.95 solved that problem a better way (December 1988).
// Version 2.96 corrected bug in "Infinite shrinkage" recovery (January 1989).
// Version 2.97 corrected blunder in creating 2.95 (February 1989).
// Version 2.98 omitted save_for_after at outer level (March 1989).
// Version 2.99 caught $$\begingroup\halign..$$ (June 1989).
// Version 2.991 caught .5\ifdim.6... (June 1989).
// Version 2.992 introduced major changes for 8-bit extensions (September 1989).
// Version 2.993 fixed a save_stack synchronization bug et alia (December 1989).
// Version 3.0 fixed unusual displays; was more \output robust (March 1990).
// Version 3.1 fixed nullfont, disabled \write{\the\prevgraf} (September 1990).
// Version 3.14 fixed unprintable font names and corrected typos (March 1991).
// Version 3.141 more of same; reconstituted ligatures better (March 1992).
// Version 3.1415 preserved nonexplicit kerns, tidied up (February 1993).
// Version 3.14159 allowed fontmemsize to change; bulletproofing (March 1995).
// Version 3.141592 fixed \xleaders, glueset, weird alignments (December 2002).
// Version 3.1415926 was a general cleanup with minor fixes (February 2008).
// Version 3.14159265 was similar (January 2014).
// Version 3.141592653 was similar but more extensive (January 2021).
//
// A reward of $327.68 will be paid to the first finder of any remaining bug.
//
// Although considerable effort has been expended to make the TeX program
// correct and reliable, no warranty is implied; the author disclaims any
// obligation or liability for damages, including but not limited to
// special, indirect, or consequential damages arising out of or in
// connection with the use or performance of this software. This work has
// been a ``labor of love'' and the author hopes that users enjoy it.
//
// Here is TeX material that gets inserted after \input webmac
package xtex

import (
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
	"unsafe"
)

const (
	memMax          = 30000
	memMin          = 0
	bufSize         = 500
	errorLine       = 72
	halfErrorLine   = 42
	maxPrintLine    = 79
	stackSize       = 200
	maxInOpen       = 6
	fontMax         = 75
	fontMemSize     = 20000
	paramSize       = 60
	nestSize        = 40
	maxStrings      = 3000
	stringVacancies = 8000
	poolSize        = 32000
	saveSize        = 600
	trieSize        = 8000
	trieOpSize      = 500
	dviBufSize      = 800
	fileNameSize    = 40
	poolName        = "TeXformats:TEX.POOL                     "
)

type (
	ASCIICode          byte     // 0..255
	eightBits          byte     // 0..255
	alphaFile          *pasFile // file of char
	byteFile           *pasFile // file of 0..255
	poolPointer        uint16   // 0..32000
	strNumber          uint16   // 0..3000
	packedASCIICode    byte     // 0..255
	scaled             int32    // integer
	nonnegativeInteger uint32   // 0..2147483647
	smallNumber        byte     // 0..63
	glueRatio          float32  // real
	quarterword        byte     // 0..255
	halfword           uint16   // 0..65535
	twoChoices         byte     // 1..2
	fourChoices        byte     // 1..4
	wordFile           *pasFile // file of record memoryWord
	glueOrd            byte     // 0..3
	groupCode          byte     // 0..16
	internalFontNumber byte     // 0..75
	fontIndex          uint16   // 0..20000
	dviIndex           uint16   // 0..800
	triePointer        uint16   // 0..8000
	hyphPointer        uint16   // 0..307
)

type twoHalves struct {
	rh      uint16
	variant uint16
}

func (r twoHalves) lh() uint16 { return *(*uint16)(unsafe.Pointer(&r.variant)) }

func (r *twoHalves) pLh() *uint16 { return (*uint16)(unsafe.Pointer(&r.variant)) }

func (r twoHalves) b0() byte { return *(*byte)(unsafe.Pointer(&r.variant)) }

func (r *twoHalves) pB0() *byte { return (*byte)(unsafe.Pointer(&r.variant)) }

func (r twoHalves) b1() byte {
	return *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&r.variant)) + 1))
}

func (r *twoHalves) pB1() *byte {
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&r.variant)) + 1))
}

type fourQuarters struct {
	b0 byte
	b1 byte
	b2 byte
	b3 byte
}

type memoryWord struct {
	variant uint32
}

func (r memoryWord) int() int32 { return *(*int32)(unsafe.Pointer(&r.variant)) }

func (r *memoryWord) pInt() *int32 { return (*int32)(unsafe.Pointer(&r.variant)) }

func (r memoryWord) gr() float32 { return *(*float32)(unsafe.Pointer(&r.variant)) }

func (r *memoryWord) pGr() *float32 { return (*float32)(unsafe.Pointer(&r.variant)) }

func (r memoryWord) hh() twoHalves { return *(*twoHalves)(unsafe.Pointer(&r.variant)) }

func (r *memoryWord) pHh() *twoHalves { return (*twoHalves)(unsafe.Pointer(&r.variant)) }

func (r memoryWord) qqqq() fourQuarters { return *(*fourQuarters)(unsafe.Pointer(&r.variant)) }

func (r *memoryWord) pQqqq() *fourQuarters { return (*fourQuarters)(unsafe.Pointer(&r.variant)) }

type listStateRecord struct {
	modeField int16
	headField uint16
	tailField uint16
	pgField   int32
	mlField   int32
	auxField  memoryWord
}

type inStateRecord struct {
	stateField byte
	indexField byte
	startField uint16
	locField   uint16
	limitField uint16
	nameField  uint16
}

type Context struct {
	stdin                io.ReadCloser
	stdout               io.WriteCloser
	bad                  int32               // integer
	xord                 [256]byte           // array[char] of 0..255
	xchr                 [256]byte           // array[0..255] of char
	nameOfFile           [40]byte            // array[1..40] of char
	nameLength           byte                // 0..40
	buffer               [501]byte           // array[0..500] of 0..255
	first                uint16              // 0..500
	last                 uint16              // 0..500
	maxBufStack          uint16              // 0..500
	termIn               pasFile             // file of char
	termOut              pasFile             // file of char
	strPool              [32001]byte         // array[0..32000] of 0..255
	strStart             [3001]uint16        // array[0..3000] of 0..32000
	poolPtr              uint16              // 0..32000
	strPtr               uint16              // 0..3000
	initPoolPtr          uint16              // 0..32000
	initStrPtr           uint16              // 0..3000
	poolFile             pasFile             // file of char
	logFile              pasFile             // file of char
	selector             byte                // 0..21
	dig                  [23]byte            // array[0..22] of 0..15
	tally                int32               // integer
	termOffset           byte                // 0..79
	fileOffset           byte                // 0..79
	trickBuf             [73]byte            // array[0..72] of 0..255
	trickCount           int32               // integer
	firstCount           int32               // integer
	interaction          byte                // 0..3
	deletionsAllowed     bool                // boolean
	setBoxAllowed        bool                // boolean
	history              byte                // 0..3
	errorCount           int8                // -1..100
	helpLine             [6]uint16           // array[0..5] of 0..3000
	helpPtr              byte                // 0..6
	useErrHelp           bool                // boolean
	interrupt            int32               // integer
	OKToInterrupt        bool                // boolean
	arithError           bool                // boolean
	remainder            int32               // integer
	tempPtr              uint16              // 0..65535
	mem                  [30001]memoryWord   // array[0..30000] of record memoryWord
	loMemMax             uint16              // 0..65535
	hiMemMin             uint16              // 0..65535
	varUsed              int32               // integer
	dynUsed              int32               // integer
	avail                uint16              // 0..65535
	memEnd               uint16              // 0..65535
	rover                uint16              // 0..65535
	fontInShortDisplay   int32               // integer
	depthThreshold       int32               // integer
	breadthMax           int32               // integer
	nest                 [41]listStateRecord // array[0..40] of record listStateRecord
	nestPtr              byte                // 0..40
	maxNestStack         byte                // 0..40
	curList              listStateRecord     // record listStateRecord
	shownMode            int16               // -203..203
	oldSetting           byte                // 0..21
	sysTime              int32               // integer
	sysDay               int32               // integer
	sysMonth             int32               // integer
	sysYear              int32               // integer
	eqtb                 [6106]memoryWord    // array[1..6106] of record memoryWord
	xeqLevel             [844]byte           // array[5263..6106] of 0..255
	hash                 [2367]twoHalves     // array[514..2880] of record twoHalves
	hashUsed             uint16              // 0..65535
	noNewControlSequence bool                // boolean
	csCount              int32               // integer
	saveStack            [601]memoryWord     // array[0..600] of record memoryWord
	savePtr              uint16              // 0..600
	maxSaveStack         uint16              // 0..600
	curLevel             byte                // 0..255
	curGroup             byte                // 0..16
	curBoundary          uint16              // 0..600
	magSet               int32               // integer
	curCmd               byte                // 0..255
	curChr               uint16              // 0..65535
	curCs                uint16              // 0..65535
	curTok               uint16              // 0..65535
	inputStack           [201]inStateRecord  // array[0..200] of record inStateRecord
	inputPtr             byte                // 0..200
	maxInStack           byte                // 0..200
	curInput             inStateRecord       // record inStateRecord
	inOpen               byte                // 0..6
	openParens           byte                // 0..6
	inputFile            [6]pasFile          // array[1..6] of file of char
	line                 int32               // integer
	lineStack            [6]int32            // array[1..6] of integer
	scannerStatus        byte                // 0..5
	warningIndex         uint16              // 0..65535
	defRef               uint16              // 0..65535
	paramStack           [61]uint16          // array[0..60] of 0..65535
	paramPtr             byte                // 0..60
	maxParamStack        int32               // integer
	alignState           int32               // integer
	basePtr              byte                // 0..200
	parLoc               uint16              // 0..65535
	parToken             uint16              // 0..65535
	forceEof             bool                // boolean
	curMark              [5]uint16           // array[0..4] of 0..65535
	longState            byte                // 111..114
	pstack               [9]uint16           // array[0..8] of 0..65535
	curVal               int32               // integer
	curValLevel          byte                // 0..5
	radix                byte                // 0..63
	curOrder             byte                // 0..3
	readFile             [16]pasFile         // array[0..15] of file of char
	readOpen             [17]byte            // array[0..16] of 0..2
	condPtr              uint16              // 0..65535
	ifLimit              byte                // 0..4
	curIf                byte                // 0..63
	ifLine               int32               // integer
	skipLine             int32               // integer
	curName              uint16              // 0..3000
	curArea              uint16              // 0..3000
	curExt               uint16              // 0..3000
	areaDelimiter        uint16              // 0..32000
	extDelimiter         uint16              // 0..32000
	TEXFormatDefault     [20]byte            // array[1..20] of char
	nameInProgress       bool                // boolean
	jobName              uint16              // 0..3000
	logOpened            bool                // boolean
	dviFile              pasFile             // file of 0..255
	outputFileName       uint16              // 0..3000
	logName              uint16              // 0..3000
	tfmFile              pasFile             // file of 0..255
	fontInfo             [20001]memoryWord   // array[0..20000] of record memoryWord
	fmemPtr              uint16              // 0..20000
	fontPtr              byte                // 0..75
	fontCheck            [76]fourQuarters    // array[0..75] of record fourQuarters
	fontSize             [76]int32           // array[0..75] of integer
	fontDsize            [76]int32           // array[0..75] of integer
	fontParams           [76]uint16          // array[0..75] of 0..20000
	fontName             [76]uint16          // array[0..75] of 0..3000
	fontArea             [76]uint16          // array[0..75] of 0..3000
	fontBc               [76]byte            // array[0..75] of 0..255
	fontEc               [76]byte            // array[0..75] of 0..255
	fontGlue             [76]uint16          // array[0..75] of 0..65535
	fontUsed             [76]bool            // array[0..75] of boolean
	hyphenChar           [76]int32           // array[0..75] of integer
	skewChar             [76]int32           // array[0..75] of integer
	bcharLabel           [76]uint16          // array[0..75] of 0..20000
	fontBchar            [76]uint16          // array[0..75] of 0..256
	fontFalseBchar       [76]uint16          // array[0..75] of 0..256
	charBase             [76]int32           // array[0..75] of integer
	widthBase            [76]int32           // array[0..75] of integer
	heightBase           [76]int32           // array[0..75] of integer
	depthBase            [76]int32           // array[0..75] of integer
	italicBase           [76]int32           // array[0..75] of integer
	ligKernBase          [76]int32           // array[0..75] of integer
	kernBase             [76]int32           // array[0..75] of integer
	extenBase            [76]int32           // array[0..75] of integer
	paramBase            [76]int32           // array[0..75] of integer
	nullCharacter        fourQuarters        // record fourQuarters
	totalPages           int32               // integer
	maxV                 int32               // integer
	maxH                 int32               // integer
	maxPush              int32               // integer
	lastBop              int32               // integer
	deadCycles           int32               // integer
	doingLeaders         bool                // boolean
	c                    byte                // 0..255
	f                    byte                // 0..255
	ruleHt               int32               // integer
	ruleDp               int32               // integer
	ruleWd               int32               // integer
	g                    uint16              // 0..65535
	lq                   int32               // integer
	lr                   int32               // integer
	dviBuf               [801]byte           // array[0..800] of 0..255
	halfBuf              uint16              // 0..800
	dviLimit             uint16              // 0..800
	dviPtr               uint16              // 0..800
	dviOffset            int32               // integer
	dviGone              int32               // integer
	downPtr              uint16              // 0..65535
	rightPtr             uint16              // 0..65535
	dviH                 int32               // integer
	dviV                 int32               // integer
	curH                 int32               // integer
	curV                 int32               // integer
	dviF                 byte                // 0..75
	curS                 int32               // integer
	totalStretch         [4]int32            // array[0..3] of integer
	totalShrink          [4]int32            // array[0..3] of integer
	lastBadness          int32               // integer
	adjustTail           uint16              // 0..65535
	packBeginLine        int32               // integer
	emptyField           twoHalves           // record twoHalves
	nullDelimiter        fourQuarters        // record fourQuarters
	curMlist             uint16              // 0..65535
	curStyle             byte                // 0..63
	curSize              byte                // 0..63
	curMu                int32               // integer
	mlistPenalties       bool                // boolean
	curF                 byte                // 0..75
	curC                 byte                // 0..255
	curI                 fourQuarters        // record fourQuarters
	magicOffset          int32               // integer
	curAlign             uint16              // 0..65535
	curSpan              uint16              // 0..65535
	curLoop              uint16              // 0..65535
	alignPtr             uint16              // 0..65535
	curHead              uint16              // 0..65535
	curTail              uint16              // 0..65535
	justBox              uint16              // 0..65535
	passive              uint16              // 0..65535
	printedNode          uint16              // 0..65535
	passNumber           uint16              // 0..65535
	activeWidth          [6]int32            // array[1..6] of integer
	curActiveWidth       [6]int32            // array[1..6] of integer
	background           [6]int32            // array[1..6] of integer
	breakWidth           [6]int32            // array[1..6] of integer
	noShrinkErrorYet     bool                // boolean
	curP                 uint16              // 0..65535
	secondPass           bool                // boolean
	finalPass            bool                // boolean
	threshold            int32               // integer
	minimalDemerits      [4]int32            // array[0..3] of integer
	minimumDemerits      int32               // integer
	bestPlace            [4]uint16           // array[0..3] of 0..65535
	bestPlLine           [4]uint16           // array[0..3] of 0..65535
	discWidth            int32               // integer
	easyLine             uint16              // 0..65535
	lastSpecialLine      uint16              // 0..65535
	firstWidth           int32               // integer
	secondWidth          int32               // integer
	firstIndent          int32               // integer
	secondIndent         int32               // integer
	bestBet              uint16              // 0..65535
	fewestDemerits       int32               // integer
	bestLine             uint16              // 0..65535
	actualLooseness      int32               // integer
	lineDiff             int32               // integer
	hc                   [66]uint16          // array[0..65] of 0..256
	hn                   byte                // 0..64
	ha                   uint16              // 0..65535
	hb                   uint16              // 0..65535
	hf                   byte                // 0..75
	hu                   [64]uint16          // array[0..63] of 0..256
	hyfChar              int32               // integer
	curLang              byte                // 0..255
	initCurLang          byte                // 0..255
	lHyf                 int32               // integer
	rHyf                 int32               // integer
	initLHyf             int32               // integer
	initRHyf             int32               // integer
	hyfBchar             uint16              // 0..65535
	hyf                  [65]byte            // array[0..64] of 0..9
	initList             uint16              // 0..65535
	initLig              bool                // boolean
	initLft              bool                // boolean
	hyphenPassed         byte                // 0..63
	curL                 uint16              // 0..65535
	curR                 uint16              // 0..65535
	curQ                 uint16              // 0..65535
	ligStack             uint16              // 0..65535
	ligaturePresent      bool                // boolean
	lftHit               bool                // boolean
	rtHit                bool                // boolean
	trie                 [8001]twoHalves     // array[0..8000] of record twoHalves
	hyfDistance          [500]byte           // array[1..500] of 0..63
	hyfNum               [500]byte           // array[1..500] of 0..63
	hyfNext              [500]byte           // array[1..500] of 0..255
	opStart              [256]uint16         // array[0..255] of 0..500
	hyphWord             [308]uint16         // array[0..307] of 0..3000
	hyphList             [308]uint16         // array[0..307] of 0..65535
	hyphCount            uint16              // 0..307
	trieOpHash           [1001]uint16        // array[-500..500] of 0..500
	trieUsed             [256]byte           // array[0..255] of 0..255
	trieOpLang           [500]byte           // array[1..500] of 0..255
	trieOpVal            [500]byte           // array[1..500] of 0..255
	trieOpPtr            uint16              // 0..500
	trieC                [8001]byte          // array[0..8000] of 0..255
	trieO                [8001]byte          // array[0..8000] of 0..255
	trieL                [8001]uint16        // array[0..8000] of 0..8000
	trieR                [8001]uint16        // array[0..8000] of 0..8000
	triePtr              uint16              // 0..8000
	trieHash             [8001]uint16        // array[0..8000] of 0..8000
	trieTaken            [8000]bool          // array[1..8000] of boolean
	trieMin              [256]uint16         // array[0..255] of 0..8000
	trieMax              uint16              // 0..8000
	trieNotReady         bool                // boolean
	bestHeightPlusDepth  int32               // integer
	pageTail             uint16              // 0..65535
	pageContents         byte                // 0..2
	pageMaxDepth         int32               // integer
	bestPageBreak        uint16              // 0..65535
	leastPageCost        int32               // integer
	bestSize             int32               // integer
	pageSoFar            [8]int32            // array[0..7] of integer
	lastGlue             uint16              // 0..65535
	lastPenalty          int32               // integer
	lastKern             int32               // integer
	insertPenalties      int32               // integer
	outputActive         bool                // boolean
	mainF                byte                // 0..75
	mainI                fourQuarters        // record fourQuarters
	mainJ                fourQuarters        // record fourQuarters
	mainK                uint16              // 0..20000
	mainP                uint16              // 0..65535
	mainS                int32               // integer
	bchar                uint16              // 0..65535
	falseBchar           uint16              // 0..65535
	cancelBoundary       bool                // boolean
	insDisc              bool                // boolean
	curBox               uint16              // 0..65535
	afterToken           uint16              // 0..65535
	longHelpSeen         bool                // boolean
	formatIdent          uint16              // 0..3000
	fmtFile              pasFile             // file of record memoryWord
	readyAlready         int32               // integer
	writeFile            [16]pasFile         // array[0..15] of file of char
	writeOpen            [18]bool            // array[0..17] of boolean
	writeLoc             uint16              // 0..65535
}

func (tex *Context) initialize() {
	var i int32  // integer
	var k int32  // integer
	var z uint16 // 0..307
	tex.xchr[32] = ' '
	tex.xchr[33] = '!'
	tex.xchr[34] = '"'
	tex.xchr[35] = '#'
	tex.xchr[36] = '$'
	tex.xchr[37] = '%'
	tex.xchr[38] = '&'
	tex.xchr[39] = '\''
	tex.xchr[40] = '('
	tex.xchr[41] = ')'
	tex.xchr[42] = '*'
	tex.xchr[43] = '+'
	tex.xchr[44] = ','
	tex.xchr[45] = '-'
	tex.xchr[46] = '.'
	tex.xchr[47] = '/'
	tex.xchr[48] = '0'
	tex.xchr[49] = '1'
	tex.xchr[50] = '2'
	tex.xchr[51] = '3'
	tex.xchr[52] = '4'
	tex.xchr[53] = '5'
	tex.xchr[54] = '6'
	tex.xchr[55] = '7'
	tex.xchr[56] = '8'
	tex.xchr[57] = '9'
	tex.xchr[58] = ':'
	tex.xchr[59] = ';'
	tex.xchr[60] = '<'
	tex.xchr[61] = '='
	tex.xchr[62] = '>'
	tex.xchr[63] = '?'
	tex.xchr[64] = '@'
	tex.xchr[65] = 'A'
	tex.xchr[66] = 'B'
	tex.xchr[67] = 'C'
	tex.xchr[68] = 'D'
	tex.xchr[69] = 'E'
	tex.xchr[70] = 'F'
	tex.xchr[71] = 'G'
	tex.xchr[72] = 'H'
	tex.xchr[73] = 'I'
	tex.xchr[74] = 'J'
	tex.xchr[75] = 'K'
	tex.xchr[76] = 'L'
	tex.xchr[77] = 'M'
	tex.xchr[78] = 'N'
	tex.xchr[79] = 'O'
	tex.xchr[80] = 'P'
	tex.xchr[81] = 'Q'
	tex.xchr[82] = 'R'
	tex.xchr[83] = 'S'
	tex.xchr[84] = 'T'
	tex.xchr[85] = 'U'
	tex.xchr[86] = 'V'
	tex.xchr[87] = 'W'
	tex.xchr[88] = 'X'
	tex.xchr[89] = 'Y'
	tex.xchr[90] = 'Z'
	tex.xchr[91] = '['
	tex.xchr[92] = '\\'
	tex.xchr[93] = ']'
	tex.xchr[94] = '^'
	tex.xchr[95] = '_'
	tex.xchr[96] = '`'
	tex.xchr[97] = 'a'
	tex.xchr[98] = 'b'
	tex.xchr[99] = 'c'
	tex.xchr[100] = 'd'
	tex.xchr[101] = 'e'
	tex.xchr[102] = 'f'
	tex.xchr[103] = 'g'
	tex.xchr[104] = 'h'
	tex.xchr[105] = 'i'
	tex.xchr[106] = 'j'
	tex.xchr[107] = 'k'
	tex.xchr[108] = 'l'
	tex.xchr[109] = 'm'
	tex.xchr[110] = 'n'
	tex.xchr[111] = 'o'
	tex.xchr[112] = 'p'
	tex.xchr[113] = 'q'
	tex.xchr[114] = 'r'
	tex.xchr[115] = 's'
	tex.xchr[116] = 't'
	tex.xchr[117] = 'u'
	tex.xchr[118] = 'v'
	tex.xchr[119] = 'w'
	tex.xchr[120] = 'x'
	tex.xchr[121] = 'y'
	tex.xchr[122] = 'z'
	tex.xchr[123] = '{'
	tex.xchr[124] = '|'
	tex.xchr[125] = '}'
	tex.xchr[126] = '~'
	for _i := int64(0); _i <= int64(31); _i++ {
		i = int32(_i)
		tex.xchr[i] = ' '
	}
	for _i := int64(127); _i <= int64(255); _i++ {
		i = int32(_i)
		tex.xchr[i] = ' '
	}
	for _i := int64(0); _i <= int64(255); _i++ {
		i = int32(_i)
		tex.xord[chr(i)] = 127
	}
	for _i := int64(128); _i <= int64(255); _i++ {
		i = int32(_i)
		tex.xord[tex.xchr[i]] = byte(i)
	}
	for _i := int64(0); _i <= int64(126); _i++ {
		i = int32(_i)
		tex.xord[tex.xchr[i]] = byte(i)
	}
	tex.interaction = 3
	tex.deletionsAllowed = true
	tex.setBoxAllowed = true
	tex.errorCount = 0
	tex.helpPtr = 0
	tex.useErrHelp = false
	tex.interrupt = 0
	tex.OKToInterrupt = true
	tex.nestPtr = 0
	tex.maxNestStack = 0
	tex.curList.modeField = 1
	tex.curList.headField = 29999
	tex.curList.tailField = 29999
	*tex.curList.auxField.pInt() = -65536000
	tex.curList.mlField = 0
	tex.curList.pgField = 0
	tex.shownMode = 0
	tex.pageContents = 0
	tex.pageTail = 29998
	tex.mem[29998].pHh().rh = 0
	tex.lastGlue = 65535
	tex.lastPenalty = 0
	tex.lastKern = 0
	tex.pageSoFar[7] = 0
	tex.pageMaxDepth = 0
	for _i := int64(5263); _i <= int64(6106); _i++ {
		k = int32(_i)
		tex.xeqLevel[k-5263] = 1
	}
	tex.noNewControlSequence = true
	*tex.hash[514-514].pLh() = 0
	tex.hash[514-514].rh = 0
	for _i := int64(515); _i <= int64(2880); _i++ {
		k = int32(_i)
		tex.hash[k-514] = tex.hash[514-514]
	}
	tex.savePtr = 0
	tex.curLevel = 1
	tex.curGroup = 0
	tex.curBoundary = 0
	tex.maxSaveStack = 0
	tex.magSet = 0
	tex.curMark[0] = 0
	tex.curMark[1] = 0
	tex.curMark[2] = 0
	tex.curMark[3] = 0
	tex.curMark[4] = 0
	tex.curVal = 0
	tex.curValLevel = 0
	tex.radix = 0
	tex.curOrder = 0
	for _i := int64(0); _i <= int64(16); _i++ {
		k = int32(_i)
		tex.readOpen[k] = 2
	}
	tex.condPtr = 0
	tex.ifLimit = 0
	tex.curIf = 0
	tex.ifLine = 0
	setString(tex.TEXFormatDefault[:], "TeXformats:plain.fmt")
	for _i := int64(0); _i <= int64(fontMax); _i++ {
		k = int32(_i)
		tex.fontUsed[k] = false
	}
	tex.nullCharacter.b0 = 0
	tex.nullCharacter.b1 = 0
	tex.nullCharacter.b2 = 0
	tex.nullCharacter.b3 = 0
	tex.totalPages = 0
	tex.maxV = 0
	tex.maxH = 0
	tex.maxPush = 0
	tex.lastBop = -1
	tex.doingLeaders = false
	tex.deadCycles = 0
	tex.curS = -1
	tex.halfBuf = uint16((dviBufSize / 2))
	tex.dviLimit = dviBufSize
	tex.dviPtr = 0
	tex.dviOffset = 0
	tex.dviGone = 0
	tex.downPtr = 0
	tex.rightPtr = 0
	tex.adjustTail = 0
	tex.lastBadness = 0
	tex.packBeginLine = 0
	tex.emptyField.rh = 0
	*tex.emptyField.pLh() = 0
	tex.nullDelimiter.b0 = 0
	tex.nullDelimiter.b1 = 0
	tex.nullDelimiter.b2 = 0
	tex.nullDelimiter.b3 = 0
	tex.alignPtr = 0
	tex.curAlign = 0
	tex.curSpan = 0
	tex.curLoop = 0
	tex.curHead = 0
	tex.curTail = 0
	for _i := int64(0); _i <= int64(307); _i++ {
		z = uint16(_i)
		tex.hyphWord[z] = 0
		tex.hyphList[z] = 0
	}
	tex.hyphCount = 0
	tex.outputActive = false
	tex.insertPenalties = 0
	tex.ligaturePresent = false
	tex.cancelBoundary = false
	tex.lftHit = false
	tex.rtHit = false
	tex.insDisc = false
	tex.afterToken = 0
	tex.longHelpSeen = false
	tex.formatIdent = 0
	for _i := int64(0); _i <= int64(17); _i++ {
		k = int32(_i)
		tex.writeOpen[k] = false
	}
	for _i := int64(1); _i <= int64(19); _i++ {
		k = int32(_i)
		*tex.mem[k].pInt() = 0
	}
	k = 0
	for k <= 19 {
		tex.mem[k].pHh().rh = 1
		*tex.mem[k].pHh().pB0() = 0
		*tex.mem[k].pHh().pB1() = 0
		k = k + 4
	}
	*tex.mem[6].pInt() = 65536
	*tex.mem[4].pHh().pB0() = 1
	*tex.mem[10].pInt() = 65536
	*tex.mem[8].pHh().pB0() = 2
	*tex.mem[14].pInt() = 65536
	*tex.mem[12].pHh().pB0() = 1
	*tex.mem[15].pInt() = 65536
	*tex.mem[12].pHh().pB1() = 1
	*tex.mem[18].pInt() = -65536
	*tex.mem[16].pHh().pB0() = 1
	tex.rover = 20
	tex.mem[tex.rover].pHh().rh = 65535
	*tex.mem[tex.rover].pHh().pLh() = 1000
	*tex.mem[int32(tex.rover)+1].pHh().pLh() = tex.rover
	tex.mem[int32(tex.rover)+1].pHh().rh = tex.rover
	tex.loMemMax = uint16(int32(tex.rover) + 1000)
	tex.mem[tex.loMemMax].pHh().rh = 0
	*tex.mem[tex.loMemMax].pHh().pLh() = 0
	for _i := int64(29987); _i <= int64(30000); _i++ {
		k = int32(_i)
		tex.mem[k] = tex.mem[tex.loMemMax]
	}
	*tex.mem[29990].pHh().pLh() = 6714
	tex.mem[29991].pHh().rh = 256
	*tex.mem[29991].pHh().pLh() = 0
	*tex.mem[29993].pHh().pB0() = 1
	*tex.mem[29994].pHh().pLh() = 65535
	*tex.mem[29993].pHh().pB1() = 0
	*tex.mem[30000].pHh().pB1() = 255
	*tex.mem[30000].pHh().pB0() = 1
	tex.mem[30000].pHh().rh = 30000
	*tex.mem[29998].pHh().pB0() = 10
	*tex.mem[29998].pHh().pB1() = 0
	tex.avail = 0
	tex.memEnd = 30000
	tex.hiMemMin = 29987
	tex.varUsed = 20
	tex.dynUsed = 14
	*tex.eqtb[2881-1].pHh().pB0() = 101
	tex.eqtb[2881-1].pHh().rh = 0
	*tex.eqtb[2881-1].pHh().pB1() = 0
	for _i := int64(1); _i <= int64(2880); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[2881-1]
	}
	tex.eqtb[2882-1].pHh().rh = 0
	*tex.eqtb[2882-1].pHh().pB1() = 1
	*tex.eqtb[2882-1].pHh().pB0() = 117
	for _i := int64(2883); _i <= int64(3411); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[2882-1]
	}
	tex.mem[0].pHh().rh = uint16(int32(tex.mem[0].hh().rh) + 530)
	tex.eqtb[3412-1].pHh().rh = 0
	*tex.eqtb[3412-1].pHh().pB0() = 118
	*tex.eqtb[3412-1].pHh().pB1() = 1
	for _i := int64(3413); _i <= int64(3677); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[2881-1]
	}
	tex.eqtb[3678-1].pHh().rh = 0
	*tex.eqtb[3678-1].pHh().pB0() = 119
	*tex.eqtb[3678-1].pHh().pB1() = 1
	for _i := int64(3679); _i <= int64(3933); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[3678-1]
	}
	tex.eqtb[3934-1].pHh().rh = 0
	*tex.eqtb[3934-1].pHh().pB0() = 120
	*tex.eqtb[3934-1].pHh().pB1() = 1
	for _i := int64(3935); _i <= int64(3982); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[3934-1]
	}
	tex.eqtb[3983-1].pHh().rh = 0
	*tex.eqtb[3983-1].pHh().pB0() = 120
	*tex.eqtb[3983-1].pHh().pB1() = 1
	for _i := int64(3984); _i <= int64(5262); _i++ {
		k = int32(_i)
		tex.eqtb[k-1] = tex.eqtb[3983-1]
	}
	for _i := int64(0); _i <= int64(255); _i++ {
		k = int32(_i)
		tex.eqtb[3983+k-1].pHh().rh = 12
		tex.eqtb[5007+k-1].pHh().rh = uint16(k + 0)
		tex.eqtb[4751+k-1].pHh().rh = 1000
	}
	tex.eqtb[3996-1].pHh().rh = 5
	tex.eqtb[4015-1].pHh().rh = 10
	tex.eqtb[4075-1].pHh().rh = 0
	tex.eqtb[4020-1].pHh().rh = 14
	tex.eqtb[4110-1].pHh().rh = 15
	tex.eqtb[3983-1].pHh().rh = 9
	for _i := int64(48); _i <= int64(57); _i++ {
		k = int32(_i)
		tex.eqtb[5007+k-1].pHh().rh = uint16(k + 28672)
	}
	for _i := int64(65); _i <= int64(90); _i++ {
		k = int32(_i)
		tex.eqtb[3983+k-1].pHh().rh = 11
		tex.eqtb[3983+k+32-1].pHh().rh = 11
		tex.eqtb[5007+k-1].pHh().rh = uint16(k + 28928)
		tex.eqtb[5007+k+32-1].pHh().rh = uint16(k + 28960)
		tex.eqtb[4239+k-1].pHh().rh = uint16(k + 32)
		tex.eqtb[4239+k+32-1].pHh().rh = uint16(k + 32)
		tex.eqtb[4495+k-1].pHh().rh = uint16(k)
		tex.eqtb[4495+k+32-1].pHh().rh = uint16(k)
		tex.eqtb[4751+k-1].pHh().rh = 999
	}
	for _i := int64(5263); _i <= int64(5573); _i++ {
		k = int32(_i)
		*tex.eqtb[k-1].pInt() = 0
	}
	*tex.eqtb[5280-1].pInt() = 1000
	*tex.eqtb[5264-1].pInt() = 10000
	*tex.eqtb[5304-1].pInt() = 1
	*tex.eqtb[5303-1].pInt() = 25
	*tex.eqtb[5308-1].pInt() = 92
	*tex.eqtb[5311-1].pInt() = 13
	for _i := int64(0); _i <= int64(255); _i++ {
		k = int32(_i)
		*tex.eqtb[5574+k-1].pInt() = -1
	}
	*tex.eqtb[5620-1].pInt() = 0
	for _i := int64(5830); _i <= int64(6106); _i++ {
		k = int32(_i)
		*tex.eqtb[k-1].pInt() = 0
	}
	tex.hashUsed = 2614
	tex.csCount = 0
	*tex.eqtb[2623-1].pHh().pB0() = 116
	tex.hash[2623-514].rh = 502
	tex.fontPtr = 0
	tex.fmemPtr = 7
	tex.fontName[0] = 801
	tex.fontArea[0] = 338
	tex.hyphenChar[0] = 45
	tex.skewChar[0] = -1
	tex.bcharLabel[0] = 0
	tex.fontBchar[0] = 256
	tex.fontFalseBchar[0] = 256
	tex.fontBc[0] = 1
	tex.fontEc[0] = 0
	tex.fontSize[0] = 0
	tex.fontDsize[0] = 0
	tex.charBase[0] = 0
	tex.widthBase[0] = 0
	tex.heightBase[0] = 0
	tex.depthBase[0] = 0
	tex.italicBase[0] = 0
	tex.ligKernBase[0] = 0
	tex.kernBase[0] = 0
	tex.extenBase[0] = 0
	tex.fontGlue[0] = 0
	tex.fontParams[0] = 7
	tex.paramBase[0] = -1
	for _i := int64(0); _i <= int64(6); _i++ {
		k = int32(_i)
		*tex.fontInfo[k].pInt() = 0
	}
	for _i := int64(-trieOpSize); _i <= int64(trieOpSize); _i++ {
		k = int32(_i)
		tex.trieOpHash[k+500] = 0
	}
	for _i := int64(0); _i <= int64(255); _i++ {
		k = int32(_i)
		tex.trieUsed[k] = 0
	}
	tex.trieOpPtr = 0
	tex.trieNotReady = true
	tex.trieL[0] = 0
	tex.trieC[0] = 0
	tex.triePtr = 0
	tex.hash[2614-514].rh = 1190
	tex.formatIdent = 1257
	tex.hash[2622-514].rh = 1296
	*tex.eqtb[2622-1].pHh().pB1() = 1
	*tex.eqtb[2622-1].pHh().pB0() = 113
	tex.eqtb[2622-1].pHh().rh = 0
}

func (tex *Context) printLn() {
	switch tex.selector {
	case 19:
		writeLn(&tex.termOut)
		writeLn(&tex.logFile)
		tex.termOffset = 0
		tex.fileOffset = 0
	case 18:
		writeLn(&tex.logFile)
		tex.fileOffset = 0
	case 17:
		writeLn(&tex.termOut)
		tex.termOffset = 0
	case 16, 20, 21:
	default:
		writeLn(&tex.writeFile[tex.selector])
	}
}

func (tex *Context) printChar(s byte) {
	if int32(s) == tex.eqtb[5312-1].int() {
		if tex.selector < 20 {
			tex.printLn()
			goto label10
		}
	}
	switch tex.selector {
	case 19:
		write(&tex.termOut, tex.xchr[s])
		write(&tex.logFile, tex.xchr[s])
		tex.termOffset = byte(int32(tex.termOffset) + 1)
		tex.fileOffset = byte(int32(tex.fileOffset) + 1)
		if tex.termOffset == maxPrintLine {
			writeLn(&tex.termOut)
			tex.termOffset = 0
		}
		if tex.fileOffset == maxPrintLine {
			writeLn(&tex.logFile)
			tex.fileOffset = 0
		}
	case 18:
		write(&tex.logFile, tex.xchr[s])
		tex.fileOffset = byte(int32(tex.fileOffset) + 1)
		if tex.fileOffset == maxPrintLine {
			tex.printLn()
		}
	case 17:
		write(&tex.termOut, tex.xchr[s])
		tex.termOffset = byte(int32(tex.termOffset) + 1)
		if tex.termOffset == maxPrintLine {
			tex.printLn()
		}
	case 16:
	case 20:
		if tex.tally < tex.trickCount {
			tex.trickBuf[(tex.tally % errorLine)] = s
		}
	case 21:
		if tex.poolPtr < poolSize {
			tex.strPool[tex.poolPtr] = s
			tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
		}
	default:
		write(&tex.writeFile[tex.selector], tex.xchr[s])
	}
	tex.tally = tex.tally + 1
label10:
}

func (tex *Context) print(s int32) {
	var j uint16 // 0..32000
	var nl int32 // integer
	if s >= int32(tex.strPtr) {
		s = 259
	} else if s < 256 {
		if s < 0 {
			s = 259
		} else {
			if tex.selector > 20 {
				tex.printChar(byte(s))
				goto label10
			}
			if s == tex.eqtb[5312-1].int() {
				if tex.selector < 20 {
					tex.printLn()
					goto label10
				}
			}
			nl = tex.eqtb[5312-1].int()
			*tex.eqtb[5312-1].pInt() = -1
			j = tex.strStart[s]
			for j < tex.strStart[s+1] {
				tex.printChar(tex.strPool[j])
				j = uint16(int32(j) + 1)
			}
			*tex.eqtb[5312-1].pInt() = nl
			goto label10
		}
	}
	j = tex.strStart[s]
	for j < tex.strStart[s+1] {
		tex.printChar(tex.strPool[j])
		j = uint16(int32(j) + 1)
	}
label10:
}

func (tex *Context) slowPrint(s int32) {
	var j uint16 // 0..32000
	if (s >= int32(tex.strPtr)) || (s < 256) {
		tex.print(s)
	} else {
		j = tex.strStart[s]
		for j < tex.strStart[s+1] {
			tex.print(int32(tex.strPool[j]))
			j = uint16(int32(j) + 1)
		}
	}
}

func (tex *Context) printNl(s uint16) {
	if ((tex.termOffset > 0) && odd(int32(tex.selector))) || ((tex.fileOffset > 0) && (tex.selector >= 18)) {
		tex.printLn()
	}
	tex.print(int32(s))
}

func (tex *Context) printEsc(s uint16) {
	var c int32 // integer
	c = tex.eqtb[5308-1].int()
	if c >= 0 {
		if c < 256 {
			tex.print(c)
		}
	}
	tex.slowPrint(int32(s))
}

func (tex *Context) printTheDigs(k byte) {
	for k > 0 {
		k = byte(int32(k) - 1)
		if tex.dig[k] < 10 {
			tex.printChar(byte(48 + int32(tex.dig[k])))
		} else {
			tex.printChar(byte(55 + int32(tex.dig[k])))
		}
	}
}

func (tex *Context) printInt(n int32) {
	var k byte  // 0..23
	var m int32 // integer
	k = 0
	if n < 0 {
		tex.printChar(45)
		if n > -100000000 {
			n = -n
		} else {
			m = -1 - n
			n = (m / 10)
			m = (m % 10) + 1
			k = 1
			if m < 10 {
				tex.dig[0] = byte(m)
			} else {
				tex.dig[0] = 0
				n = n + 1
			}
		}
	}
	for {
		tex.dig[k] = byte((n % 10))
		n = (n / 10)
		k = byte(int32(k) + 1)
		if n == 0 {
			break
		}
	}
	tex.printTheDigs(k)
}

func (tex *Context) printCs(p int32) {
	if p < 514 {
		if p >= 257 {
			if p == 513 {
				tex.printEsc(504)
				tex.printEsc(505)
				tex.printChar(32)
			} else {
				tex.printEsc(uint16(p - 257))
				if tex.eqtb[3983+p-257-1].hh().rh == 11 {
					tex.printChar(32)
				}
			}
		} else if p < 1 {
			tex.printEsc(506)
		} else {
			tex.print(p - 1)
		}
	} else if p >= 2881 {
		tex.printEsc(506)
	} else if (tex.hash[p-514].rh < 0) || (tex.hash[p-514].rh >= tex.strPtr) {
		tex.printEsc(507)
	} else {
		tex.printEsc(tex.hash[p-514].rh)
		tex.printChar(32)
	}
}

func (tex *Context) sprintCs(p uint16) {
	if p < 514 {
		if p < 257 {
			tex.print(int32(p) - 1)
		} else if p < 513 {
			tex.printEsc(uint16(int32(p) - 257))
		} else {
			tex.printEsc(504)
			tex.printEsc(505)
		}
	} else {
		tex.printEsc(tex.hash[p-514].rh)
	}
}

func (tex *Context) printFileName(n, a, e int32) {
	tex.slowPrint(a)
	tex.slowPrint(n)
	tex.slowPrint(e)
}

func (tex *Context) printSize(s int32) {
	if s == 0 {
		tex.printEsc(412)
	} else if s == 16 {
		tex.printEsc(413)
	} else {
		tex.printEsc(414)
	}
}

func (tex *Context) printWriteWhatsit(s uint16, p uint16) {
	tex.printEsc(s)
	if tex.mem[int32(p)+1].hh().lh() < 16 {
		tex.printInt(int32(tex.mem[int32(p)+1].hh().lh()))
	} else if tex.mem[int32(p)+1].hh().lh() == 16 {
		tex.printChar(42)
	} else {
		tex.printChar(45)
	}
}

func (tex *Context) jumpOut() {
	panic(pasEndOfTeX)
}

func (tex *Context) error1() {
	var c byte               // 0..255
	var s1, s2, s3, s4 int32 // integer
	if tex.history < 2 {
		tex.history = 2
	}
	tex.printChar(46)
	tex.showContext()
	if tex.interaction == 3 {
		for true {
		label22:
			if tex.interaction != 3 {
				goto label10
			}
			tex.clearForErrorPrompt()
			tex.print(264)
			tex.termInput()
			if tex.last == tex.first {
				goto label10
			}
			c = tex.buffer[tex.first]
			if c >= 97 {
				c = byte(int32(c) - 32)
			}
			switch c {
			case 48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
				if tex.deletionsAllowed {
					s1 = int32(tex.curTok)
					s2 = int32(tex.curCmd)
					s3 = int32(tex.curChr)
					s4 = tex.alignState
					tex.alignState = 1000000
					tex.OKToInterrupt = false
					if (int32(tex.last) > (int32(tex.first) + 1)) && (tex.buffer[int32(tex.first)+1] >= 48) && (tex.buffer[int32(tex.first)+1] <= 57) {
						c = byte((int32(c) * 10) + int32(tex.buffer[int32(tex.first)+1]) - (48 * 11))
					} else {
						c = byte(int32(c) - 48)
					}
					for c > 0 {
						tex.getToken()
						c = byte(int32(c) - 1)
					}
					tex.curTok = uint16(s1)
					tex.curCmd = byte(s2)
					tex.curChr = uint16(s3)
					tex.alignState = s4
					tex.OKToInterrupt = true
					tex.helpPtr = 2
					tex.helpLine[1] = 279
					tex.helpLine[0] = 280
					tex.showContext()
					goto label22
				}
			case 69:
				if tex.basePtr > 0 {
					if tex.inputStack[tex.basePtr].nameField >= 256 {
						tex.printNl(265)
						tex.slowPrint(int32(tex.inputStack[tex.basePtr].nameField))
						tex.print(266)
						tex.printInt(tex.line)
						tex.interaction = 2
						tex.jumpOut()
					}
				}
			case 72:
				if tex.useErrHelp {
					tex.giveErrHelp()
					tex.useErrHelp = false
				} else {
					if tex.helpPtr == 0 {
						tex.helpPtr = 2
						tex.helpLine[1] = 281
						tex.helpLine[0] = 282
					}
					for {
						tex.helpPtr = byte(int32(tex.helpPtr) - 1)
						tex.print(int32(tex.helpLine[tex.helpPtr]))
						tex.printLn()
						if tex.helpPtr == 0 {
							break
						}
					}
				}
				tex.helpPtr = 4
				tex.helpLine[3] = 283
				tex.helpLine[2] = 282
				tex.helpLine[1] = 284
				tex.helpLine[0] = 285
				goto label22
			case 73:
				tex.beginFileReading()
				if int32(tex.last) > int32(tex.first)+1 {
					tex.curInput.locField = uint16(int32(tex.first) + 1)
					tex.buffer[tex.first] = 32
				} else {
					tex.print(278)
					tex.termInput()
					tex.curInput.locField = tex.first
				}
				tex.first = tex.last
				tex.curInput.limitField = uint16(int32(tex.last) - 1)
				goto label10
			case 81, 82, 83:
				tex.errorCount = 0
				tex.interaction = byte(0 + int32(c) - 81)
				tex.print(273)
				switch c {
				case 81:
					tex.printEsc(274)
					tex.selector = byte(int32(tex.selector) - 1)
				case 82:
					tex.printEsc(275)
				case 83:
					tex.printEsc(276)
				}
				tex.print(277)
				tex.printLn()
				break1(&tex.termOut)
				goto label10
			case 88:
				tex.interaction = 2
				tex.jumpOut()
			default:
			}
			tex.print(267)
			tex.printNl(268)
			tex.printNl(269)
			if tex.basePtr > 0 {
				if tex.inputStack[tex.basePtr].nameField >= 256 {
					tex.print(270)
				}
			}
			if tex.deletionsAllowed {
				tex.printNl(271)
			}
			tex.printNl(272)
		}
	}
	tex.errorCount = int8(int32(tex.errorCount) + 1)
	if tex.errorCount == 100 {
		tex.printNl(263)
		tex.history = 3
		tex.jumpOut()
	}
	if tex.interaction > 0 {
		tex.selector = byte(int32(tex.selector) - 1)
	}
	if tex.useErrHelp {
		tex.printLn()
		tex.giveErrHelp()
	} else {
		for tex.helpPtr > 0 {
			tex.helpPtr = byte(int32(tex.helpPtr) - 1)
			tex.printNl(tex.helpLine[tex.helpPtr])
		}
	}
	tex.printLn()
	if tex.interaction > 0 {
		tex.selector = byte(int32(tex.selector) + 1)
	}
	tex.printLn()
label10:
}

func (tex *Context) fatalError(s uint16) {
	tex.normalizeSelector()
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(287)
	tex.helpPtr = 1
	tex.helpLine[0] = s
	if tex.interaction == 3 {
		tex.interaction = 2
	}
	if tex.logOpened {
		tex.error1()
	}
	tex.history = 3
	tex.jumpOut()
}

func (tex *Context) overflow(s uint16, n int32) {
	tex.normalizeSelector()
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(288)
	tex.print(int32(s))
	tex.printChar(61)
	tex.printInt(n)
	tex.printChar(93)
	tex.helpPtr = 2
	tex.helpLine[1] = 289
	tex.helpLine[0] = 290
	if tex.interaction == 3 {
		tex.interaction = 2
	}
	if tex.logOpened {
		tex.error1()
	}
	tex.history = 3
	tex.jumpOut()
}

func (tex *Context) confusion(s uint16) {
	tex.normalizeSelector()
	if tex.history < 2 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(291)
		tex.print(int32(s))
		tex.printChar(41)
		tex.helpPtr = 1
		tex.helpLine[0] = 292
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(293)
		tex.helpPtr = 2
		tex.helpLine[1] = 294
		tex.helpLine[0] = 295
	}
	if tex.interaction == 3 {
		tex.interaction = 2
	}
	if tex.logOpened {
		tex.error1()
	}
	tex.history = 3
	tex.jumpOut()
}

func (tex *Context) aOpenIn(f *pasFile) (ret bool) {
	reset1(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) aOpenOut(f *pasFile) (ret bool) {
	rewrite1(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) bOpenIn(f *pasFile) (ret bool) {
	reset1(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) bOpenOut(f *pasFile) (ret bool) {
	rewrite1(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) wOpenIn(f *pasFile) (ret bool) {
	reset4(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) wOpenOut(f *pasFile) (ret bool) {
	rewrite4(tex, f, string(tex.nameOfFile[:]), "/O")
	ret = erstat(f) == 0
	return ret
}

func (tex *Context) aClose(f *pasFile) {
	close(f)
}

func (tex *Context) bClose(f *pasFile) {
	close(f)
}

func (tex *Context) wClose(f *pasFile) {
	close(f)
}

func (tex *Context) inputLn(f *pasFile, bypassEoln bool) (ret bool) {
	var lastNonblank uint16 // 0..500
	if bypassEoln {
		if !eof(f) {
			get(f)
		}
	}
	tex.last = tex.first
	if eof(f) {
		ret = false
	} else {
		lastNonblank = tex.first
		for !eoln(f) {
			if tex.last >= tex.maxBufStack {
				tex.maxBufStack = uint16(int32(tex.last) + 1)
				if tex.maxBufStack == bufSize {
					if tex.formatIdent == 0 {
						writeLn(&tex.termOut, "Buffer size exceeded!")
						panic(pasFinalEnd)
					} else {
						tex.curInput.locField = tex.first
						tex.curInput.limitField = uint16(int32(tex.last) - 1)
						tex.overflow(256, bufSize)
					}
				}
			}
			tex.buffer[tex.last] = tex.xord[f.byte()]
			get(f)
			tex.last = uint16(int32(tex.last) + 1)
			if tex.buffer[int32(tex.last)-1] != 32 {
				lastNonblank = tex.last
			}
		}
		tex.last = lastNonblank
		ret = true
	}
	return ret
}

func (tex *Context) initTerminal() (ret bool) {
	reset1(tex, &tex.termIn, "TTY:", "/O/I")
	for true {
		write(&tex.termOut, "**")
		break1(&tex.termOut)
		if !tex.inputLn(&tex.termIn, true) {
			writeLn(&tex.termOut)
			write(&tex.termOut, "! End of file on the terminal... why?")
			ret = false
			goto label10
		}
		tex.curInput.locField = tex.first
		for (tex.curInput.locField < tex.last) && (tex.buffer[tex.curInput.locField] == 32) {
			tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
		}
		if tex.curInput.locField < tex.last {
			ret = true
			goto label10
		}
		writeLn(&tex.termOut, "Please type the name of your input file.")
	}
label10:
	return ret
}

func (tex *Context) makeString() (ret uint16) {
	if tex.strPtr == maxStrings {
		tex.overflow(258, maxStrings-int32(tex.initStrPtr))
	}
	tex.strPtr = uint16(int32(tex.strPtr) + 1)
	tex.strStart[tex.strPtr] = tex.poolPtr
	ret = uint16(int32(tex.strPtr) - 1)
	return ret
}

func (tex *Context) strEqBuf(s uint16, k int32) (ret bool) {
	var j uint16    // 0..32000
	var result bool // boolean
	j = tex.strStart[s]
	for j < tex.strStart[int32(s)+1] {
		if tex.strPool[j] != tex.buffer[k] {
			result = false
			goto label45
		}
		j = uint16(int32(j) + 1)
		k = k + 1
	}
	result = true
label45:
	ret = result
	return ret
}

func (tex *Context) strEqStr(s, t uint16) (ret bool) {
	var j, k uint16 // 0..32000
	var result bool // boolean
	result = false
	if (int32(tex.strStart[int32(s)+1]) - int32(tex.strStart[s])) != (int32(tex.strStart[int32(t)+1]) - int32(tex.strStart[t])) {
		goto label45
	}
	j = tex.strStart[s]
	k = tex.strStart[t]
	for j < tex.strStart[int32(s)+1] {
		if tex.strPool[j] != tex.strPool[k] {
			goto label45
		}
		j = uint16(int32(j) + 1)
		k = uint16(int32(k) + 1)
	}
	result = true
label45:
	ret = result
	return ret
}

func (tex *Context) getStringsStarted() (ret bool) {
	var k, l byte // 0..255
	var m, n byte // char
	var a int32   // integer
	var c bool    // boolean
	tex.poolPtr = 0
	tex.strPtr = 0
	tex.strStart[0] = 0
	for _i := int64(0); _i <= int64(255); _i++ {
		k = byte(_i)
		if (k < 32) || (k > 126) {
			tex.strPool[tex.poolPtr] = 94
			tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
			tex.strPool[tex.poolPtr] = 94
			tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
			if k < 64 {
				tex.strPool[tex.poolPtr] = byte(int32(k) + 64)
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
			} else if k < 128 {
				tex.strPool[tex.poolPtr] = byte(int32(k) - 64)
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
			} else {
				l = byte((int32(k) / 16))
				if l < 10 {
					tex.strPool[tex.poolPtr] = byte(int32(l) + 48)
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				} else {
					tex.strPool[tex.poolPtr] = byte(int32(l) + 87)
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				}
				l = byte((int32(k) % 16))
				if l < 10 {
					tex.strPool[tex.poolPtr] = byte(int32(l) + 48)
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				} else {
					tex.strPool[tex.poolPtr] = byte(int32(l) + 87)
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				}
			}
		} else {
			tex.strPool[tex.poolPtr] = k
			tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
		}
		tex.makeString()
	}
	setString(tex.nameOfFile[:], poolName)
	if tex.aOpenIn(&tex.poolFile) {
		c = false
		for {
			if eof(&tex.poolFile) {
				writeLn(&tex.termOut, "! TEX.POOL has no check sum.")
				tex.aClose(&tex.poolFile)
				ret = false
				goto label10
			}
			read(&tex.poolFile, &m, &n)
			if m == '*' {
				a = 0
				k = 1
				for true {
					if (tex.xord[n] < 48) || (tex.xord[n] > 57) {
						writeLn(&tex.termOut, "! TEX.POOL check sum doesn't have nine digits.")
						tex.aClose(&tex.poolFile)
						ret = false
						goto label10
					}
					a = (10 * a) + int32(tex.xord[n]) - 48
					if k == 9 {
						goto label30
					}
					k = byte(int32(k) + 1)
					read(&tex.poolFile, &n)
				}
			label30:
				if a != 504454778 {
					writeLn(&tex.termOut, "! TEX.POOL doesn't match; TANGLE me again.")
					tex.aClose(&tex.poolFile)
					ret = false
					goto label10
				}
				c = true
			} else {
				if (tex.xord[m] < 48) || (tex.xord[m] > 57) || (tex.xord[n] < 48) || (tex.xord[n] > 57) {
					writeLn(&tex.termOut, "! TEX.POOL line doesn't begin with two digits.")
					tex.aClose(&tex.poolFile)
					ret = false
					goto label10
				}
				l = byte((int32(tex.xord[m]) * 10) + int32(tex.xord[n]) - (48 * 11))
				if int32(tex.poolPtr)+int32(l)+stringVacancies > poolSize {
					writeLn(&tex.termOut, "! You have to increase POOLSIZE.")
					tex.aClose(&tex.poolFile)
					ret = false
					goto label10
				}
				for _i := int64(1); _i <= int64(l); _i++ {
					k = byte(_i)
					if eoln(&tex.poolFile) {
						m = ' '
					} else {
						read(&tex.poolFile, &m)
					}
					tex.strPool[tex.poolPtr] = tex.xord[m]
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				}
				readLn(&tex.poolFile)
				tex.makeString()
			}
			if c {
				break
			}
		}
		tex.aClose(&tex.poolFile)
		ret = true
	} else {
		writeLn(&tex.termOut, "! I can't read TEX.POOL.")
		tex.aClose(&tex.poolFile)
		ret = false
		goto label10
	}
label10:
	return ret
}

func (tex *Context) printTwo(n int32) {
	n = (iabs(n) % 100)
	tex.printChar(byte(48 + (n / 10)))
	tex.printChar(byte(48 + (n % 10)))
}

func (tex *Context) printHex(n int32) {
	var k byte // 0..22
	k = 0
	tex.printChar(34)
	for {
		tex.dig[k] = byte((n % 16))
		n = (n / 16)
		k = byte(int32(k) + 1)
		if n == 0 {
			break
		}
	}
	tex.printTheDigs(k)
}

func (tex *Context) printRomanInt(n int32) {
	var j, k uint16 // 0..32000
	var u, v uint32 // 0..2147483647
	j = tex.strStart[260]
	v = 1000
	for true {
		for n >= int32(v) {
			tex.printChar(tex.strPool[j])
			n = n - int32(v)
		}
		if n <= 0 {
			goto label10
		}
		k = uint16(int32(j) + 2)
		u = uint32((int32(v) / (int32(tex.strPool[int32(k)-1]) - 48)))
		if tex.strPool[int32(k)-1] == 50 {
			k = uint16(int32(k) + 2)
			u = uint32((int32(u) / (int32(tex.strPool[int32(k)-1]) - 48)))
		}
		if n+int32(u) >= int32(v) {
			tex.printChar(tex.strPool[k])
			n = n + int32(u)
		} else {
			j = uint16(int32(j) + 2)
			v = uint32((int32(v) / (int32(tex.strPool[int32(j)-1]) - 48)))
		}
	}
label10:
}

func (tex *Context) printCurrentString() {
	var j uint16 // 0..32000
	j = tex.strStart[tex.strPtr]
	for j < tex.poolPtr {
		tex.printChar(tex.strPool[j])
		j = uint16(int32(j) + 1)
	}
}

func (tex *Context) termInput() {
	var k uint16 // 0..500
	break1(&tex.termOut)
	if !tex.inputLn(&tex.termIn, true) {
		tex.fatalError(261)
	}
	tex.termOffset = 0
	tex.selector = byte(int32(tex.selector) - 1)
	if tex.last != tex.first {
		for _i := int64(tex.first); _i <= int64(int32(tex.last)-1); _i++ {
			k = uint16(_i)
			tex.print(int32(tex.buffer[k]))
		}
	}
	tex.printLn()
	tex.selector = byte(int32(tex.selector) + 1)
}

func (tex *Context) intError(n int32) {
	tex.print(286)
	tex.printInt(n)
	tex.printChar(41)
	tex.error1()
}

func (tex *Context) normalizeSelector() {
	if tex.logOpened {
		tex.selector = 19
	} else {
		tex.selector = 17
	}
	if tex.jobName == 0 {
		tex.openLogFile()
	}
	if tex.interaction == 0 {
		tex.selector = byte(int32(tex.selector) - 1)
	}
}

func (tex *Context) pauseForInstructions() {
	if tex.OKToInterrupt {
		tex.interaction = 3
		if (tex.selector == 18) || (tex.selector == 16) {
			tex.selector = byte(int32(tex.selector) + 1)
		}
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(296)
		tex.helpPtr = 3
		tex.helpLine[2] = 297
		tex.helpLine[1] = 298
		tex.helpLine[0] = 299
		tex.deletionsAllowed = false
		tex.error1()
		tex.deletionsAllowed = true
		tex.interrupt = 0
	}
}

func (tex *Context) half(x int32) (ret int32) {
	if odd(x) {
		ret = ((x + 1) / 2)
	} else {
		ret = (x / 2)
	}
	return ret
}

func (tex *Context) roundDecimals(k byte) (ret int32) {
	var a int32 // integer
	a = 0
	for k > 0 {
		k = byte(int32(k) - 1)
		a = ((a + (int32(tex.dig[k]) * 131072)) / 10)
	}
	ret = ((a + 1) / 2)
	return ret
}

func (tex *Context) printScaled(s int32) {
	var delta int32 // integer
	if s < 0 {
		tex.printChar(45)
		s = -s
	}
	tex.printInt((s / 65536))
	tex.printChar(46)
	s = (10 * (s % 65536)) + 5
	delta = 10
	for {
		if delta > 65536 {
			s = s - 17232
		}
		tex.printChar(byte(48 + (s / 65536)))
		s = (10 * (s % 65536))
		delta = (delta * 10)
		if s <= delta {
			break
		}
	}
}

func (tex *Context) multAndAdd(n int32, x, y, maxAnswer int32) (ret int32) {
	if n < 0 {
		x = -x
		n = -n
	}
	if n == 0 {
		ret = y
	} else if (x <= ((maxAnswer - y) / n)) && (-x <= ((maxAnswer + y) / n)) {
		ret = (n * x) + y
	} else {
		tex.arithError = true
		ret = 0
	}
	return ret
}

func (tex *Context) xOverN(x int32, n int32) (ret int32) {
	var negative bool // boolean
	negative = false
	if n == 0 {
		tex.arithError = true
		ret = 0
		tex.remainder = x
	} else {
		if n < 0 {
			x = -x
			n = -n
			negative = true
		}
		if x >= 0 {
			ret = (x / n)
			tex.remainder = (x % n)
		} else {
			ret = -(-x / n)
			tex.remainder = -(-x % n)
		}
	}
	if negative {
		tex.remainder = -tex.remainder
	}
	return ret
}

func (tex *Context) xnOverD(x int32, n, d int32) (ret int32) {
	var positive bool  // boolean
	var t, u, v uint32 // 0..2147483647
	if x >= 0 {
		positive = true
	} else {
		x = -x
		positive = false
	}
	t = uint32(((x % 32768) * n))
	u = uint32(((x / 32768) * n) + (int32(t) / 32768))
	v = uint32(((int32(u) % d) * 32768) + (int32(t) % 32768))
	if (int32(u) / d) >= 32768 {
		tex.arithError = true
	} else {
		u = uint32((32768 * (int32(u) / d)) + (int32(v) / d))
	}
	if positive {
		ret = int32(u)
		tex.remainder = (int32(v) % d)
	} else {
		ret = int32(-u)
		tex.remainder = -(int32(v) % d)
	}
	return ret
}

func (tex *Context) badness(t, s int32) (ret uint16) {
	var r int32 // integer
	if t == 0 {
		ret = 0
	} else if s <= 0 {
		ret = 10000
	} else {
		if t <= 7230584 {
			r = ((t * 297) / s)
		} else if s >= 1663497 {
			r = (t / (s / 297))
		} else {
			r = t
		}
		if r > 1290 {
			ret = 10000
		} else {
			ret = uint16((((r * r * r) + 131072) / 262144))
		}
	}
	return ret
}

func (tex *Context) showTokenList(p, q int32, l int32) {
	var m, c int32    // integer
	var matchChr byte // 0..255
	var n byte        // 0..255
	matchChr = 35
	n = 48
	tex.tally = 0
	for (p != 0) && (tex.tally < l) {
		if p == q {
			tex.firstCount = tex.tally
			tex.trickCount = tex.tally + 1 + errorLine - halfErrorLine
			if tex.trickCount < errorLine {
				tex.trickCount = errorLine
			}
		}
		if (p < int32(tex.hiMemMin)) || (p > int32(tex.memEnd)) {
			tex.printEsc(309)
			goto label10
		}
		if tex.mem[p].hh().lh() >= 4095 {
			tex.printCs(int32(tex.mem[p].hh().lh()) - 4095)
		} else {
			m = (int32(tex.mem[p].hh().lh()) / 256)
			c = (int32(tex.mem[p].hh().lh()) % 256)
			if tex.mem[p].hh().lh() < 0 {
				tex.printEsc(555)
			} else {
				switch m {
				case 1, 2, 3, 4, 7, 8, 10, 11, 12:
					tex.print(c)
				case 6:
					tex.print(c)
					tex.print(c)
				case 5:
					tex.print(int32(matchChr))
					if c <= 9 {
						tex.printChar(byte(c + 48))
					} else {
						tex.printChar(33)
						goto label10
					}
				case 13:
					matchChr = byte(c)
					tex.print(c)
					n = byte(int32(n) + 1)
					tex.printChar(n)
					if n > 57 {
						goto label10
					}
				case 14:
					tex.print(556)
				default:
					tex.printEsc(555)
				}
			}
		}
		p = int32(tex.mem[p].hh().rh)
	}
	if p != 0 {
		tex.printEsc(554)
	}
label10:
}

func (tex *Context) runaway() {
	var p uint16 // 0..65535
	if tex.scannerStatus > 1 {
		tex.printNl(569)
		switch tex.scannerStatus {
		case 2:
			tex.print(570)
			p = tex.defRef
		case 3:
			tex.print(571)
			p = 29997
		case 4:
			tex.print(572)
			p = 29996
		case 5:
			tex.print(573)
			p = tex.defRef
		}
		tex.printChar(63)
		tex.printLn()
		tex.showTokenList(int32(tex.mem[p].hh().rh), 0, errorLine-10)
	}
}

func (tex *Context) getAvail() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.avail
	if p != 0 {
		tex.avail = tex.mem[tex.avail].hh().rh
	} else if tex.memEnd < memMax {
		tex.memEnd = uint16(int32(tex.memEnd) + 1)
		p = tex.memEnd
	} else {
		tex.hiMemMin = uint16(int32(tex.hiMemMin) - 1)
		p = tex.hiMemMin
		if tex.hiMemMin <= tex.loMemMax {
			tex.runaway()
			tex.overflow(300, memMax+1-memMin)
		}
	}
	tex.mem[p].pHh().rh = 0
	ret = p
	return ret
}

func (tex *Context) flushList(p uint16) {
	var q, r uint16 // 0..65535
	if p != 0 {
		r = p
		for {
			q = r
			r = tex.mem[r].hh().rh
			if r == 0 {
				break
			}
		}
		tex.mem[q].pHh().rh = tex.avail
		tex.avail = p
	}
}

func (tex *Context) getNode(s int32) (ret uint16) {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	var r int32  // integer
	var t int32  // integer
label20:
	p = tex.rover
	for {
		q = uint16(int32(p) + int32(tex.mem[p].hh().lh()))
		for tex.mem[q].hh().rh == 65535 {
			t = int32(tex.mem[int32(q)+1].hh().rh)
			if q == tex.rover {
				tex.rover = uint16(t)
			}
			*tex.mem[t+1].pHh().pLh() = tex.mem[int32(q)+1].hh().lh()
			tex.mem[int32(tex.mem[int32(q)+1].hh().lh())+1].pHh().rh = uint16(t)
			q = uint16(int32(q) + int32(tex.mem[q].hh().lh()))
		}
		r = int32(q) - s
		if r > int32(p)+1 {
			*tex.mem[p].pHh().pLh() = uint16(r - int32(p))
			tex.rover = p
			goto label40
		}
		if r == int32(p) {
			if tex.mem[int32(p)+1].hh().rh != p {
				tex.rover = tex.mem[int32(p)+1].hh().rh
				t = int32(tex.mem[int32(p)+1].hh().lh())
				*tex.mem[int32(tex.rover)+1].pHh().pLh() = uint16(t)
				tex.mem[t+1].pHh().rh = tex.rover
				goto label40
			}
		}
		*tex.mem[p].pHh().pLh() = uint16(int32(q) - int32(p))
		p = tex.mem[int32(p)+1].hh().rh
		if p == tex.rover {
			break
		}
	}
	if s == 1073741824 {
		ret = 65535
		goto label10
	}
	if int32(tex.loMemMax)+2 < int32(tex.hiMemMin) {
		if int32(tex.loMemMax)+2 <= 65535 {
			if int32(tex.hiMemMin)-int32(tex.loMemMax) >= 1998 {
				t = int32(tex.loMemMax) + 1000
			} else {
				t = int32(tex.loMemMax) + 1 + ((int32(tex.hiMemMin) - int32(tex.loMemMax)) / 2)
			}
			p = tex.mem[int32(tex.rover)+1].hh().lh()
			q = tex.loMemMax
			tex.mem[int32(p)+1].pHh().rh = q
			*tex.mem[int32(tex.rover)+1].pHh().pLh() = q
			if t > 65535 {
				t = 65535
			}
			tex.mem[int32(q)+1].pHh().rh = tex.rover
			*tex.mem[int32(q)+1].pHh().pLh() = p
			tex.mem[q].pHh().rh = 65535
			*tex.mem[q].pHh().pLh() = uint16(t - int32(tex.loMemMax))
			tex.loMemMax = uint16(t)
			tex.mem[tex.loMemMax].pHh().rh = 0
			*tex.mem[tex.loMemMax].pHh().pLh() = 0
			tex.rover = q
			goto label20
		}
	}
	tex.overflow(300, memMax+1-memMin)
label40:
	tex.mem[r].pHh().rh = 0
	ret = uint16(r)
label10:
	return ret
}

func (tex *Context) freeNode(p uint16, s uint16) {
	var q uint16 // 0..65535
	*tex.mem[p].pHh().pLh() = s
	tex.mem[p].pHh().rh = 65535
	q = tex.mem[int32(tex.rover)+1].hh().lh()
	*tex.mem[int32(p)+1].pHh().pLh() = q
	tex.mem[int32(p)+1].pHh().rh = tex.rover
	*tex.mem[int32(tex.rover)+1].pHh().pLh() = p
	tex.mem[int32(q)+1].pHh().rh = p
}

func (tex *Context) sortAvail() {
	var p, q, r uint16  // 0..65535
	var oldRover uint16 // 0..65535
	p = tex.getNode(1073741824)
	p = tex.mem[int32(tex.rover)+1].hh().rh
	tex.mem[int32(tex.rover)+1].pHh().rh = 65535
	oldRover = tex.rover
	for p != oldRover {
		if p < tex.rover {
			q = p
			p = tex.mem[int32(q)+1].hh().rh
			tex.mem[int32(q)+1].pHh().rh = tex.rover
			tex.rover = q
		} else {
			q = tex.rover
			for tex.mem[int32(q)+1].hh().rh < p {
				q = tex.mem[int32(q)+1].hh().rh
			}
			r = tex.mem[int32(p)+1].hh().rh
			tex.mem[int32(p)+1].pHh().rh = tex.mem[int32(q)+1].hh().rh
			tex.mem[int32(q)+1].pHh().rh = p
			p = r
		}
	}
	p = tex.rover
	for tex.mem[int32(p)+1].hh().rh != 65535 {
		*tex.mem[int32(tex.mem[int32(p)+1].hh().rh)+1].pHh().pLh() = p
		p = tex.mem[int32(p)+1].hh().rh
	}
	tex.mem[int32(p)+1].pHh().rh = tex.rover
	*tex.mem[int32(tex.rover)+1].pHh().pLh() = p
}

func (tex *Context) newNullBox() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(7)
	*tex.mem[p].pHh().pB0() = 0
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pInt() = 0
	*tex.mem[int32(p)+2].pInt() = 0
	*tex.mem[int32(p)+3].pInt() = 0
	*tex.mem[int32(p)+4].pInt() = 0
	tex.mem[int32(p)+5].pHh().rh = 0
	*tex.mem[int32(p)+5].pHh().pB0() = 0
	*tex.mem[int32(p)+5].pHh().pB1() = 0
	*tex.mem[int32(p)+6].pGr() = 0
	ret = p
	return ret
}

func (tex *Context) newRule() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(4)
	*tex.mem[p].pHh().pB0() = 2
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pInt() = -1073741824
	*tex.mem[int32(p)+2].pInt() = -1073741824
	*tex.mem[int32(p)+3].pInt() = -1073741824
	ret = p
	return ret
}

func (tex *Context) newLigature(f, c byte, q uint16) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 6
	*tex.mem[int32(p)+1].pHh().pB0() = f
	*tex.mem[int32(p)+1].pHh().pB1() = c
	tex.mem[int32(p)+1].pHh().rh = q
	*tex.mem[p].pHh().pB1() = 0
	ret = p
	return ret
}

func (tex *Context) newLigItem(c byte) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB1() = c
	tex.mem[int32(p)+1].pHh().rh = 0
	ret = p
	return ret
}

func (tex *Context) newDisc() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 7
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pHh().pLh() = 0
	tex.mem[int32(p)+1].pHh().rh = 0
	ret = p
	return ret
}

func (tex *Context) newMath(w int32, s byte) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 9
	*tex.mem[p].pHh().pB1() = s
	*tex.mem[int32(p)+1].pInt() = w
	ret = p
	return ret
}

func (tex *Context) newSpec(p uint16) (ret uint16) {
	var q uint16 // 0..65535
	q = tex.getNode(4)
	tex.mem[q] = tex.mem[p]
	tex.mem[q].pHh().rh = 0
	*tex.mem[int32(q)+1].pInt() = tex.mem[int32(p)+1].int()
	*tex.mem[int32(q)+2].pInt() = tex.mem[int32(p)+2].int()
	*tex.mem[int32(q)+3].pInt() = tex.mem[int32(p)+3].int()
	ret = q
	return ret
}

func (tex *Context) newParamGlue(n byte) (ret uint16) {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 10
	*tex.mem[p].pHh().pB1() = byte(int32(n) + 1)
	tex.mem[int32(p)+1].pHh().rh = 0
	q = tex.eqtb[2882+int32(n)-1].hh().rh
	*tex.mem[int32(p)+1].pHh().pLh() = q
	tex.mem[q].pHh().rh = uint16(int32(tex.mem[q].hh().rh) + 1)
	ret = p
	return ret
}

func (tex *Context) newGlue(q uint16) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 10
	*tex.mem[p].pHh().pB1() = 0
	tex.mem[int32(p)+1].pHh().rh = 0
	*tex.mem[int32(p)+1].pHh().pLh() = q
	tex.mem[q].pHh().rh = uint16(int32(tex.mem[q].hh().rh) + 1)
	ret = p
	return ret
}

func (tex *Context) newSkipParam(n byte) (ret uint16) {
	var p uint16 // 0..65535
	tex.tempPtr = tex.newSpec(tex.eqtb[2882+int32(n)-1].hh().rh)
	p = tex.newGlue(tex.tempPtr)
	tex.mem[tex.tempPtr].pHh().rh = 0
	*tex.mem[p].pHh().pB1() = byte(int32(n) + 1)
	ret = p
	return ret
}

func (tex *Context) newKern(w int32) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 11
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pInt() = w
	ret = p
	return ret
}

func (tex *Context) newPenalty(m int32) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 12
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pInt() = m
	ret = p
	return ret
}

func (tex *Context) shortDisplay(p int32) {
	var n int32 // integer
	for p > memMin {
		if p >= int32(tex.hiMemMin) {
			if p <= int32(tex.memEnd) {
				if int32(tex.mem[p].hh().b0()) != tex.fontInShortDisplay {
					if (tex.mem[p].hh().b0() < 0) || (tex.mem[p].hh().b0() > fontMax) {
						tex.printChar(42)
					} else {
						tex.printEsc(tex.hash[2624+int32(tex.mem[p].hh().b0())-514].rh)
					}
					tex.printChar(32)
					tex.fontInShortDisplay = int32(tex.mem[p].hh().b0())
				}
				tex.print(int32(tex.mem[p].hh().b1()) - 0)
			}
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 3, 8, 4, 5, 13:
				tex.print(308)
			case 2:
				tex.printChar(124)
			case 10:
				if tex.mem[p+1].hh().lh() != 0 {
					tex.printChar(32)
				}
			case 9:
				tex.printChar(36)
			case 6:
				tex.shortDisplay(int32(tex.mem[p+1].hh().rh))
			case 7:
				tex.shortDisplay(int32(tex.mem[p+1].hh().lh()))
				tex.shortDisplay(int32(tex.mem[p+1].hh().rh))
				n = int32(tex.mem[p].hh().b1())
				for n > 0 {
					if tex.mem[p].hh().rh != 0 {
						p = int32(tex.mem[p].hh().rh)
					}
					n = n - 1
				}
			default:
			}
		}
		p = int32(tex.mem[p].hh().rh)
	}
}

func (tex *Context) printFontAndChar(p int32) {
	if p > int32(tex.memEnd) {
		tex.printEsc(309)
	} else {
		if (tex.mem[p].hh().b0() < 0) || (tex.mem[p].hh().b0() > fontMax) {
			tex.printChar(42)
		} else {
			tex.printEsc(tex.hash[2624+int32(tex.mem[p].hh().b0())-514].rh)
		}
		tex.printChar(32)
		tex.print(int32(tex.mem[p].hh().b1()) - 0)
	}
}

func (tex *Context) printMark(p int32) {
	tex.printChar(123)
	if (p < int32(tex.hiMemMin)) || (p > int32(tex.memEnd)) {
		tex.printEsc(309)
	} else {
		tex.showTokenList(int32(tex.mem[p].hh().rh), 0, maxPrintLine-10)
	}
	tex.printChar(125)
}

func (tex *Context) printRuleDimen(d int32) {
	if d == -1073741824 {
		tex.printChar(42)
	} else {
		tex.printScaled(d)
	}
}

func (tex *Context) printGlue(d int32, order int32, s uint16) {
	tex.printScaled(d)
	if (order < 0) || (order > 3) {
		tex.print(310)
	} else if order > 0 {
		tex.print(311)
		for order > 1 {
			tex.printChar(108)
			order = order - 1
		}
	} else if s != 0 {
		tex.print(int32(s))
	}
}

func (tex *Context) printSpec(p int32, s uint16) {
	if (p < memMin) || (p >= int32(tex.loMemMax)) {
		tex.printChar(42)
	} else {
		tex.printScaled(tex.mem[p+1].int())
		if s != 0 {
			tex.print(int32(s))
		}
		if tex.mem[p+2].int() != 0 {
			tex.print(312)
			tex.printGlue(tex.mem[p+2].int(), int32(tex.mem[p].hh().b0()), s)
		}
		if tex.mem[p+3].int() != 0 {
			tex.print(313)
			tex.printGlue(tex.mem[p+3].int(), int32(tex.mem[p].hh().b1()), s)
		}
	}
}

func (tex *Context) printFamAndChar(p uint16) {
	tex.printEsc(464)
	tex.printInt(int32(tex.mem[p].hh().b0()))
	tex.printChar(32)
	tex.print(int32(tex.mem[p].hh().b1()) - 0)
}

func (tex *Context) printDelimiter(p uint16) {
	var a int32 // integer
	a = (int32(tex.mem[p].qqqq().b0) * 256) + int32(tex.mem[p].qqqq().b1) - 0
	a = (a * 4096) + (int32(tex.mem[p].qqqq().b2) * 256) + int32(tex.mem[p].qqqq().b3) - 0
	if a < 0 {
		tex.printInt(a)
	} else {
		tex.printHex(a)
	}
}

func (tex *Context) printSubsidiaryData(p uint16, c byte) {
	if (int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])) >= tex.depthThreshold {
		if tex.mem[p].hh().rh != 0 {
			tex.print(314)
		}
	} else {
		tex.strPool[tex.poolPtr] = c
		tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
		tex.tempPtr = p
		switch tex.mem[p].hh().rh {
		case 1:
			tex.printLn()
			tex.printCurrentString()
			tex.printFamAndChar(p)
		case 2:
			tex.showInfo()
		case 3:
			if tex.mem[p].hh().lh() == 0 {
				tex.printLn()
				tex.printCurrentString()
				tex.print(860)
			} else {
				tex.showInfo()
			}
		default:
		}
		tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
	}
}

func (tex *Context) printStyle(c int32) {
	switch c / 2 {
	case 0:
		tex.printEsc(861)
	case 1:
		tex.printEsc(862)
	case 2:
		tex.printEsc(863)
	case 3:
		tex.printEsc(864)
	default:
		tex.print(865)
	}
}

func (tex *Context) printSkipParam(n int32) {
	switch n {
	case 0:
		tex.printEsc(376)
	case 1:
		tex.printEsc(377)
	case 2:
		tex.printEsc(378)
	case 3:
		tex.printEsc(379)
	case 4:
		tex.printEsc(380)
	case 5:
		tex.printEsc(381)
	case 6:
		tex.printEsc(382)
	case 7:
		tex.printEsc(383)
	case 8:
		tex.printEsc(384)
	case 9:
		tex.printEsc(385)
	case 10:
		tex.printEsc(386)
	case 11:
		tex.printEsc(387)
	case 12:
		tex.printEsc(388)
	case 13:
		tex.printEsc(389)
	case 14:
		tex.printEsc(390)
	case 15:
		tex.printEsc(391)
	case 16:
		tex.printEsc(392)
	case 17:
		tex.printEsc(393)
	default:
		tex.print(394)
	}
}

func (tex *Context) showNodeList(p int32) {
	var n int32   // integer
	var g float32 // real
	if (int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])) > tex.depthThreshold {
		if p > 0 {
			tex.print(314)
		}
		goto label10
	}
	n = 0
	for p > memMin {
		tex.printLn()
		tex.printCurrentString()
		if p > int32(tex.memEnd) {
			tex.print(315)
			goto label10
		}
		n = n + 1
		if n > tex.breadthMax {
			tex.print(316)
			goto label10
		}
		if p >= int32(tex.hiMemMin) {
			tex.printFontAndChar(p)
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 13:
				if tex.mem[p].hh().b0() == 0 {
					tex.printEsc(104)
				} else if tex.mem[p].hh().b0() == 1 {
					tex.printEsc(118)
				} else {
					tex.printEsc(318)
				}
				tex.print(319)
				tex.printScaled(tex.mem[p+3].int())
				tex.printChar(43)
				tex.printScaled(tex.mem[p+2].int())
				tex.print(320)
				tex.printScaled(tex.mem[p+1].int())
				if tex.mem[p].hh().b0() == 13 {
					if tex.mem[p].hh().b1() != 0 {
						tex.print(286)
						tex.printInt(int32(tex.mem[p].hh().b1()) + 1)
						tex.print(322)
					}
					if tex.mem[p+6].int() != 0 {
						tex.print(323)
						tex.printGlue(tex.mem[p+6].int(), int32(tex.mem[p+5].hh().b1()), 0)
					}
					if tex.mem[p+4].int() != 0 {
						tex.print(324)
						tex.printGlue(tex.mem[p+4].int(), int32(tex.mem[p+5].hh().b0()), 0)
					}
				} else {
					g = tex.mem[p+6].gr()
					if (g != 0) && (tex.mem[p+5].hh().b0() != 0) {
						tex.print(325)
						if tex.mem[p+5].hh().b0() == 2 {
							tex.print(326)
						}
						if iabs(tex.mem[p+6].int()) < 1048576 {
							tex.print(327)
						} else if abs(g) > 20000 {
							if g > 0 {
								tex.printChar(62)
							} else {
								tex.print(328)
							}
							tex.printGlue((20000 * 65536), int32(tex.mem[p+5].hh().b1()), 0)
						} else {
							tex.printGlue(round((65536 * g)), int32(tex.mem[p+5].hh().b1()), 0)
						}
					}
					if tex.mem[p+4].int() != 0 {
						tex.print(321)
						tex.printScaled(tex.mem[p+4].int())
					}
				}
				tex.strPool[tex.poolPtr] = 46
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+5].hh().rh))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
			case 2:
				tex.printEsc(329)
				tex.printRuleDimen(tex.mem[p+3].int())
				tex.printChar(43)
				tex.printRuleDimen(tex.mem[p+2].int())
				tex.print(320)
				tex.printRuleDimen(tex.mem[p+1].int())
			case 3:
				tex.printEsc(330)
				tex.printInt(int32(tex.mem[p].hh().b1()) - 0)
				tex.print(331)
				tex.printScaled(tex.mem[p+3].int())
				tex.print(332)
				tex.printSpec(int32(tex.mem[p+4].hh().rh), 0)
				tex.printChar(44)
				tex.printScaled(tex.mem[p+2].int())
				tex.print(333)
				tex.printInt(tex.mem[p+1].int())
				tex.strPool[tex.poolPtr] = 46
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+4].hh().lh()))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
			case 8:
				switch tex.mem[p].hh().b1() {
				case 0:
					tex.printWriteWhatsit(1285, uint16(p))
					tex.printChar(61)
					tex.printFileName(int32(tex.mem[p+1].hh().rh), int32(tex.mem[p+2].hh().lh()), int32(tex.mem[p+2].hh().rh))
				case 1:
					tex.printWriteWhatsit(594, uint16(p))
					tex.printMark(int32(tex.mem[p+1].hh().rh))
				case 2:
					tex.printWriteWhatsit(1286, uint16(p))
				case 3:
					tex.printEsc(1287)
					tex.printMark(int32(tex.mem[p+1].hh().rh))
				case 4:
					tex.printEsc(1289)
					tex.printInt(int32(tex.mem[p+1].hh().rh))
					tex.print(1292)
					tex.printInt(int32(tex.mem[p+1].hh().b0()))
					tex.printChar(44)
					tex.printInt(int32(tex.mem[p+1].hh().b1()))
					tex.printChar(41)
				default:
					tex.print(1293)
				}
			case 10:
				if tex.mem[p].hh().b1() >= 100 {
					tex.printEsc(338)
					if tex.mem[p].hh().b1() == 101 {
						tex.printChar(99)
					} else if tex.mem[p].hh().b1() == 102 {
						tex.printChar(120)
					}
					tex.print(339)
					tex.printSpec(int32(tex.mem[p+1].hh().lh()), 0)
					tex.strPool[tex.poolPtr] = 46
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
					tex.showNodeList(int32(tex.mem[p+1].hh().rh))
					tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
				} else {
					tex.printEsc(334)
					if tex.mem[p].hh().b1() != 0 {
						tex.printChar(40)
						if tex.mem[p].hh().b1() < 98 {
							tex.printSkipParam(int32(tex.mem[p].hh().b1()) - 1)
						} else if tex.mem[p].hh().b1() == 98 {
							tex.printEsc(335)
						} else {
							tex.printEsc(336)
						}
						tex.printChar(41)
					}
					if tex.mem[p].hh().b1() != 98 {
						tex.printChar(32)
						if tex.mem[p].hh().b1() < 98 {
							tex.printSpec(int32(tex.mem[p+1].hh().lh()), 0)
						} else {
							tex.printSpec(int32(tex.mem[p+1].hh().lh()), 337)
						}
					}
				}
			case 11:
				if tex.mem[p].hh().b1() != 99 {
					tex.printEsc(340)
					if tex.mem[p].hh().b1() != 0 {
						tex.printChar(32)
					}
					tex.printScaled(tex.mem[p+1].int())
					if tex.mem[p].hh().b1() == 2 {
						tex.print(341)
					}
				} else {
					tex.printEsc(342)
					tex.printScaled(tex.mem[p+1].int())
					tex.print(337)
				}
			case 9:
				tex.printEsc(343)
				if tex.mem[p].hh().b1() == 0 {
					tex.print(344)
				} else {
					tex.print(345)
				}
				if tex.mem[p+1].int() != 0 {
					tex.print(346)
					tex.printScaled(tex.mem[p+1].int())
				}
			case 6:
				tex.printFontAndChar(p + 1)
				tex.print(347)
				if tex.mem[p].hh().b1() > 1 {
					tex.printChar(124)
				}
				tex.fontInShortDisplay = int32(tex.mem[p+1].hh().b0())
				tex.shortDisplay(int32(tex.mem[p+1].hh().rh))
				if odd(int32(tex.mem[p].hh().b1())) {
					tex.printChar(124)
				}
				tex.printChar(41)
			case 12:
				tex.printEsc(348)
				tex.printInt(tex.mem[p+1].int())
			case 7:
				tex.printEsc(349)
				if tex.mem[p].hh().b1() > 0 {
					tex.print(350)
					tex.printInt(int32(tex.mem[p].hh().b1()))
				}
				tex.strPool[tex.poolPtr] = 46
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+1].hh().lh()))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
				tex.strPool[tex.poolPtr] = 124
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+1].hh().rh))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
			case 4:
				tex.printEsc(351)
				tex.printMark(tex.mem[p+1].int())
			case 5:
				tex.printEsc(352)
				tex.strPool[tex.poolPtr] = 46
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(tex.mem[p+1].int())
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
			case 14:
				tex.printStyle(int32(tex.mem[p].hh().b1()))
			case 15:
				tex.printEsc(525)
				tex.strPool[tex.poolPtr] = 68
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+1].hh().lh()))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
				tex.strPool[tex.poolPtr] = 84
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+1].hh().rh))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
				tex.strPool[tex.poolPtr] = 83
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+2].hh().lh()))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
				tex.strPool[tex.poolPtr] = 115
				tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				tex.showNodeList(int32(tex.mem[p+2].hh().rh))
				tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
			case 16, 17, 18, 19, 20, 21, 22, 23, 24, 27, 26, 29, 28, 30, 31:
				switch tex.mem[p].hh().b0() {
				case 16:
					tex.printEsc(866)
				case 17:
					tex.printEsc(867)
				case 18:
					tex.printEsc(868)
				case 19:
					tex.printEsc(869)
				case 20:
					tex.printEsc(870)
				case 21:
					tex.printEsc(871)
				case 22:
					tex.printEsc(872)
				case 23:
					tex.printEsc(873)
				case 27:
					tex.printEsc(874)
				case 26:
					tex.printEsc(875)
				case 29:
					tex.printEsc(539)
				case 24:
					tex.printEsc(533)
					tex.printDelimiter(uint16(p + 4))
				case 28:
					tex.printEsc(508)
					tex.printFamAndChar(uint16(p + 4))
				case 30:
					tex.printEsc(876)
					tex.printDelimiter(uint16(p + 1))
				case 31:
					tex.printEsc(877)
					tex.printDelimiter(uint16(p + 1))
				}
				if tex.mem[p].hh().b1() != 0 {
					if tex.mem[p].hh().b1() == 1 {
						tex.printEsc(878)
					} else {
						tex.printEsc(879)
					}
				}
				if tex.mem[p].hh().b0() < 30 {
					tex.printSubsidiaryData(uint16(p+1), 46)
				}
				tex.printSubsidiaryData(uint16(p+2), 94)
				tex.printSubsidiaryData(uint16(p+3), 95)
			case 25:
				tex.printEsc(880)
				if tex.mem[p+1].int() == 1073741824 {
					tex.print(881)
				} else {
					tex.printScaled(tex.mem[p+1].int())
				}
				if (tex.mem[p+4].qqqq().b0 != 0) || (tex.mem[p+4].qqqq().b1 != 0) || (tex.mem[p+4].qqqq().b2 != 0) || (tex.mem[p+4].qqqq().b3 != 0) {
					tex.print(882)
					tex.printDelimiter(uint16(p + 4))
				}
				if (tex.mem[p+5].qqqq().b0 != 0) || (tex.mem[p+5].qqqq().b1 != 0) || (tex.mem[p+5].qqqq().b2 != 0) || (tex.mem[p+5].qqqq().b3 != 0) {
					tex.print(883)
					tex.printDelimiter(uint16(p + 5))
				}
				tex.printSubsidiaryData(uint16(p+2), 92)
				tex.printSubsidiaryData(uint16(p+3), 47)
			default:
				tex.print(317)
			}
		}
		p = int32(tex.mem[p].hh().rh)
	}
label10:
}

func (tex *Context) showBox(p uint16) {
	tex.depthThreshold = tex.eqtb[5288-1].int()
	tex.breadthMax = tex.eqtb[5287-1].int()
	if tex.breadthMax <= 0 {
		tex.breadthMax = 5
	}
	if int32(tex.poolPtr)+tex.depthThreshold >= poolSize {
		tex.depthThreshold = poolSize - int32(tex.poolPtr) - 1
	}
	tex.showNodeList(int32(p))
	tex.printLn()
}

func (tex *Context) deleteTokenRef(p uint16) {
	if tex.mem[p].hh().lh() == 0 {
		tex.flushList(p)
	} else {
		*tex.mem[p].pHh().pLh() = uint16(int32(tex.mem[p].hh().lh()) - 1)
	}
}

func (tex *Context) deleteGlueRef(p uint16) {
	if tex.mem[p].hh().rh == 0 {
		tex.freeNode(p, 4)
	} else {
		tex.mem[p].pHh().rh = uint16(int32(tex.mem[p].hh().rh) - 1)
	}
}

func (tex *Context) flushNodeList(p uint16) {
	var q uint16 // 0..65535
	for p != 0 {
		q = tex.mem[p].hh().rh
		if p >= tex.hiMemMin {
			tex.mem[p].pHh().rh = tex.avail
			tex.avail = p
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 13:
				tex.flushNodeList(tex.mem[int32(p)+5].hh().rh)
				tex.freeNode(p, 7)
				goto label30
			case 2:
				tex.freeNode(p, 4)
				goto label30
			case 3:
				tex.flushNodeList(tex.mem[int32(p)+4].hh().lh())
				tex.deleteGlueRef(tex.mem[int32(p)+4].hh().rh)
				tex.freeNode(p, 5)
				goto label30
			case 8:
				switch tex.mem[p].hh().b1() {
				case 0:
					tex.freeNode(p, 3)
				case 1, 3:
					tex.deleteTokenRef(tex.mem[int32(p)+1].hh().rh)
					tex.freeNode(p, 2)
					goto label30
				case 2, 4:
					tex.freeNode(p, 2)
				default:
					tex.confusion(1295)
				}
				goto label30
			case 10:
				if tex.mem[tex.mem[int32(p)+1].hh().lh()].hh().rh == 0 {
					tex.freeNode(tex.mem[int32(p)+1].hh().lh(), 4)
				} else {
					tex.mem[tex.mem[int32(p)+1].hh().lh()].pHh().rh = uint16(int32(tex.mem[tex.mem[int32(p)+1].hh().lh()].hh().rh) - 1)
				}
				if tex.mem[int32(p)+1].hh().rh != 0 {
					tex.flushNodeList(tex.mem[int32(p)+1].hh().rh)
				}
			case 11, 9, 12:
			case 6:
				tex.flushNodeList(tex.mem[int32(p)+1].hh().rh)
			case 4:
				tex.deleteTokenRef(uint16(tex.mem[int32(p)+1].int()))
			case 7:
				tex.flushNodeList(tex.mem[int32(p)+1].hh().lh())
				tex.flushNodeList(tex.mem[int32(p)+1].hh().rh)
			case 5:
				tex.flushNodeList(uint16(tex.mem[int32(p)+1].int()))
			case 14:
				tex.freeNode(p, 3)
				goto label30
			case 15:
				tex.flushNodeList(tex.mem[int32(p)+1].hh().lh())
				tex.flushNodeList(tex.mem[int32(p)+1].hh().rh)
				tex.flushNodeList(tex.mem[int32(p)+2].hh().lh())
				tex.flushNodeList(tex.mem[int32(p)+2].hh().rh)
				tex.freeNode(p, 3)
				goto label30
			case 16, 17, 18, 19, 20, 21, 22, 23, 24, 27, 26, 29, 28:
				if tex.mem[int32(p)+1].hh().rh >= 2 {
					tex.flushNodeList(tex.mem[int32(p)+1].hh().lh())
				}
				if tex.mem[int32(p)+2].hh().rh >= 2 {
					tex.flushNodeList(tex.mem[int32(p)+2].hh().lh())
				}
				if tex.mem[int32(p)+3].hh().rh >= 2 {
					tex.flushNodeList(tex.mem[int32(p)+3].hh().lh())
				}
				if tex.mem[p].hh().b0() == 24 {
					tex.freeNode(p, 5)
				} else if tex.mem[p].hh().b0() == 28 {
					tex.freeNode(p, 5)
				} else {
					tex.freeNode(p, 4)
				}
				goto label30
			case 30, 31:
				tex.freeNode(p, 4)
				goto label30
			case 25:
				tex.flushNodeList(tex.mem[int32(p)+2].hh().lh())
				tex.flushNodeList(tex.mem[int32(p)+3].hh().lh())
				tex.freeNode(p, 6)
				goto label30
			default:
				tex.confusion(353)
			}
			tex.freeNode(p, 2)
		label30:
		}
		p = q
	}
}

func (tex *Context) copyNodeList(p uint16) (ret uint16) {
	var h uint16   // 0..65535
	var q uint16   // 0..65535
	var r uint16   // 0..65535
	var words byte // 0..5
	h = tex.getAvail()
	q = h
	for p != 0 {
		words = 1
		if p >= tex.hiMemMin {
			r = tex.getAvail()
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 13:
				r = tex.getNode(7)
				tex.mem[int32(r)+6] = tex.mem[int32(p)+6]
				tex.mem[int32(r)+5] = tex.mem[int32(p)+5]
				tex.mem[int32(r)+5].pHh().rh = tex.copyNodeList(tex.mem[int32(p)+5].hh().rh)
				words = 5
			case 2:
				r = tex.getNode(4)
				words = 4
			case 3:
				r = tex.getNode(5)
				tex.mem[int32(r)+4] = tex.mem[int32(p)+4]
				tex.mem[tex.mem[int32(p)+4].hh().rh].pHh().rh = uint16(int32(tex.mem[tex.mem[int32(p)+4].hh().rh].hh().rh) + 1)
				*tex.mem[int32(r)+4].pHh().pLh() = tex.copyNodeList(tex.mem[int32(p)+4].hh().lh())
				words = 4
			case 8:
				switch tex.mem[p].hh().b1() {
				case 0:
					r = tex.getNode(3)
					words = 3
				case 1, 3:
					r = tex.getNode(2)
					*tex.mem[tex.mem[int32(p)+1].hh().rh].pHh().pLh() = uint16(int32(tex.mem[tex.mem[int32(p)+1].hh().rh].hh().lh()) + 1)
					words = 2
				case 2, 4:
					r = tex.getNode(2)
					words = 2
				default:
					tex.confusion(1294)
				}
			case 10:
				r = tex.getNode(2)
				tex.mem[tex.mem[int32(p)+1].hh().lh()].pHh().rh = uint16(int32(tex.mem[tex.mem[int32(p)+1].hh().lh()].hh().rh) + 1)
				*tex.mem[int32(r)+1].pHh().pLh() = tex.mem[int32(p)+1].hh().lh()
				tex.mem[int32(r)+1].pHh().rh = tex.copyNodeList(tex.mem[int32(p)+1].hh().rh)
			case 11, 9, 12:
				r = tex.getNode(2)
				words = 2
			case 6:
				r = tex.getNode(2)
				tex.mem[int32(r)+1] = tex.mem[int32(p)+1]
				tex.mem[int32(r)+1].pHh().rh = tex.copyNodeList(tex.mem[int32(p)+1].hh().rh)
			case 7:
				r = tex.getNode(2)
				*tex.mem[int32(r)+1].pHh().pLh() = tex.copyNodeList(tex.mem[int32(p)+1].hh().lh())
				tex.mem[int32(r)+1].pHh().rh = tex.copyNodeList(tex.mem[int32(p)+1].hh().rh)
			case 4:
				r = tex.getNode(2)
				*tex.mem[tex.mem[int32(p)+1].int()].pHh().pLh() = uint16(int32(tex.mem[tex.mem[int32(p)+1].int()].hh().lh()) + 1)
				words = 2
			case 5:
				r = tex.getNode(2)
				*tex.mem[int32(r)+1].pInt() = int32(tex.copyNodeList(uint16(tex.mem[int32(p)+1].int())))
			default:
				tex.confusion(354)
			}
		}
		for words > 0 {
			words = byte(int32(words) - 1)
			tex.mem[int32(r)+int32(words)] = tex.mem[int32(p)+int32(words)]
		}
		tex.mem[q].pHh().rh = r
		q = r
		p = tex.mem[p].hh().rh
	}
	tex.mem[q].pHh().rh = 0
	q = tex.mem[h].hh().rh
	tex.mem[h].pHh().rh = tex.avail
	tex.avail = h
	ret = q
	return ret
}

func (tex *Context) printMode(m int32) {
	if m > 0 {
		switch m / 101 {
		case 0:
			tex.print(355)
		case 1:
			tex.print(356)
		case 2:
			tex.print(357)
		}
	} else if m == 0 {
		tex.print(358)
	} else {
		switch -m / 101 {
		case 0:
			tex.print(359)
		case 1:
			tex.print(360)
		case 2:
			tex.print(343)
		}
	}
	tex.print(361)
}

func (tex *Context) pushNest() {
	if tex.nestPtr > tex.maxNestStack {
		tex.maxNestStack = tex.nestPtr
		if tex.nestPtr == nestSize {
			tex.overflow(362, nestSize)
		}
	}
	tex.nest[tex.nestPtr] = tex.curList
	tex.nestPtr = byte(int32(tex.nestPtr) + 1)
	tex.curList.headField = tex.getAvail()
	tex.curList.tailField = tex.curList.headField
	tex.curList.pgField = 0
	tex.curList.mlField = tex.line
}

func (tex *Context) popNest() {
	tex.mem[tex.curList.headField].pHh().rh = tex.avail
	tex.avail = tex.curList.headField
	tex.nestPtr = byte(int32(tex.nestPtr) - 1)
	tex.curList = tex.nest[tex.nestPtr]
}

func (tex *Context) showActivities() {
	var p byte       // 0..40
	var m int16      // -203..203
	var a memoryWord // record memoryWord
	var q, r uint16  // 0..65535
	var t int32      // integer
	tex.nest[tex.nestPtr] = tex.curList
	tex.printNl(338)
	tex.printLn()
	for _i := int64(tex.nestPtr); _i >= int64(0); _i-- {
		p = byte(_i)
		m = tex.nest[p].modeField
		a = tex.nest[p].auxField
		tex.printNl(363)
		tex.printMode(int32(m))
		tex.print(364)
		tex.printInt(iabs(tex.nest[p].mlField))
		if m == 102 {
			if tex.nest[p].pgField != 8585216 {
				tex.print(365)
				tex.printInt((tex.nest[p].pgField % 65536))
				tex.print(366)
				tex.printInt((tex.nest[p].pgField / 4194304))
				tex.printChar(44)
				tex.printInt(((tex.nest[p].pgField / 65536) % 64))
				tex.printChar(41)
			}
		}
		if tex.nest[p].mlField < 0 {
			tex.print(367)
		}
		if p == 0 {
			if 29998 != int32(tex.pageTail) {
				tex.printNl(980)
				if tex.outputActive {
					tex.print(981)
				}
				tex.showBox(tex.mem[29998].hh().rh)
				if tex.pageContents > 0 {
					tex.printNl(982)
					tex.printTotals()
					tex.printNl(983)
					tex.printScaled(tex.pageSoFar[0])
					r = tex.mem[30000].hh().rh
					for r != 30000 {
						tex.printLn()
						tex.printEsc(330)
						t = int32(tex.mem[r].hh().b1()) - 0
						tex.printInt(t)
						tex.print(984)
						if tex.eqtb[5318+t-1].int() == 1000 {
							t = tex.mem[int32(r)+3].int()
						} else {
							t = (tex.xOverN(tex.mem[int32(r)+3].int(), 1000) * tex.eqtb[5318+t-1].int())
						}
						tex.printScaled(t)
						if tex.mem[r].hh().b0() == 1 {
							q = 29998
							t = 0
							for {
								q = tex.mem[q].hh().rh
								if (tex.mem[q].hh().b0() == 3) && (tex.mem[q].hh().b1() == tex.mem[r].hh().b1()) {
									t = t + 1
								}
								if q == tex.mem[int32(r)+1].hh().lh() {
									break
								}
							}
							tex.print(985)
							tex.printInt(t)
							tex.print(986)
						}
						r = tex.mem[r].hh().rh
					}
				}
			}
			if tex.mem[29999].hh().rh != 0 {
				tex.printNl(368)
			}
		}
		tex.showBox(tex.mem[tex.nest[p].headField].hh().rh)
		switch iabs(int32(m)) / 101 {
		case 0:
			tex.printNl(369)
			if a.int() <= -65536000 {
				tex.print(370)
			} else {
				tex.printScaled(a.int())
			}
			if tex.nest[p].pgField != 0 {
				tex.print(371)
				tex.printInt(tex.nest[p].pgField)
				tex.print(372)
				if tex.nest[p].pgField != 1 {
					tex.printChar(115)
				}
			}
		case 1:
			tex.printNl(373)
			tex.printInt(int32(a.hh().lh()))
			if m > 0 {
				if a.hh().rh > 0 {
					tex.print(374)
					tex.printInt(int32(a.hh().rh))
				}
			}
		case 2:
			if a.int() != 0 {
				tex.print(375)
				tex.showBox(uint16(a.int()))
			}
		}
	}
}

func (tex *Context) printParam(n int32) {
	switch n {
	case 0:
		tex.printEsc(420)
	case 1:
		tex.printEsc(421)
	case 2:
		tex.printEsc(422)
	case 3:
		tex.printEsc(423)
	case 4:
		tex.printEsc(424)
	case 5:
		tex.printEsc(425)
	case 6:
		tex.printEsc(426)
	case 7:
		tex.printEsc(427)
	case 8:
		tex.printEsc(428)
	case 9:
		tex.printEsc(429)
	case 10:
		tex.printEsc(430)
	case 11:
		tex.printEsc(431)
	case 12:
		tex.printEsc(432)
	case 13:
		tex.printEsc(433)
	case 14:
		tex.printEsc(434)
	case 15:
		tex.printEsc(435)
	case 16:
		tex.printEsc(436)
	case 17:
		tex.printEsc(437)
	case 18:
		tex.printEsc(438)
	case 19:
		tex.printEsc(439)
	case 20:
		tex.printEsc(440)
	case 21:
		tex.printEsc(441)
	case 22:
		tex.printEsc(442)
	case 23:
		tex.printEsc(443)
	case 24:
		tex.printEsc(444)
	case 25:
		tex.printEsc(445)
	case 26:
		tex.printEsc(446)
	case 27:
		tex.printEsc(447)
	case 28:
		tex.printEsc(448)
	case 29:
		tex.printEsc(449)
	case 30:
		tex.printEsc(450)
	case 31:
		tex.printEsc(451)
	case 32:
		tex.printEsc(452)
	case 33:
		tex.printEsc(453)
	case 34:
		tex.printEsc(454)
	case 35:
		tex.printEsc(455)
	case 36:
		tex.printEsc(456)
	case 37:
		tex.printEsc(457)
	case 38:
		tex.printEsc(458)
	case 39:
		tex.printEsc(459)
	case 40:
		tex.printEsc(460)
	case 41:
		tex.printEsc(461)
	case 42:
		tex.printEsc(462)
	case 43:
		tex.printEsc(463)
	case 44:
		tex.printEsc(464)
	case 45:
		tex.printEsc(465)
	case 46:
		tex.printEsc(466)
	case 47:
		tex.printEsc(467)
	case 48:
		tex.printEsc(468)
	case 49:
		tex.printEsc(469)
	case 50:
		tex.printEsc(470)
	case 51:
		tex.printEsc(471)
	case 52:
		tex.printEsc(472)
	case 53:
		tex.printEsc(473)
	case 54:
		tex.printEsc(474)
	default:
		tex.print(475)
	}
}

func (tex *Context) fixDateAndTime() {
	tex.sysTime = (12 * 60)
	tex.sysDay = 4
	tex.sysMonth = 7
	tex.sysYear = 1776
	*tex.eqtb[5283-1].pInt() = pasSysTime()
	*tex.eqtb[5284-1].pInt() = pasSysDay()
	*tex.eqtb[5285-1].pInt() = pasSysMonth()
	*tex.eqtb[5286-1].pInt() = pasSysYear()
}

func (tex *Context) beginDiagnostic() {
	tex.oldSetting = tex.selector
	if (tex.eqtb[5292-1].int() <= 0) && (tex.selector == 19) {
		tex.selector = byte(int32(tex.selector) - 1)
		if tex.history == 0 {
			tex.history = 1
		}
	}
}

func (tex *Context) endDiagnostic(blankLine bool) {
	tex.printNl(338)
	if blankLine {
		tex.printLn()
	}
	tex.selector = tex.oldSetting
}

func (tex *Context) printLengthParam(n int32) {
	switch n {
	case 0:
		tex.printEsc(478)
	case 1:
		tex.printEsc(479)
	case 2:
		tex.printEsc(480)
	case 3:
		tex.printEsc(481)
	case 4:
		tex.printEsc(482)
	case 5:
		tex.printEsc(483)
	case 6:
		tex.printEsc(484)
	case 7:
		tex.printEsc(485)
	case 8:
		tex.printEsc(486)
	case 9:
		tex.printEsc(487)
	case 10:
		tex.printEsc(488)
	case 11:
		tex.printEsc(489)
	case 12:
		tex.printEsc(490)
	case 13:
		tex.printEsc(491)
	case 14:
		tex.printEsc(492)
	case 15:
		tex.printEsc(493)
	case 16:
		tex.printEsc(494)
	case 17:
		tex.printEsc(495)
	case 18:
		tex.printEsc(496)
	case 19:
		tex.printEsc(497)
	case 20:
		tex.printEsc(498)
	default:
		tex.print(499)
	}
}

func (tex *Context) printCmdChr(cmd byte, chrCode uint16) {
	switch cmd {
	case 1:
		tex.print(557)
		tex.print(int32(chrCode))
	case 2:
		tex.print(558)
		tex.print(int32(chrCode))
	case 3:
		tex.print(559)
		tex.print(int32(chrCode))
	case 6:
		tex.print(560)
		tex.print(int32(chrCode))
	case 7:
		tex.print(561)
		tex.print(int32(chrCode))
	case 8:
		tex.print(562)
		tex.print(int32(chrCode))
	case 9:
		tex.print(563)
	case 10:
		tex.print(564)
		tex.print(int32(chrCode))
	case 11:
		tex.print(565)
		tex.print(int32(chrCode))
	case 12:
		tex.print(566)
		tex.print(int32(chrCode))
	case 75, 76:
		if chrCode < 2900 {
			tex.printSkipParam(int32(chrCode) - 2882)
		} else if chrCode < 3156 {
			tex.printEsc(395)
			tex.printInt(int32(chrCode) - 2900)
		} else {
			tex.printEsc(396)
			tex.printInt(int32(chrCode) - 3156)
		}
	case 72:
		if chrCode >= 3422 {
			tex.printEsc(407)
			tex.printInt(int32(chrCode) - 3422)
		} else {
			switch chrCode {
			case 3413:
				tex.printEsc(398)
			case 3414:
				tex.printEsc(399)
			case 3415:
				tex.printEsc(400)
			case 3416:
				tex.printEsc(401)
			case 3417:
				tex.printEsc(402)
			case 3418:
				tex.printEsc(403)
			case 3419:
				tex.printEsc(404)
			case 3420:
				tex.printEsc(405)
			default:
				tex.printEsc(406)
			}
		}
	case 73:
		if chrCode < 5318 {
			tex.printParam(int32(chrCode) - 5263)
		} else {
			tex.printEsc(476)
			tex.printInt(int32(chrCode) - 5318)
		}
	case 74:
		if chrCode < 5851 {
			tex.printLengthParam(int32(chrCode) - 5830)
		} else {
			tex.printEsc(500)
			tex.printInt(int32(chrCode) - 5851)
		}
	case 45:
		tex.printEsc(508)
	case 90:
		tex.printEsc(509)
	case 40:
		tex.printEsc(510)
	case 41:
		tex.printEsc(511)
	case 77:
		tex.printEsc(519)
	case 61:
		tex.printEsc(512)
	case 42:
		tex.printEsc(531)
	case 16:
		tex.printEsc(513)
	case 107:
		tex.printEsc(504)
	case 88:
		tex.printEsc(518)
	case 15:
		tex.printEsc(514)
	case 92:
		tex.printEsc(515)
	case 67:
		tex.printEsc(505)
	case 62:
		tex.printEsc(516)
	case 64:
		tex.printEsc(32)
	case 102:
		tex.printEsc(517)
	case 32:
		tex.printEsc(520)
	case 36:
		tex.printEsc(521)
	case 39:
		tex.printEsc(522)
	case 37:
		tex.printEsc(330)
	case 44:
		tex.printEsc(47)
	case 18:
		tex.printEsc(351)
	case 46:
		tex.printEsc(523)
	case 17:
		tex.printEsc(524)
	case 54:
		tex.printEsc(525)
	case 91:
		tex.printEsc(526)
	case 34:
		tex.printEsc(527)
	case 65:
		tex.printEsc(528)
	case 103:
		tex.printEsc(529)
	case 55:
		tex.printEsc(335)
	case 63:
		tex.printEsc(530)
	case 66:
		tex.printEsc(533)
	case 96:
		tex.printEsc(534)
	case 0:
		tex.printEsc(535)
	case 98:
		tex.printEsc(536)
	case 80:
		tex.printEsc(532)
	case 84:
		tex.printEsc(408)
	case 109:
		tex.printEsc(537)
	case 71:
		tex.printEsc(407)
	case 38:
		tex.printEsc(352)
	case 33:
		tex.printEsc(538)
	case 56:
		tex.printEsc(539)
	case 35:
		tex.printEsc(540)
	case 13:
		tex.printEsc(597)
	case 104:
		if chrCode == 0 {
			tex.printEsc(629)
		} else {
			tex.printEsc(630)
		}
	case 110:
		switch chrCode {
		case 1:
			tex.printEsc(632)
		case 2:
			tex.printEsc(633)
		case 3:
			tex.printEsc(634)
		case 4:
			tex.printEsc(635)
		default:
			tex.printEsc(631)
		}
	case 89:
		if chrCode == 0 {
			tex.printEsc(476)
		} else if chrCode == 1 {
			tex.printEsc(500)
		} else if chrCode == 2 {
			tex.printEsc(395)
		} else {
			tex.printEsc(396)
		}
	case 79:
		if chrCode == 1 {
			tex.printEsc(669)
		} else {
			tex.printEsc(668)
		}
	case 82:
		if chrCode == 0 {
			tex.printEsc(670)
		} else {
			tex.printEsc(671)
		}
	case 83:
		if chrCode == 1 {
			tex.printEsc(672)
		} else if chrCode == 3 {
			tex.printEsc(673)
		} else {
			tex.printEsc(674)
		}
	case 70:
		switch chrCode {
		case 0:
			tex.printEsc(675)
		case 1:
			tex.printEsc(676)
		case 2:
			tex.printEsc(677)
		case 3:
			tex.printEsc(678)
		default:
			tex.printEsc(679)
		}
	case 108:
		switch chrCode {
		case 0:
			tex.printEsc(735)
		case 1:
			tex.printEsc(736)
		case 2:
			tex.printEsc(737)
		case 3:
			tex.printEsc(738)
		case 4:
			tex.printEsc(739)
		default:
			tex.printEsc(740)
		}
	case 105:
		switch chrCode {
		case 1:
			tex.printEsc(758)
		case 2:
			tex.printEsc(759)
		case 3:
			tex.printEsc(760)
		case 4:
			tex.printEsc(761)
		case 5:
			tex.printEsc(762)
		case 6:
			tex.printEsc(763)
		case 7:
			tex.printEsc(764)
		case 8:
			tex.printEsc(765)
		case 9:
			tex.printEsc(766)
		case 10:
			tex.printEsc(767)
		case 11:
			tex.printEsc(768)
		case 12:
			tex.printEsc(769)
		case 13:
			tex.printEsc(770)
		case 14:
			tex.printEsc(771)
		case 15:
			tex.printEsc(772)
		case 16:
			tex.printEsc(773)
		default:
			tex.printEsc(757)
		}
	case 106:
		if chrCode == 2 {
			tex.printEsc(774)
		} else if chrCode == 4 {
			tex.printEsc(775)
		} else {
			tex.printEsc(776)
		}
	case 4:
		if chrCode == 256 {
			tex.printEsc(898)
		} else {
			tex.print(902)
			tex.print(int32(chrCode))
		}
	case 5:
		if chrCode == 257 {
			tex.printEsc(899)
		} else {
			tex.printEsc(900)
		}
	case 81:
		switch chrCode {
		case 0:
			tex.printEsc(970)
		case 1:
			tex.printEsc(971)
		case 2:
			tex.printEsc(972)
		case 3:
			tex.printEsc(973)
		case 4:
			tex.printEsc(974)
		case 5:
			tex.printEsc(975)
		case 6:
			tex.printEsc(976)
		default:
			tex.printEsc(977)
		}
	case 14:
		if chrCode == 1 {
			tex.printEsc(1026)
		} else {
			tex.printEsc(1025)
		}
	case 26:
		switch chrCode {
		case 4:
			tex.printEsc(1027)
		case 0:
			tex.printEsc(1028)
		case 1:
			tex.printEsc(1029)
		case 2:
			tex.printEsc(1030)
		default:
			tex.printEsc(1031)
		}
	case 27:
		switch chrCode {
		case 4:
			tex.printEsc(1032)
		case 0:
			tex.printEsc(1033)
		case 1:
			tex.printEsc(1034)
		case 2:
			tex.printEsc(1035)
		default:
			tex.printEsc(1036)
		}
	case 28:
		tex.printEsc(336)
	case 29:
		tex.printEsc(340)
	case 30:
		tex.printEsc(342)
	case 21:
		if chrCode == 1 {
			tex.printEsc(1054)
		} else {
			tex.printEsc(1055)
		}
	case 22:
		if chrCode == 1 {
			tex.printEsc(1056)
		} else {
			tex.printEsc(1057)
		}
	case 20:
		switch chrCode {
		case 0:
			tex.printEsc(409)
		case 1:
			tex.printEsc(1058)
		case 2:
			tex.printEsc(1059)
		case 3:
			tex.printEsc(965)
		case 4:
			tex.printEsc(1060)
		case 5:
			tex.printEsc(967)
		default:
			tex.printEsc(1061)
		}
	case 31:
		if chrCode == 100 {
			tex.printEsc(1063)
		} else if chrCode == 101 {
			tex.printEsc(1064)
		} else if chrCode == 102 {
			tex.printEsc(1065)
		} else {
			tex.printEsc(1062)
		}
	case 43:
		if chrCode == 0 {
			tex.printEsc(1081)
		} else {
			tex.printEsc(1080)
		}
	case 25:
		if chrCode == 10 {
			tex.printEsc(1092)
		} else if chrCode == 11 {
			tex.printEsc(1091)
		} else {
			tex.printEsc(1090)
		}
	case 23:
		if chrCode == 1 {
			tex.printEsc(1094)
		} else {
			tex.printEsc(1093)
		}
	case 24:
		if chrCode == 1 {
			tex.printEsc(1096)
		} else {
			tex.printEsc(1095)
		}
	case 47:
		if chrCode == 1 {
			tex.printEsc(45)
		} else {
			tex.printEsc(349)
		}
	case 48:
		if chrCode == 1 {
			tex.printEsc(1128)
		} else {
			tex.printEsc(1127)
		}
	case 50:
		switch chrCode {
		case 16:
			tex.printEsc(866)
		case 17:
			tex.printEsc(867)
		case 18:
			tex.printEsc(868)
		case 19:
			tex.printEsc(869)
		case 20:
			tex.printEsc(870)
		case 21:
			tex.printEsc(871)
		case 22:
			tex.printEsc(872)
		case 23:
			tex.printEsc(873)
		case 26:
			tex.printEsc(875)
		default:
			tex.printEsc(874)
		}
	case 51:
		if chrCode == 1 {
			tex.printEsc(878)
		} else if chrCode == 2 {
			tex.printEsc(879)
		} else {
			tex.printEsc(1129)
		}
	case 53:
		tex.printStyle(int32(chrCode))
	case 52:
		switch chrCode {
		case 1:
			tex.printEsc(1148)
		case 2:
			tex.printEsc(1149)
		case 3:
			tex.printEsc(1150)
		case 4:
			tex.printEsc(1151)
		case 5:
			tex.printEsc(1152)
		default:
			tex.printEsc(1147)
		}
	case 49:
		if chrCode == 30 {
			tex.printEsc(876)
		} else {
			tex.printEsc(877)
		}
	case 93:
		if chrCode == 1 {
			tex.printEsc(1171)
		} else if chrCode == 2 {
			tex.printEsc(1172)
		} else {
			tex.printEsc(1173)
		}
	case 97:
		if chrCode == 0 {
			tex.printEsc(1174)
		} else if chrCode == 1 {
			tex.printEsc(1175)
		} else if chrCode == 2 {
			tex.printEsc(1176)
		} else {
			tex.printEsc(1177)
		}
	case 94:
		if chrCode != 0 {
			tex.printEsc(1192)
		} else {
			tex.printEsc(1191)
		}
	case 95:
		switch chrCode {
		case 0:
			tex.printEsc(1193)
		case 1:
			tex.printEsc(1194)
		case 2:
			tex.printEsc(1195)
		case 3:
			tex.printEsc(1196)
		case 4:
			tex.printEsc(1197)
		case 5:
			tex.printEsc(1198)
		default:
			tex.printEsc(1199)
		}
	case 68:
		tex.printEsc(513)
		tex.printHex(int32(chrCode))
	case 69:
		tex.printEsc(524)
		tex.printHex(int32(chrCode))
	case 85:
		if chrCode == 3983 {
			tex.printEsc(415)
		} else if chrCode == 5007 {
			tex.printEsc(419)
		} else if chrCode == 4239 {
			tex.printEsc(416)
		} else if chrCode == 4495 {
			tex.printEsc(417)
		} else if chrCode == 4751 {
			tex.printEsc(418)
		} else {
			tex.printEsc(477)
		}
	case 86:
		tex.printSize(int32(chrCode) - 3935)
	case 99:
		if chrCode == 1 {
			tex.printEsc(953)
		} else {
			tex.printEsc(941)
		}
	case 78:
		if chrCode == 0 {
			tex.printEsc(1217)
		} else {
			tex.printEsc(1218)
		}
	case 87:
		tex.print(1226)
		tex.slowPrint(int32(tex.fontName[chrCode]))
		if tex.fontSize[chrCode] != tex.fontDsize[chrCode] {
			tex.print(741)
			tex.printScaled(tex.fontSize[chrCode])
			tex.print(397)
		}
	case 100:
		switch chrCode {
		case 0:
			tex.printEsc(274)
		case 1:
			tex.printEsc(275)
		case 2:
			tex.printEsc(276)
		default:
			tex.printEsc(1227)
		}
	case 60:
		if chrCode == 0 {
			tex.printEsc(1229)
		} else {
			tex.printEsc(1228)
		}
	case 58:
		if chrCode == 0 {
			tex.printEsc(1230)
		} else {
			tex.printEsc(1231)
		}
	case 57:
		if chrCode == 4239 {
			tex.printEsc(1237)
		} else {
			tex.printEsc(1238)
		}
	case 19:
		switch chrCode {
		case 1:
			tex.printEsc(1240)
		case 2:
			tex.printEsc(1241)
		case 3:
			tex.printEsc(1242)
		default:
			tex.printEsc(1239)
		}
	case 101:
		tex.print(1249)
	case 111:
		tex.print(1250)
	case 112:
		tex.printEsc(1251)
	case 113:
		tex.printEsc(1252)
	case 114:
		tex.printEsc(1171)
		tex.printEsc(1252)
	case 115:
		tex.printEsc(1253)
	case 59:
		switch chrCode {
		case 0:
			tex.printEsc(1285)
		case 1:
			tex.printEsc(594)
		case 2:
			tex.printEsc(1286)
		case 3:
			tex.printEsc(1287)
		case 4:
			tex.printEsc(1288)
		case 5:
			tex.printEsc(1289)
		default:
			tex.print(1290)
		}
	default:
		tex.print(567)
	}
}

func (tex *Context) idLookup(j, l int32) (ret uint16) {
	var h int32  // integer
	var d int32  // integer
	var p uint16 // 0..65535
	var k uint16 // 0..65535
	h = int32(tex.buffer[j])
	for _i := int64(j + 1); _i <= int64(j+l-1); _i++ {
		k = uint16(_i)
		h = h + h + int32(tex.buffer[k])
		for h >= 1777 {
			h = h - 1777
		}
	}
	p = uint16(h + 514)
	for true {
		if tex.hash[p-514].rh > 0 {
			if (int32(tex.strStart[int32(tex.hash[p-514].rh)+1]) - int32(tex.strStart[tex.hash[p-514].rh])) == l {
				if tex.strEqBuf(tex.hash[p-514].rh, j) {
					goto label40
				}
			}
		}
		if tex.hash[p-514].lh() == 0 {
			if tex.noNewControlSequence {
				p = 2881
			} else {
				if tex.hash[p-514].rh > 0 {
					for {
						if tex.hashUsed == 514 {
							tex.overflow(503, 2100)
						}
						tex.hashUsed = uint16(int32(tex.hashUsed) - 1)
						if tex.hash[tex.hashUsed-514].rh == 0 {
							break
						}
					}
					*tex.hash[p-514].pLh() = tex.hashUsed
					p = tex.hashUsed
				}
				if int32(tex.poolPtr)+l > poolSize {
					tex.overflow(257, poolSize-int32(tex.initPoolPtr))
				}
				d = (int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr]))
				for tex.poolPtr > tex.strStart[tex.strPtr] {
					tex.poolPtr = uint16(int32(tex.poolPtr) - 1)
					tex.strPool[int32(tex.poolPtr)+l] = tex.strPool[tex.poolPtr]
				}
				for _i := int64(j); _i <= int64(j+l-1); _i++ {
					k = uint16(_i)
					tex.strPool[tex.poolPtr] = tex.buffer[k]
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				}
				tex.hash[p-514].rh = tex.makeString()
				tex.poolPtr = uint16(int32(tex.poolPtr) + d)
			}
			goto label40
		}
		p = tex.hash[p-514].lh()
	}
label40:
	ret = p
	return ret
}

func (tex *Context) primitive(s uint16, c byte, o uint16) {
	var k uint16 // 0..32000
	var j byte   // 0..63
	var l byte   // 0..63
	if s < 256 {
		tex.curVal = int32(s) + 257
	} else {
		k = tex.strStart[s]
		l = byte(int32(tex.strStart[int32(s)+1]) - int32(k))
		for _i := int64(0); _i <= int64(int32(l)-1); _i++ {
			j = byte(_i)
			tex.buffer[j] = tex.strPool[int32(k)+int32(j)]
		}
		tex.curVal = int32(tex.idLookup(0, int32(l)))
		tex.strPtr = uint16(int32(tex.strPtr) - 1)
		tex.poolPtr = tex.strStart[tex.strPtr]
		tex.hash[tex.curVal-514].rh = s
	}
	*tex.eqtb[tex.curVal-1].pHh().pB1() = 1
	*tex.eqtb[tex.curVal-1].pHh().pB0() = c
	tex.eqtb[tex.curVal-1].pHh().rh = o
}

func (tex *Context) newSaveLevel(c byte) {
	if tex.savePtr > tex.maxSaveStack {
		tex.maxSaveStack = tex.savePtr
		if int32(tex.maxSaveStack) > saveSize-6 {
			tex.overflow(541, saveSize)
		}
	}
	*tex.saveStack[tex.savePtr].pHh().pB0() = 3
	*tex.saveStack[tex.savePtr].pHh().pB1() = tex.curGroup
	tex.saveStack[tex.savePtr].pHh().rh = tex.curBoundary
	if tex.curLevel == 255 {
		tex.overflow(542, 255)
	}
	tex.curBoundary = tex.savePtr
	tex.curLevel = byte(int32(tex.curLevel) + 1)
	tex.savePtr = uint16(int32(tex.savePtr) + 1)
	tex.curGroup = c
}

func (tex *Context) eqDestroy(w memoryWord) {
	var q uint16 // 0..65535
	switch w.hh().b0() {
	case 111, 112, 113, 114:
		tex.deleteTokenRef(w.hh().rh)
	case 117:
		tex.deleteGlueRef(w.hh().rh)
	case 118:
		q = w.hh().rh
		if q != 0 {
			tex.freeNode(q, uint16(int32(tex.mem[q].hh().lh())+int32(tex.mem[q].hh().lh())+1))
		}
	case 119:
		tex.flushNodeList(w.hh().rh)
	default:
	}
}

func (tex *Context) eqSave(p uint16, l byte) {
	if tex.savePtr > tex.maxSaveStack {
		tex.maxSaveStack = tex.savePtr
		if int32(tex.maxSaveStack) > saveSize-6 {
			tex.overflow(541, saveSize)
		}
	}
	if l == 0 {
		*tex.saveStack[tex.savePtr].pHh().pB0() = 1
	} else {
		tex.saveStack[tex.savePtr] = tex.eqtb[p-1]
		tex.savePtr = uint16(int32(tex.savePtr) + 1)
		*tex.saveStack[tex.savePtr].pHh().pB0() = 0
	}
	*tex.saveStack[tex.savePtr].pHh().pB1() = l
	tex.saveStack[tex.savePtr].pHh().rh = p
	tex.savePtr = uint16(int32(tex.savePtr) + 1)
}

func (tex *Context) eqDefine(p uint16, t byte, e uint16) {
	if tex.eqtb[p-1].hh().b1() == tex.curLevel {
		tex.eqDestroy(tex.eqtb[p-1])
	} else if tex.curLevel > 1 {
		tex.eqSave(p, tex.eqtb[p-1].hh().b1())
	}
	*tex.eqtb[p-1].pHh().pB1() = tex.curLevel
	*tex.eqtb[p-1].pHh().pB0() = t
	tex.eqtb[p-1].pHh().rh = e
}

func (tex *Context) eqWordDefine(p uint16, w int32) {
	if tex.xeqLevel[p-5263] != tex.curLevel {
		tex.eqSave(p, tex.xeqLevel[p-5263])
		tex.xeqLevel[p-5263] = tex.curLevel
	}
	*tex.eqtb[p-1].pInt() = w
}

func (tex *Context) geqDefine(p uint16, t byte, e uint16) {
	tex.eqDestroy(tex.eqtb[p-1])
	*tex.eqtb[p-1].pHh().pB1() = 1
	*tex.eqtb[p-1].pHh().pB0() = t
	tex.eqtb[p-1].pHh().rh = e
}

func (tex *Context) geqWordDefine(p uint16, w int32) {
	*tex.eqtb[p-1].pInt() = w
	tex.xeqLevel[p-5263] = 1
}

func (tex *Context) saveForAfter(t uint16) {
	if tex.curLevel > 1 {
		if tex.savePtr > tex.maxSaveStack {
			tex.maxSaveStack = tex.savePtr
			if int32(tex.maxSaveStack) > saveSize-6 {
				tex.overflow(541, saveSize)
			}
		}
		*tex.saveStack[tex.savePtr].pHh().pB0() = 2
		*tex.saveStack[tex.savePtr].pHh().pB1() = 0
		tex.saveStack[tex.savePtr].pHh().rh = t
		tex.savePtr = uint16(int32(tex.savePtr) + 1)
	}
}

func (tex *Context) unsave() {
	var p uint16 // 0..65535
	var l byte   // 0..255
	var t uint16 // 0..65535
	if tex.curLevel > 1 {
		tex.curLevel = byte(int32(tex.curLevel) - 1)
		for true {
			tex.savePtr = uint16(int32(tex.savePtr) - 1)
			if tex.saveStack[tex.savePtr].hh().b0() == 3 {
				goto label30
			}
			p = tex.saveStack[tex.savePtr].hh().rh
			if tex.saveStack[tex.savePtr].hh().b0() == 2 {
				t = tex.curTok
				tex.curTok = p
				tex.backInput()
				tex.curTok = t
			} else {
				if tex.saveStack[tex.savePtr].hh().b0() == 0 {
					l = tex.saveStack[tex.savePtr].hh().b1()
					tex.savePtr = uint16(int32(tex.savePtr) - 1)
				} else {
					tex.saveStack[tex.savePtr] = tex.eqtb[2881-1]
				}
				if p < 5263 {
					if tex.eqtb[p-1].hh().b1() == 1 {
						tex.eqDestroy(tex.saveStack[tex.savePtr])
					} else {
						tex.eqDestroy(tex.eqtb[p-1])
						tex.eqtb[p-1] = tex.saveStack[tex.savePtr]
					}
				} else if tex.xeqLevel[p-5263] != 1 {
					tex.eqtb[p-1] = tex.saveStack[tex.savePtr]
					tex.xeqLevel[p-5263] = l
				} else {
				}
			}
		}
	label30:
		tex.curGroup = tex.saveStack[tex.savePtr].hh().b1()
		tex.curBoundary = tex.saveStack[tex.savePtr].hh().rh
	} else {
		tex.confusion(543)
	}
}

func (tex *Context) prepareMag() {
	if (tex.magSet > 0) && (tex.eqtb[5280-1].int() != tex.magSet) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(547)
		tex.printInt(tex.eqtb[5280-1].int())
		tex.print(548)
		tex.printNl(549)
		tex.helpPtr = 2
		tex.helpLine[1] = 550
		tex.helpLine[0] = 551
		tex.intError(tex.magSet)
		tex.geqWordDefine(5280, tex.magSet)
	}
	if (tex.eqtb[5280-1].int() <= 0) || (tex.eqtb[5280-1].int() > 32768) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(552)
		tex.helpPtr = 1
		tex.helpLine[0] = 553
		tex.intError(tex.eqtb[5280-1].int())
		tex.geqWordDefine(5280, 1000)
	}
	tex.magSet = tex.eqtb[5280-1].int()
}

func (tex *Context) tokenShow(p uint16) {
	if p != 0 {
		tex.showTokenList(int32(tex.mem[p].hh().rh), 0, 10000000)
	}
}

func (tex *Context) printMeaning() {
	tex.printCmdChr(tex.curCmd, tex.curChr)
	if tex.curCmd >= 111 {
		tex.printChar(58)
		tex.printLn()
		tex.tokenShow(tex.curChr)
	} else if tex.curCmd == 110 {
		tex.printChar(58)
		tex.printLn()
		tex.tokenShow(tex.curMark[tex.curChr])
	}
}

func (tex *Context) showCurCmdChr() {
	tex.beginDiagnostic()
	tex.printNl(123)
	if tex.curList.modeField != tex.shownMode {
		tex.printMode(int32(tex.curList.modeField))
		tex.print(568)
		tex.shownMode = tex.curList.modeField
	}
	tex.printCmdChr(tex.curCmd, tex.curChr)
	tex.printChar(125)
	tex.endDiagnostic(false)
}

func (tex *Context) showContext() {
	var oldSetting byte // 0..21
	var nn int32        // integer
	var bottomLine bool // boolean
	var i uint16        // 0..500
	var j uint16        // 0..500
	var l byte          // 0..42
	var m int32         // integer
	var n byte          // 0..72
	var p int32         // integer
	var q int32         // integer
	tex.basePtr = tex.inputPtr
	tex.inputStack[tex.basePtr] = tex.curInput
	nn = -1
	bottomLine = false
	for true {
		tex.curInput = tex.inputStack[tex.basePtr]
		if tex.curInput.stateField != 0 {
			if (tex.curInput.nameField > 17) || (tex.basePtr == 0) {
				bottomLine = true
			}
		}
		if (tex.basePtr == tex.inputPtr) || bottomLine || (nn < tex.eqtb[5317-1].int()) {
			if (tex.basePtr == tex.inputPtr) || (tex.curInput.stateField != 0) || (tex.curInput.indexField != 3) || (tex.curInput.locField != 0) {
				tex.tally = 0
				oldSetting = tex.selector
				if tex.curInput.stateField != 0 {
					if tex.curInput.nameField <= 17 {
						if tex.curInput.nameField == 0 {
							if tex.basePtr == 0 {
								tex.printNl(574)
							} else {
								tex.printNl(575)
							}
						} else {
							tex.printNl(576)
							if tex.curInput.nameField == 17 {
								tex.printChar(42)
							} else {
								tex.printInt(int32(tex.curInput.nameField) - 1)
							}
							tex.printChar(62)
						}
					} else {
						tex.printNl(577)
						tex.printInt(tex.line)
					}
					tex.printChar(32)
					l = byte(tex.tally)
					tex.tally = 0
					tex.selector = 20
					tex.trickCount = 1000000
					if int32(tex.buffer[tex.curInput.limitField]) == tex.eqtb[5311-1].int() {
						j = tex.curInput.limitField
					} else {
						j = uint16(int32(tex.curInput.limitField) + 1)
					}
					if j > 0 {
						for _i := int64(tex.curInput.startField); _i <= int64(int32(j)-1); _i++ {
							i = uint16(_i)
							if i == tex.curInput.locField {
								tex.firstCount = tex.tally
								tex.trickCount = tex.tally + 1 + errorLine - halfErrorLine
								if tex.trickCount < errorLine {
									tex.trickCount = errorLine
								}
							}
							tex.print(int32(tex.buffer[i]))
						}
					}
				} else {
					switch tex.curInput.indexField {
					case 0:
						tex.printNl(578)
					case 1, 2:
						tex.printNl(579)
					case 3:
						if tex.curInput.locField == 0 {
							tex.printNl(580)
						} else {
							tex.printNl(581)
						}
					case 4:
						tex.printNl(582)
					case 5:
						tex.printLn()
						tex.printCs(int32(tex.curInput.nameField))
					case 6:
						tex.printNl(583)
					case 7:
						tex.printNl(584)
					case 8:
						tex.printNl(585)
					case 9:
						tex.printNl(586)
					case 10:
						tex.printNl(587)
					case 11:
						tex.printNl(588)
					case 12:
						tex.printNl(589)
					case 13:
						tex.printNl(590)
					case 14:
						tex.printNl(591)
					case 15:
						tex.printNl(592)
					default:
						tex.printNl(63)
					}
					l = byte(tex.tally)
					tex.tally = 0
					tex.selector = 20
					tex.trickCount = 1000000
					if tex.curInput.indexField < 5 {
						tex.showTokenList(int32(tex.curInput.startField), int32(tex.curInput.locField), 100000)
					} else {
						tex.showTokenList(int32(tex.mem[tex.curInput.startField].hh().rh), int32(tex.curInput.locField), 100000)
					}
				}
				tex.selector = oldSetting
				if tex.trickCount == 1000000 {
					tex.firstCount = tex.tally
					tex.trickCount = tex.tally + 1 + errorLine - halfErrorLine
					if tex.trickCount < errorLine {
						tex.trickCount = errorLine
					}
				}
				if tex.tally < tex.trickCount {
					m = tex.tally - tex.firstCount
				} else {
					m = tex.trickCount - tex.firstCount
				}
				if int32(l)+tex.firstCount <= halfErrorLine {
					p = 0
					n = byte(int32(l) + tex.firstCount)
				} else {
					tex.print(277)
					p = int32(l) + tex.firstCount - halfErrorLine + 3
					n = halfErrorLine
				}
				for _i := int64(p); _i <= int64(tex.firstCount-1); _i++ {
					q = int32(_i)
					tex.printChar(tex.trickBuf[(q % errorLine)])
				}
				tex.printLn()
				for _i := int64(1); _i <= int64(n); _i++ {
					q = int32(_i)
					tex.printChar(32)
				}
				if m+int32(n) <= errorLine {
					p = tex.firstCount + m
				} else {
					p = tex.firstCount + (errorLine - int32(n) - 3)
				}
				for _i := int64(tex.firstCount); _i <= int64(p-1); _i++ {
					q = int32(_i)
					tex.printChar(tex.trickBuf[(q % errorLine)])
				}
				if m+int32(n) > errorLine {
					tex.print(277)
				}
				nn = nn + 1
			}
		} else if nn == tex.eqtb[5317-1].int() {
			tex.printNl(277)
			nn = nn + 1
		}
		if bottomLine {
			goto label30
		}
		tex.basePtr = byte(int32(tex.basePtr) - 1)
	}
label30:
	tex.curInput = tex.inputStack[tex.inputPtr]
}

func (tex *Context) beginTokenList(p uint16, t byte) {
	if tex.inputPtr > tex.maxInStack {
		tex.maxInStack = tex.inputPtr
		if tex.inputPtr == stackSize {
			tex.overflow(593, stackSize)
		}
	}
	tex.inputStack[tex.inputPtr] = tex.curInput
	tex.inputPtr = byte(int32(tex.inputPtr) + 1)
	tex.curInput.stateField = 0
	tex.curInput.startField = p
	tex.curInput.indexField = t
	if t >= 5 {
		*tex.mem[p].pHh().pLh() = uint16(int32(tex.mem[p].hh().lh()) + 1)
		if t == 5 {
			tex.curInput.limitField = uint16(tex.paramPtr)
		} else {
			tex.curInput.locField = tex.mem[p].hh().rh
			if tex.eqtb[5293-1].int() > 1 {
				tex.beginDiagnostic()
				tex.printNl(338)
				switch t {
				case 14:
					tex.printEsc(351)
				case 15:
					tex.printEsc(594)
				default:
					tex.printCmdChr(72, uint16(int32(t)+3407))
				}
				tex.print(556)
				tex.tokenShow(p)
				tex.endDiagnostic(false)
			}
		}
	} else {
		tex.curInput.locField = p
	}
}

func (tex *Context) endTokenList() {
	if tex.curInput.indexField >= 3 {
		if tex.curInput.indexField <= 4 {
			tex.flushList(tex.curInput.startField)
		} else {
			tex.deleteTokenRef(tex.curInput.startField)
			if tex.curInput.indexField == 5 {
				for uint16(tex.paramPtr) > tex.curInput.limitField {
					tex.paramPtr = byte(int32(tex.paramPtr) - 1)
					tex.flushList(tex.paramStack[tex.paramPtr])
				}
			}
		}
	} else if tex.curInput.indexField == 1 {
		if tex.alignState > 500000 {
			tex.alignState = 0
		} else {
			tex.fatalError(595)
		}
	}
	tex.inputPtr = byte(int32(tex.inputPtr) - 1)
	tex.curInput = tex.inputStack[tex.inputPtr]
	if tex.interrupt != 0 {
		tex.pauseForInstructions()
	}
}

func (tex *Context) backInput() {
	var p uint16 // 0..65535
	for (tex.curInput.stateField == 0) && (tex.curInput.locField == 0) && (tex.curInput.indexField != 2) {
		tex.endTokenList()
	}
	p = tex.getAvail()
	*tex.mem[p].pHh().pLh() = tex.curTok
	if tex.curTok < 768 {
		if tex.curTok < 512 {
			tex.alignState = tex.alignState - 1
		} else {
			tex.alignState = tex.alignState + 1
		}
	}
	if tex.inputPtr > tex.maxInStack {
		tex.maxInStack = tex.inputPtr
		if tex.inputPtr == stackSize {
			tex.overflow(593, stackSize)
		}
	}
	tex.inputStack[tex.inputPtr] = tex.curInput
	tex.inputPtr = byte(int32(tex.inputPtr) + 1)
	tex.curInput.stateField = 0
	tex.curInput.startField = p
	tex.curInput.indexField = 3
	tex.curInput.locField = p
}

func (tex *Context) backError() {
	tex.OKToInterrupt = false
	tex.backInput()
	tex.OKToInterrupt = true
	tex.error1()
}

func (tex *Context) insError() {
	tex.OKToInterrupt = false
	tex.backInput()
	tex.curInput.indexField = 4
	tex.OKToInterrupt = true
	tex.error1()
}

func (tex *Context) beginFileReading() {
	if tex.inOpen == maxInOpen {
		tex.overflow(596, maxInOpen)
	}
	if tex.first == bufSize {
		tex.overflow(256, bufSize)
	}
	tex.inOpen = byte(int32(tex.inOpen) + 1)
	if tex.inputPtr > tex.maxInStack {
		tex.maxInStack = tex.inputPtr
		if tex.inputPtr == stackSize {
			tex.overflow(593, stackSize)
		}
	}
	tex.inputStack[tex.inputPtr] = tex.curInput
	tex.inputPtr = byte(int32(tex.inputPtr) + 1)
	tex.curInput.indexField = tex.inOpen
	tex.lineStack[tex.curInput.indexField-1] = tex.line
	tex.curInput.startField = tex.first
	tex.curInput.stateField = 1
	tex.curInput.nameField = 0
}

func (tex *Context) endFileReading() {
	tex.first = tex.curInput.startField
	tex.line = tex.lineStack[tex.curInput.indexField-1]
	if tex.curInput.nameField > 17 {
		tex.aClose(&tex.inputFile[tex.curInput.indexField-1])
	}
	tex.inputPtr = byte(int32(tex.inputPtr) - 1)
	tex.curInput = tex.inputStack[tex.inputPtr]
	tex.inOpen = byte(int32(tex.inOpen) - 1)
}

func (tex *Context) clearForErrorPrompt() {
	for (tex.curInput.stateField != 0) && (tex.curInput.nameField == 0) && (tex.inputPtr > 0) && (tex.curInput.locField > tex.curInput.limitField) {
		tex.endFileReading()
	}
	tex.printLn()
	breakIn(&tex.termIn, true)
}

func (tex *Context) checkOuterValidity() {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	if tex.scannerStatus != 0 {
		tex.deletionsAllowed = false
		if tex.curCs != 0 {
			if (tex.curInput.stateField == 0) || (tex.curInput.nameField < 1) || (tex.curInput.nameField > 17) {
				p = tex.getAvail()
				*tex.mem[p].pHh().pLh() = uint16(4095 + int32(tex.curCs))
				tex.beginTokenList(p, 3)
			}
			tex.curCmd = 10
			tex.curChr = 32
		}
		if tex.scannerStatus > 1 {
			tex.runaway()
			if tex.curCs == 0 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(604)
			} else {
				tex.curCs = 0
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(605)
			}
			tex.print(606)
			p = tex.getAvail()
			switch tex.scannerStatus {
			case 2:
				tex.print(570)
				*tex.mem[p].pHh().pLh() = 637
			case 3:
				tex.print(612)
				*tex.mem[p].pHh().pLh() = tex.parToken
				tex.longState = 113
			case 4:
				tex.print(572)
				*tex.mem[p].pHh().pLh() = 637
				q = p
				p = tex.getAvail()
				tex.mem[p].pHh().rh = q
				*tex.mem[p].pHh().pLh() = 6710
				tex.alignState = -1000000
			case 5:
				tex.print(573)
				*tex.mem[p].pHh().pLh() = 637
			}
			tex.beginTokenList(p, 4)
			tex.print(607)
			tex.sprintCs(tex.warningIndex)
			tex.helpPtr = 4
			tex.helpLine[3] = 608
			tex.helpLine[2] = 609
			tex.helpLine[1] = 610
			tex.helpLine[0] = 611
			tex.error1()
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(598)
			tex.printCmdChr(105, uint16(tex.curIf))
			tex.print(599)
			tex.printInt(tex.skipLine)
			tex.helpPtr = 3
			tex.helpLine[2] = 600
			tex.helpLine[1] = 601
			tex.helpLine[0] = 602
			if tex.curCs != 0 {
				tex.curCs = 0
			} else {
				tex.helpLine[2] = 603
			}
			tex.curTok = 6713
			tex.insError()
		}
		tex.deletionsAllowed = true
	}
}

func (tex *Context) getNext() {
	var k uint16   // 0..500
	var t uint16   // 0..65535
	var cat byte   // 0..15
	var c, cc byte // 0..255
	var d byte     // 2..3
label20:
	tex.curCs = 0
	if tex.curInput.stateField != 0 {
	label25:
		if tex.curInput.locField <= tex.curInput.limitField {
			tex.curChr = uint16(tex.buffer[tex.curInput.locField])
			tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
		label21:
			tex.curCmd = byte(tex.eqtb[3983+int32(tex.curChr)-1].hh().rh)
			switch int32(tex.curInput.stateField) + int32(tex.curCmd) {
			case 10, 26, 42, 27, 43:
				goto label25
			case 1, 17, 33:
				if tex.curInput.locField > tex.curInput.limitField {
					tex.curCs = 513
				} else {
				label26:
					k = tex.curInput.locField
					tex.curChr = uint16(tex.buffer[k])
					cat = byte(tex.eqtb[3983+int32(tex.curChr)-1].hh().rh)
					k = uint16(int32(k) + 1)
					if cat == 11 {
						tex.curInput.stateField = 17
					} else if cat == 10 {
						tex.curInput.stateField = 17
					} else {
						tex.curInput.stateField = 1
					}
					if (cat == 11) && (k <= tex.curInput.limitField) {
						for {
							tex.curChr = uint16(tex.buffer[k])
							cat = byte(tex.eqtb[3983+int32(tex.curChr)-1].hh().rh)
							k = uint16(int32(k) + 1)
							if (cat != 11) || (k > tex.curInput.limitField) {
								break
							}
						}
						if uint16(tex.buffer[k]) == tex.curChr {
							if cat == 7 {
								if k < tex.curInput.limitField {
									c = tex.buffer[int32(k)+1]
									if c < 128 {
										d = 2
										if ((c >= 48) && (c <= 57)) || ((c >= 97) && (c <= 102)) {
											if int32(k)+2 <= int32(tex.curInput.limitField) {
												cc = tex.buffer[int32(k)+2]
												if ((cc >= 48) && (cc <= 57)) || ((cc >= 97) && (cc <= 102)) {
													d = byte(int32(d) + 1)
												}
											}
										}
										if d > 2 {
											if c <= 57 {
												tex.curChr = uint16(int32(c) - 48)
											} else {
												tex.curChr = uint16(int32(c) - 87)
											}
											if cc <= 57 {
												tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 48)
											} else {
												tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 87)
											}
											tex.buffer[int32(k)-1] = byte(tex.curChr)
										} else if c < 64 {
											tex.buffer[int32(k)-1] = byte(int32(c) + 64)
										} else {
											tex.buffer[int32(k)-1] = byte(int32(c) - 64)
										}
										tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - int32(d))
										tex.first = uint16(int32(tex.first) - int32(d))
										for k <= tex.curInput.limitField {
											tex.buffer[k] = tex.buffer[int32(k)+int32(d)]
											k = uint16(int32(k) + 1)
										}
										goto label26
									}
								}
							}
						}
						if cat != 11 {
							k = uint16(int32(k) - 1)
						}
						if int32(k) > int32(tex.curInput.locField)+1 {
							tex.curCs = tex.idLookup(int32(tex.curInput.locField), int32(k)-int32(tex.curInput.locField))
							tex.curInput.locField = k
							goto label40
						}
					} else {
						if uint16(tex.buffer[k]) == tex.curChr {
							if cat == 7 {
								if k < tex.curInput.limitField {
									c = tex.buffer[int32(k)+1]
									if c < 128 {
										d = 2
										if ((c >= 48) && (c <= 57)) || ((c >= 97) && (c <= 102)) {
											if int32(k)+2 <= int32(tex.curInput.limitField) {
												cc = tex.buffer[int32(k)+2]
												if ((cc >= 48) && (cc <= 57)) || ((cc >= 97) && (cc <= 102)) {
													d = byte(int32(d) + 1)
												}
											}
										}
										if d > 2 {
											if c <= 57 {
												tex.curChr = uint16(int32(c) - 48)
											} else {
												tex.curChr = uint16(int32(c) - 87)
											}
											if cc <= 57 {
												tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 48)
											} else {
												tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 87)
											}
											tex.buffer[int32(k)-1] = byte(tex.curChr)
										} else if c < 64 {
											tex.buffer[int32(k)-1] = byte(int32(c) + 64)
										} else {
											tex.buffer[int32(k)-1] = byte(int32(c) - 64)
										}
										tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - int32(d))
										tex.first = uint16(int32(tex.first) - int32(d))
										for k <= tex.curInput.limitField {
											tex.buffer[k] = tex.buffer[int32(k)+int32(d)]
											k = uint16(int32(k) + 1)
										}
										goto label26
									}
								}
							}
						}
					}
					tex.curCs = uint16(257 + int32(tex.buffer[tex.curInput.locField]))
					tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
				}
			label40:
				tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
				tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
				if tex.curCmd >= 113 {
					tex.checkOuterValidity()
				}
			case 14, 30, 46:
				tex.curCs = uint16(int32(tex.curChr) + 1)
				tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
				tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
				tex.curInput.stateField = 1
				if tex.curCmd >= 113 {
					tex.checkOuterValidity()
				}
			case 8, 24, 40:
				if tex.curChr == uint16(tex.buffer[tex.curInput.locField]) {
					if tex.curInput.locField < tex.curInput.limitField {
						c = tex.buffer[int32(tex.curInput.locField)+1]
						if c < 128 {
							tex.curInput.locField = uint16(int32(tex.curInput.locField) + 2)
							if ((c >= 48) && (c <= 57)) || ((c >= 97) && (c <= 102)) {
								if tex.curInput.locField <= tex.curInput.limitField {
									cc = tex.buffer[tex.curInput.locField]
									if ((cc >= 48) && (cc <= 57)) || ((cc >= 97) && (cc <= 102)) {
										tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
										if c <= 57 {
											tex.curChr = uint16(int32(c) - 48)
										} else {
											tex.curChr = uint16(int32(c) - 87)
										}
										if cc <= 57 {
											tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 48)
										} else {
											tex.curChr = uint16((16 * int32(tex.curChr)) + int32(cc) - 87)
										}
										goto label21
									}
								}
							}
							if c < 64 {
								tex.curChr = uint16(int32(c) + 64)
							} else {
								tex.curChr = uint16(int32(c) - 64)
							}
							goto label21
						}
					}
				}
				tex.curInput.stateField = 1
			case 16, 32, 48:
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(613)
				tex.helpPtr = 2
				tex.helpLine[1] = 614
				tex.helpLine[0] = 615
				tex.deletionsAllowed = false
				tex.error1()
				tex.deletionsAllowed = true
				goto label20
			case 11:
				tex.curInput.stateField = 17
				tex.curChr = 32
			case 6:
				tex.curInput.locField = uint16(int32(tex.curInput.limitField) + 1)
				tex.curCmd = 10
				tex.curChr = 32
			case 22, 15, 31, 47:
				tex.curInput.locField = uint16(int32(tex.curInput.limitField) + 1)
				goto label25
			case 38:
				tex.curInput.locField = uint16(int32(tex.curInput.limitField) + 1)
				tex.curCs = tex.parLoc
				tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
				tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
				if tex.curCmd >= 113 {
					tex.checkOuterValidity()
				}
			case 2:
				tex.alignState = tex.alignState + 1
			case 18, 34:
				tex.curInput.stateField = 1
				tex.alignState = tex.alignState + 1
			case 3:
				tex.alignState = tex.alignState - 1
			case 19, 35:
				tex.curInput.stateField = 1
				tex.alignState = tex.alignState - 1
			case 20, 21, 23, 25, 28, 29, 36, 37, 39, 41, 44, 45:
				tex.curInput.stateField = 1
			default:
			}
		} else {
			tex.curInput.stateField = 33
			if tex.curInput.nameField > 17 {
				tex.line = tex.line + 1
				tex.first = tex.curInput.startField
				if !tex.forceEof {
					if tex.inputLn(&tex.inputFile[tex.curInput.indexField-1], true) {
						tex.firmUpTheLine()
					} else {
						tex.forceEof = true
					}
				}
				if tex.forceEof {
					tex.printChar(41)
					tex.openParens = byte(int32(tex.openParens) - 1)
					break1(&tex.termOut)
					tex.forceEof = false
					tex.endFileReading()
					tex.checkOuterValidity()
					goto label20
				}
				if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
					tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - 1)
				} else {
					tex.buffer[tex.curInput.limitField] = byte(tex.eqtb[5311-1].int())
				}
				tex.first = uint16(int32(tex.curInput.limitField) + 1)
				tex.curInput.locField = tex.curInput.startField
			} else {
				if !(tex.curInput.nameField == 0) {
					tex.curCmd = 0
					tex.curChr = 0
					goto label10
				}
				if tex.inputPtr > 0 {
					tex.endFileReading()
					goto label20
				}
				if tex.selector < 18 {
					tex.openLogFile()
				}
				if tex.interaction > 1 {
					if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
						tex.curInput.limitField = uint16(int32(tex.curInput.limitField) + 1)
					}
					if tex.curInput.limitField == tex.curInput.startField {
						tex.printNl(616)
					}
					tex.printLn()
					tex.first = tex.curInput.startField
					tex.print(42)
					tex.termInput()
					tex.curInput.limitField = tex.last
					if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
						tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - 1)
					} else {
						tex.buffer[tex.curInput.limitField] = byte(tex.eqtb[5311-1].int())
					}
					tex.first = uint16(int32(tex.curInput.limitField) + 1)
					tex.curInput.locField = tex.curInput.startField
				} else {
					tex.fatalError(617)
				}
			}
			if tex.interrupt != 0 {
				tex.pauseForInstructions()
			}
			goto label25
		}
	} else if tex.curInput.locField != 0 {
		t = tex.mem[tex.curInput.locField].hh().lh()
		tex.curInput.locField = tex.mem[tex.curInput.locField].hh().rh
		if t >= 4095 {
			tex.curCs = uint16(int32(t) - 4095)
			tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
			tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
			if tex.curCmd >= 113 {
				if tex.curCmd == 116 {
					tex.curCs = uint16(int32(tex.mem[tex.curInput.locField].hh().lh()) - 4095)
					tex.curInput.locField = 0
					tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
					tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
					if tex.curCmd > 100 {
						tex.curCmd = 0
						tex.curChr = 257
					}
				} else {
					tex.checkOuterValidity()
				}
			}
		} else {
			tex.curCmd = byte((int32(t) / 256))
			tex.curChr = uint16((int32(t) % 256))
			switch tex.curCmd {
			case 1:
				tex.alignState = tex.alignState + 1
			case 2:
				tex.alignState = tex.alignState - 1
			case 5:
				tex.beginTokenList(tex.paramStack[int32(tex.curInput.limitField)+int32(tex.curChr)-1], 0)
				goto label20
			default:
			}
		}
	} else {
		tex.endTokenList()
		goto label20
	}
	if tex.curCmd <= 5 {
		if tex.curCmd >= 4 {
			if tex.alignState == 0 {
				if (tex.scannerStatus == 4) || (tex.curAlign == 0) {
					tex.fatalError(595)
				}
				tex.curCmd = byte(tex.mem[int32(tex.curAlign)+5].hh().lh())
				*tex.mem[int32(tex.curAlign)+5].pHh().pLh() = tex.curChr
				if tex.curCmd == 63 {
					tex.beginTokenList(29990, 2)
				} else {
					tex.beginTokenList(uint16(tex.mem[int32(tex.curAlign)+2].int()), 2)
				}
				tex.alignState = 1000000
				goto label20
			}
		}
	}
label10:
}

func (tex *Context) firmUpTheLine() {
	var k uint16 // 0..500
	tex.curInput.limitField = tex.last
	if tex.eqtb[5291-1].int() > 0 {
		if tex.interaction > 1 {
			tex.printLn()
			if tex.curInput.startField < tex.curInput.limitField {
				for _i := int64(tex.curInput.startField); _i <= int64(int32(tex.curInput.limitField)-1); _i++ {
					k = uint16(_i)
					tex.print(int32(tex.buffer[k]))
				}
			}
			tex.first = tex.curInput.limitField
			tex.print(618)
			tex.termInput()
			if tex.last > tex.first {
				for _i := int64(tex.first); _i <= int64(int32(tex.last)-1); _i++ {
					k = uint16(_i)
					tex.buffer[int32(k)+int32(tex.curInput.startField)-int32(tex.first)] = tex.buffer[k]
				}
				tex.curInput.limitField = uint16(int32(tex.curInput.startField) + int32(tex.last) - int32(tex.first))
			}
		}
	}
}

func (tex *Context) getToken() {
	tex.noNewControlSequence = false
	tex.getNext()
	tex.noNewControlSequence = true
	if tex.curCs == 0 {
		tex.curTok = uint16((int32(tex.curCmd) * 256) + int32(tex.curChr))
	} else {
		tex.curTok = uint16(4095 + int32(tex.curCs))
	}
}

func (tex *Context) macroCall() {
	var r uint16                // 0..65535
	var p uint16                // 0..65535
	var q uint16                // 0..65535
	var s uint16                // 0..65535
	var t uint16                // 0..65535
	var u, v uint16             // 0..65535
	var rbracePtr uint16        // 0..65535
	var n byte                  // 0..63
	var unbalance uint16        // 0..65535
	var m uint16                // 0..65535
	var refCount uint16         // 0..65535
	var saveScannerStatus byte  // 0..63
	var saveWarningIndex uint16 // 0..65535
	var matchChr byte           // 0..255
	saveScannerStatus = tex.scannerStatus
	saveWarningIndex = tex.warningIndex
	tex.warningIndex = tex.curCs
	refCount = tex.curChr
	r = tex.mem[refCount].hh().rh
	n = 0
	if tex.eqtb[5293-1].int() > 0 {
		tex.beginDiagnostic()
		tex.printLn()
		tex.printCs(int32(tex.warningIndex))
		tex.tokenShow(refCount)
		tex.endDiagnostic(false)
	}
	if tex.mem[r].hh().lh() != 3584 {
		tex.scannerStatus = 3
		unbalance = 0
		tex.longState = tex.eqtb[tex.curCs-1].hh().b0()
		if tex.longState >= 113 {
			tex.longState = byte(int32(tex.longState) - 2)
		}
		for {
			tex.mem[29997].pHh().rh = 0
			if (tex.mem[r].hh().lh() > 3583) || (tex.mem[r].hh().lh() < 3328) {
				s = 0
			} else {
				matchChr = byte(int32(tex.mem[r].hh().lh()) - 3328)
				s = tex.mem[r].hh().rh
				r = s
				p = 29997
				m = 0
			}
		label22:
			tex.getToken()
			if tex.curTok == tex.mem[r].hh().lh() {
				r = tex.mem[r].hh().rh
				if (tex.mem[r].hh().lh() >= 3328) && (tex.mem[r].hh().lh() <= 3584) {
					if tex.curTok < 512 {
						tex.alignState = tex.alignState - 1
					}
					goto label40
				} else {
					goto label22
				}
			}
			if s != r {
				if s == 0 {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(650)
					tex.sprintCs(tex.warningIndex)
					tex.print(651)
					tex.helpPtr = 4
					tex.helpLine[3] = 652
					tex.helpLine[2] = 653
					tex.helpLine[1] = 654
					tex.helpLine[0] = 655
					tex.error1()
					goto label10
				} else {
					t = s
					for {

						{
							q = tex.getAvail()
							tex.mem[p].pHh().rh = q
							*tex.mem[q].pHh().pLh() = tex.mem[t].hh().lh()
							p = q
						}
						m = uint16(int32(m) + 1)
						u = tex.mem[t].hh().rh
						v = s
						for true {
							if u == r {
								if tex.curTok != tex.mem[v].hh().lh() {
									goto label30
								} else {
									r = tex.mem[v].hh().rh
									goto label22
								}
							}
							if tex.mem[u].hh().lh() != tex.mem[v].hh().lh() {
								goto label30
							}
							u = tex.mem[u].hh().rh
							v = tex.mem[v].hh().rh
						}
					label30:
						t = tex.mem[t].hh().rh
						if t == r {
							break
						}
					}
					r = s
				}
			}
			if tex.curTok == tex.parToken {
				if tex.longState != 112 {
					if tex.longState == 111 {
						tex.runaway()
						if tex.interaction == 3 {
						}
						tex.printNl(262)
						tex.print(645)
						tex.sprintCs(tex.warningIndex)
						tex.print(646)
						tex.helpPtr = 3
						tex.helpLine[2] = 647
						tex.helpLine[1] = 648
						tex.helpLine[0] = 649
						tex.backError()
					}
					tex.pstack[n] = tex.mem[29997].hh().rh
					tex.alignState = tex.alignState - int32(unbalance)
					for _i := int64(0); _i <= int64(n); _i++ {
						m = uint16(_i)
						tex.flushList(tex.pstack[m])
					}
					goto label10
				}
			}
			if tex.curTok < 768 {
				if tex.curTok < 512 {
					unbalance = 1
					for true {
						q = tex.avail
						if q == 0 {
							q = tex.getAvail()
						} else {
							tex.avail = tex.mem[q].hh().rh
							tex.mem[q].pHh().rh = 0
						}
						tex.mem[p].pHh().rh = q
						*tex.mem[q].pHh().pLh() = tex.curTok
						p = q
						tex.getToken()
						if tex.curTok == tex.parToken {
							if tex.longState != 112 {
								if tex.longState == 111 {
									tex.runaway()
									if tex.interaction == 3 {
									}
									tex.printNl(262)
									tex.print(645)
									tex.sprintCs(tex.warningIndex)
									tex.print(646)
									tex.helpPtr = 3
									tex.helpLine[2] = 647
									tex.helpLine[1] = 648
									tex.helpLine[0] = 649
									tex.backError()
								}
								tex.pstack[n] = tex.mem[29997].hh().rh
								tex.alignState = tex.alignState - int32(unbalance)
								for _i := int64(0); _i <= int64(n); _i++ {
									m = uint16(_i)
									tex.flushList(tex.pstack[m])
								}
								goto label10
							}
						}
						if tex.curTok < 768 {
							if tex.curTok < 512 {
								unbalance = uint16(int32(unbalance) + 1)
							} else {
								unbalance = uint16(int32(unbalance) - 1)
								if unbalance == 0 {
									goto label31
								}
							}
						}
					}
				label31:
					rbracePtr = p
					q = tex.getAvail()
					tex.mem[p].pHh().rh = q
					*tex.mem[q].pHh().pLh() = tex.curTok
					p = q
				} else {
					tex.backInput()
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(637)
					tex.sprintCs(tex.warningIndex)
					tex.print(638)
					tex.helpPtr = 6
					tex.helpLine[5] = 639
					tex.helpLine[4] = 640
					tex.helpLine[3] = 641
					tex.helpLine[2] = 642
					tex.helpLine[1] = 643
					tex.helpLine[0] = 644
					tex.alignState = tex.alignState + 1
					tex.longState = 111
					tex.curTok = tex.parToken
					tex.insError()
					goto label22
				}
			} else {
				if tex.curTok == 2592 {
					if tex.mem[r].hh().lh() <= 3584 {
						if tex.mem[r].hh().lh() >= 3328 {
							goto label22
						}
					}
				}
				q = tex.getAvail()
				tex.mem[p].pHh().rh = q
				*tex.mem[q].pHh().pLh() = tex.curTok
				p = q
			}
			m = uint16(int32(m) + 1)
			if tex.mem[r].hh().lh() > 3584 {
				goto label22
			}
			if tex.mem[r].hh().lh() < 3328 {
				goto label22
			}
		label40:
			if s != 0 {
				if (m == 1) && (tex.mem[p].hh().lh() < 768) {
					tex.mem[rbracePtr].pHh().rh = 0
					tex.mem[p].pHh().rh = tex.avail
					tex.avail = p
					p = tex.mem[29997].hh().rh
					tex.pstack[n] = tex.mem[p].hh().rh
					tex.mem[p].pHh().rh = tex.avail
					tex.avail = p
				} else {
					tex.pstack[n] = tex.mem[29997].hh().rh
				}
				n = byte(int32(n) + 1)
				if tex.eqtb[5293-1].int() > 0 {
					tex.beginDiagnostic()
					tex.printNl(uint16(matchChr))
					tex.printInt(int32(n))
					tex.print(656)
					tex.showTokenList(int32(tex.pstack[int32(n)-1]), 0, 1000)
					tex.endDiagnostic(false)
				}
			}
			if tex.mem[r].hh().lh() == 3584 {
				break
			}
		}
	}
	for (tex.curInput.stateField == 0) && (tex.curInput.locField == 0) && (tex.curInput.indexField != 2) {
		tex.endTokenList()
	}
	tex.beginTokenList(refCount, 5)
	tex.curInput.nameField = tex.warningIndex
	tex.curInput.locField = tex.mem[r].hh().rh
	if n > 0 {
		if int32(tex.paramPtr)+int32(n) > tex.maxParamStack {
			tex.maxParamStack = int32(tex.paramPtr) + int32(n)
			if tex.maxParamStack > paramSize {
				tex.overflow(636, paramSize)
			}
		}
		for _i := int64(0); _i <= int64(int32(n)-1); _i++ {
			m = uint16(_i)
			tex.paramStack[int32(tex.paramPtr)+int32(m)] = tex.pstack[m]
		}
		tex.paramPtr = byte(int32(tex.paramPtr) + int32(n))
	}
label10:
	tex.scannerStatus = saveScannerStatus
	tex.warningIndex = saveWarningIndex
}

func (tex *Context) insertRelax() {
	tex.curTok = uint16(4095 + int32(tex.curCs))
	tex.backInput()
	tex.curTok = 6716
	tex.backInput()
	tex.curInput.indexField = 4
}

func (tex *Context) expand() {
	var t uint16                              // 0..65535
	var p, q, r uint16                        // 0..65535
	var j uint16                              // 0..500
	var cvBackup int32                        // integer
	var cvlBackup, radixBackup, coBackup byte // 0..63
	var backupBackup uint16                   // 0..65535
	var saveScannerStatus byte                // 0..63
	cvBackup = tex.curVal
	cvlBackup = tex.curValLevel
	radixBackup = tex.radix
	coBackup = tex.curOrder
	backupBackup = tex.mem[29987].hh().rh
	if tex.curCmd < 111 {
		if tex.eqtb[5299-1].int() > 1 {
			tex.showCurCmdChr()
		}
		switch tex.curCmd {
		case 110:
			if tex.curMark[tex.curChr] != 0 {
				tex.beginTokenList(tex.curMark[tex.curChr], 14)
			}
		case 102:
			tex.getToken()
			t = tex.curTok
			tex.getToken()
			if tex.curCmd > 100 {
				tex.expand()
			} else {
				tex.backInput()
			}
			tex.curTok = t
			tex.backInput()
		case 103:
			saveScannerStatus = tex.scannerStatus
			tex.scannerStatus = 0
			tex.getToken()
			tex.scannerStatus = saveScannerStatus
			t = tex.curTok
			tex.backInput()
			if t >= 4095 {
				p = tex.getAvail()
				*tex.mem[p].pHh().pLh() = 6718
				tex.mem[p].pHh().rh = tex.curInput.locField
				tex.curInput.startField = p
				tex.curInput.locField = p
			}
		case 107:
			r = tex.getAvail()
			p = r
			for {
				tex.getXToken()
				if tex.curCs == 0 {
					q = tex.getAvail()
					tex.mem[p].pHh().rh = q
					*tex.mem[q].pHh().pLh() = tex.curTok
					p = q
				}
				if tex.curCs != 0 {
					break
				}
			}
			if tex.curCmd != 67 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(625)
				tex.printEsc(505)
				tex.print(626)
				tex.helpPtr = 2
				tex.helpLine[1] = 627
				tex.helpLine[0] = 628
				tex.backError()
			}
			j = tex.first
			p = tex.mem[r].hh().rh
			for p != 0 {
				if j >= tex.maxBufStack {
					tex.maxBufStack = uint16(int32(j) + 1)
					if tex.maxBufStack == bufSize {
						tex.overflow(256, bufSize)
					}
				}
				tex.buffer[j] = byte((int32(tex.mem[p].hh().lh()) % 256))
				j = uint16(int32(j) + 1)
				p = tex.mem[p].hh().rh
			}
			if int32(j) > int32(tex.first)+1 {
				tex.noNewControlSequence = false
				tex.curCs = tex.idLookup(int32(tex.first), int32(j)-int32(tex.first))
				tex.noNewControlSequence = true
			} else if j == tex.first {
				tex.curCs = 513
			} else {
				tex.curCs = uint16(257 + int32(tex.buffer[tex.first]))
			}
			tex.flushList(r)
			if tex.eqtb[tex.curCs-1].hh().b0() == 101 {
				tex.eqDefine(tex.curCs, 0, 256)
			}
			tex.curTok = uint16(int32(tex.curCs) + 4095)
			tex.backInput()
		case 108:
			tex.convToks()
		case 109:
			tex.insTheToks()
		case 105:
			tex.conditional()
		case 106:
			if tex.curChr > uint16(tex.ifLimit) {
				if tex.ifLimit == 1 {
					tex.insertRelax()
				} else {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(777)
					tex.printCmdChr(106, tex.curChr)
					tex.helpPtr = 1
					tex.helpLine[0] = 778
					tex.error1()
				}
			} else {
				for tex.curChr != 2 {
					tex.passText()
				}
				p = tex.condPtr
				tex.ifLine = tex.mem[int32(p)+1].int()
				tex.curIf = tex.mem[p].hh().b1()
				tex.ifLimit = tex.mem[p].hh().b0()
				tex.condPtr = tex.mem[p].hh().rh
				tex.freeNode(p, 2)
			}
		case 104:
			if tex.curChr > 0 {
				tex.forceEof = true
			} else if tex.nameInProgress {
				tex.insertRelax()
			} else {
				tex.startInput()
			}
		default:
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(619)
			tex.helpPtr = 5
			tex.helpLine[4] = 620
			tex.helpLine[3] = 621
			tex.helpLine[2] = 622
			tex.helpLine[1] = 623
			tex.helpLine[0] = 624
			tex.error1()
		}
	} else if tex.curCmd < 115 {
		tex.macroCall()
	} else {
		tex.curTok = 6715
		tex.backInput()
	}
	tex.curVal = cvBackup
	tex.curValLevel = cvlBackup
	tex.radix = radixBackup
	tex.curOrder = coBackup
	tex.mem[29987].pHh().rh = backupBackup
}

func (tex *Context) getXToken() {
label20:
	tex.getNext()
	if tex.curCmd <= 100 {
		goto label30
	}
	if tex.curCmd >= 111 {
		if tex.curCmd < 115 {
			tex.macroCall()
		} else {
			tex.curCs = 2620
			tex.curCmd = 9
			goto label30
		}
	} else {
		tex.expand()
	}
	goto label20
label30:
	if tex.curCs == 0 {
		tex.curTok = uint16((int32(tex.curCmd) * 256) + int32(tex.curChr))
	} else {
		tex.curTok = uint16(4095 + int32(tex.curCs))
	}
}

func (tex *Context) xToken() {
	for tex.curCmd > 100 {
		tex.expand()
		tex.getNext()
	}
	if tex.curCs == 0 {
		tex.curTok = uint16((int32(tex.curCmd) * 256) + int32(tex.curChr))
	} else {
		tex.curTok = uint16(4095 + int32(tex.curCs))
	}
}

func (tex *Context) scanLeftBrace() {
	for {
		tex.getXToken()
		if (tex.curCmd != 10) && (tex.curCmd != 0) {
			break
		}
	}
	if tex.curCmd != 1 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(657)
		tex.helpPtr = 4
		tex.helpLine[3] = 658
		tex.helpLine[2] = 659
		tex.helpLine[1] = 660
		tex.helpLine[0] = 661
		tex.backError()
		tex.curTok = 379
		tex.curCmd = 1
		tex.curChr = 123
		tex.alignState = tex.alignState + 1
	}
}

func (tex *Context) scanOptionalEquals() {
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	if tex.curTok != 3133 {
		tex.backInput()
	}
}

func (tex *Context) scanKeyword(s uint16) (ret bool) {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	var k uint16 // 0..32000
	p = 29987
	tex.mem[p].pHh().rh = 0
	k = tex.strStart[s]
	for k < tex.strStart[int32(s)+1] {
		tex.getXToken()
		if (tex.curCs == 0) && ((tex.curChr == uint16(tex.strPool[k])) || (int32(tex.curChr) == (int32(tex.strPool[k]) - 32))) {
			q = tex.getAvail()
			tex.mem[p].pHh().rh = q
			*tex.mem[q].pHh().pLh() = tex.curTok
			p = q
			k = uint16(int32(k) + 1)
		} else if (tex.curCmd != 10) || (p != 29987) {
			tex.backInput()
			if p != 29987 {
				tex.beginTokenList(tex.mem[29987].hh().rh, 3)
			}
			ret = false
			goto label10
		}
	}
	tex.flushList(tex.mem[29987].hh().rh)
	ret = true
label10:
	return ret
}

func (tex *Context) muError() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(662)
	tex.helpPtr = 1
	tex.helpLine[0] = 663
	tex.error1()
}

func (tex *Context) scanEightBitInt() {
	tex.scanInt()
	if (tex.curVal < 0) || (tex.curVal > 255) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(687)
		tex.helpPtr = 2
		tex.helpLine[1] = 688
		tex.helpLine[0] = 689
		tex.intError(tex.curVal)
		tex.curVal = 0
	}
}

func (tex *Context) scanCharNum() {
	tex.scanInt()
	if (tex.curVal < 0) || (tex.curVal > 255) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(690)
		tex.helpPtr = 2
		tex.helpLine[1] = 691
		tex.helpLine[0] = 689
		tex.intError(tex.curVal)
		tex.curVal = 0
	}
}

func (tex *Context) scanFourBitInt() {
	tex.scanInt()
	if (tex.curVal < 0) || (tex.curVal > 15) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(692)
		tex.helpPtr = 2
		tex.helpLine[1] = 693
		tex.helpLine[0] = 689
		tex.intError(tex.curVal)
		tex.curVal = 0
	}
}

func (tex *Context) scanFifteenBitInt() {
	tex.scanInt()
	if (tex.curVal < 0) || (tex.curVal > 32767) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(694)
		tex.helpPtr = 2
		tex.helpLine[1] = 695
		tex.helpLine[0] = 689
		tex.intError(tex.curVal)
		tex.curVal = 0
	}
}

func (tex *Context) scanTwentySevenBitInt() {
	tex.scanInt()
	if (tex.curVal < 0) || (tex.curVal > 134217727) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(696)
		tex.helpPtr = 2
		tex.helpLine[1] = 697
		tex.helpLine[0] = 689
		tex.intError(tex.curVal)
		tex.curVal = 0
	}
}

func (tex *Context) scanFontIdent() {
	var f byte   // 0..75
	var m uint16 // 0..65535
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	if tex.curCmd == 88 {
		f = byte(tex.eqtb[3934-1].hh().rh)
	} else if tex.curCmd == 87 {
		f = byte(tex.curChr)
	} else if tex.curCmd == 86 {
		m = tex.curChr
		tex.scanFourBitInt()
		f = byte(tex.eqtb[int32(m)+tex.curVal-1].hh().rh)
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(817)
		tex.helpPtr = 2
		tex.helpLine[1] = 818
		tex.helpLine[0] = 819
		tex.backError()
		f = 0
	}
	tex.curVal = int32(f)
}

func (tex *Context) findFontDimen(writing bool) {
	var f byte  // 0..75
	var n int32 // integer
	tex.scanInt()
	n = tex.curVal
	tex.scanFontIdent()
	f = byte(tex.curVal)
	if n <= 0 {
		tex.curVal = int32(tex.fmemPtr)
	} else {
		if writing && (n <= 4) && (n >= 2) && (tex.fontGlue[f] != 0) {
			tex.deleteGlueRef(tex.fontGlue[f])
			tex.fontGlue[f] = 0
		}
		if n > int32(tex.fontParams[f]) {
			if f < tex.fontPtr {
				tex.curVal = int32(tex.fmemPtr)
			} else {
				for {
					if tex.fmemPtr == fontMemSize {
						tex.overflow(824, fontMemSize)
					}
					*tex.fontInfo[tex.fmemPtr].pInt() = 0
					tex.fmemPtr = uint16(int32(tex.fmemPtr) + 1)
					tex.fontParams[f] = uint16(int32(tex.fontParams[f]) + 1)
					if n == int32(tex.fontParams[f]) {
						break
					}
				}
				tex.curVal = int32(tex.fmemPtr) - 1
			}
		} else {
			tex.curVal = n + tex.paramBase[f]
		}
	}
	if tex.curVal == int32(tex.fmemPtr) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(802)
		tex.printEsc(tex.hash[2624+int32(f)-514].rh)
		tex.print(820)
		tex.printInt(int32(tex.fontParams[f]))
		tex.print(821)
		tex.helpPtr = 2
		tex.helpLine[1] = 822
		tex.helpLine[0] = 823
		tex.error1()
	}
}

func (tex *Context) scanSomethingInternal(level byte, negative bool) {
	var m uint16 // 0..65535
	var p byte   // 0..40
	m = tex.curChr
	switch tex.curCmd {
	case 85:
		tex.scanCharNum()
		if m == 5007 {
			tex.curVal = int32(tex.eqtb[5007+tex.curVal-1].hh().rh) - 0
			tex.curValLevel = 0
		} else if m < 5007 {
			tex.curVal = int32(tex.eqtb[int32(m)+tex.curVal-1].hh().rh)
			tex.curValLevel = 0
		} else {
			tex.curVal = tex.eqtb[int32(m)+tex.curVal-1].int()
			tex.curValLevel = 0
		}
	case 71, 72, 86, 87, 88:
		if level != 5 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(664)
			tex.helpPtr = 3
			tex.helpLine[2] = 665
			tex.helpLine[1] = 666
			tex.helpLine[0] = 667
			tex.backError()
			tex.curVal = 0
			tex.curValLevel = 1
		} else if tex.curCmd <= 72 {
			if tex.curCmd < 72 {
				tex.scanEightBitInt()
				m = uint16(3422 + tex.curVal)
			}
			tex.curVal = int32(tex.eqtb[m-1].hh().rh)
			tex.curValLevel = 5
		} else {
			tex.backInput()
			tex.scanFontIdent()
			tex.curVal = 2624 + tex.curVal
			tex.curValLevel = 4
		}
	case 73:
		tex.curVal = tex.eqtb[m-1].int()
		tex.curValLevel = 0
	case 74:
		tex.curVal = tex.eqtb[m-1].int()
		tex.curValLevel = 1
	case 75:
		tex.curVal = int32(tex.eqtb[m-1].hh().rh)
		tex.curValLevel = 2
	case 76:
		tex.curVal = int32(tex.eqtb[m-1].hh().rh)
		tex.curValLevel = 3
	case 79:
		if iabs(int32(tex.curList.modeField)) != int32(m) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(680)
			tex.printCmdChr(79, m)
			tex.helpPtr = 4
			tex.helpLine[3] = 681
			tex.helpLine[2] = 682
			tex.helpLine[1] = 683
			tex.helpLine[0] = 684
			tex.error1()
			if level != 5 {
				tex.curVal = 0
				tex.curValLevel = 1
			} else {
				tex.curVal = 0
				tex.curValLevel = 0
			}
		} else if m == 1 {
			tex.curVal = tex.curList.auxField.int()
			tex.curValLevel = 1
		} else {
			tex.curVal = int32(tex.curList.auxField.hh().lh())
			tex.curValLevel = 0
		}
	case 80:
		if tex.curList.modeField == 0 {
			tex.curVal = 0
			tex.curValLevel = 0
		} else {
			tex.nest[tex.nestPtr] = tex.curList
			p = tex.nestPtr
			for iabs(int32(tex.nest[p].modeField)) != 1 {
				p = byte(int32(p) - 1)
			}
			tex.curVal = tex.nest[p].pgField
			tex.curValLevel = 0
		}
	case 82:
		if m == 0 {
			tex.curVal = tex.deadCycles
		} else {
			tex.curVal = tex.insertPenalties
		}
		tex.curValLevel = 0
	case 81:
		if (tex.pageContents == 0) && !tex.outputActive {
			if m == 0 {
				tex.curVal = 1073741823
			} else {
				tex.curVal = 0
			}
		} else {
			tex.curVal = tex.pageSoFar[m]
		}
		tex.curValLevel = 1
	case 84:
		if tex.eqtb[3412-1].hh().rh == 0 {
			tex.curVal = 0
		} else {
			tex.curVal = int32(tex.mem[tex.eqtb[3412-1].hh().rh].hh().lh())
		}
		tex.curValLevel = 0
	case 83:
		tex.scanEightBitInt()
		if tex.eqtb[3678+tex.curVal-1].hh().rh == 0 {
			tex.curVal = 0
		} else {
			tex.curVal = tex.mem[int32(tex.eqtb[3678+tex.curVal-1].hh().rh)+int32(m)].int()
		}
		tex.curValLevel = 1
	case 68, 69:
		tex.curVal = int32(tex.curChr)
		tex.curValLevel = 0
	case 77:
		tex.findFontDimen(false)
		*tex.fontInfo[tex.fmemPtr].pInt() = 0
		tex.curVal = tex.fontInfo[tex.curVal].int()
		tex.curValLevel = 1
	case 78:
		tex.scanFontIdent()
		if m == 0 {
			tex.curVal = tex.hyphenChar[tex.curVal]
			tex.curValLevel = 0
		} else {
			tex.curVal = tex.skewChar[tex.curVal]
			tex.curValLevel = 0
		}
	case 89:
		tex.scanEightBitInt()
		switch m {
		case 0:
			tex.curVal = tex.eqtb[5318+tex.curVal-1].int()
		case 1:
			tex.curVal = tex.eqtb[5851+tex.curVal-1].int()
		case 2:
			tex.curVal = int32(tex.eqtb[2900+tex.curVal-1].hh().rh)
		case 3:
			tex.curVal = int32(tex.eqtb[3156+tex.curVal-1].hh().rh)
		}
		tex.curValLevel = byte(m)
	case 70:
		if tex.curChr > 2 {
			if tex.curChr == 3 {
				tex.curVal = tex.line
			} else {
				tex.curVal = tex.lastBadness
			}
			tex.curValLevel = 0
		} else {
			if tex.curChr == 2 {
				tex.curVal = 0
			} else {
				tex.curVal = 0
			}
			tex.curValLevel = byte(tex.curChr)
			if !(tex.curList.tailField >= tex.hiMemMin) && (tex.curList.modeField != 0) {
				switch tex.curChr {
				case 0:
					if tex.mem[tex.curList.tailField].hh().b0() == 12 {
						tex.curVal = tex.mem[int32(tex.curList.tailField)+1].int()
					}
				case 1:
					if tex.mem[tex.curList.tailField].hh().b0() == 11 {
						tex.curVal = tex.mem[int32(tex.curList.tailField)+1].int()
					}
				case 2:
					if tex.mem[tex.curList.tailField].hh().b0() == 10 {
						tex.curVal = int32(tex.mem[int32(tex.curList.tailField)+1].hh().lh())
						if tex.mem[tex.curList.tailField].hh().b1() == 99 {
							tex.curValLevel = 3
						}
					}
				}
			} else if (tex.curList.modeField == 1) && (tex.curList.tailField == tex.curList.headField) {
				switch tex.curChr {
				case 0:
					tex.curVal = tex.lastPenalty
				case 1:
					tex.curVal = tex.lastKern
				case 2:
					if tex.lastGlue != 65535 {
						tex.curVal = int32(tex.lastGlue)
					}
				}
			}
		}
	default:
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(685)
		tex.printCmdChr(tex.curCmd, tex.curChr)
		tex.print(686)
		tex.printEsc(537)
		tex.helpPtr = 1
		tex.helpLine[0] = 684
		tex.error1()
		if level != 5 {
			tex.curVal = 0
			tex.curValLevel = 1
		} else {
			tex.curVal = 0
			tex.curValLevel = 0
		}
	}
	for tex.curValLevel > level {
		if tex.curValLevel == 2 {
			tex.curVal = tex.mem[tex.curVal+1].int()
		} else if tex.curValLevel == 3 {
			tex.muError()
		}
		tex.curValLevel = byte(int32(tex.curValLevel) - 1)
	}
	if negative {
		if tex.curValLevel >= 2 {
			tex.curVal = int32(tex.newSpec(uint16(tex.curVal)))
			*tex.mem[tex.curVal+1].pInt() = -tex.mem[tex.curVal+1].int()
			*tex.mem[tex.curVal+2].pInt() = -tex.mem[tex.curVal+2].int()
			*tex.mem[tex.curVal+3].pInt() = -tex.mem[tex.curVal+3].int()
		} else {
			tex.curVal = -tex.curVal
		}
	} else if (tex.curValLevel >= 2) && (tex.curValLevel <= 3) {
		tex.mem[tex.curVal].pHh().rh = uint16(int32(tex.mem[tex.curVal].hh().rh) + 1)
	}
}

func (tex *Context) scanInt() {
	var negative bool // boolean
	var m int32       // integer
	var d byte        // 0..63
	var vacuous bool  // boolean
	var OKSoFar bool  // boolean
	tex.radix = 0
	OKSoFar = true
	negative = false
	for {
		for {
			tex.getXToken()
			if tex.curCmd != 10 {
				break
			}
		}
		if tex.curTok == 3117 {
			negative = !negative
			tex.curTok = 3115
		}
		if tex.curTok != 3115 {
			break
		}
	}
	if tex.curTok == 3168 {
		tex.getToken()
		if tex.curTok < 4095 {
			tex.curVal = int32(tex.curChr)
			if tex.curCmd <= 2 {
				if tex.curCmd == 2 {
					tex.alignState = tex.alignState + 1
				} else {
					tex.alignState = tex.alignState - 1
				}
			}
		} else if tex.curTok < 4352 {
			tex.curVal = int32(tex.curTok) - 4096
		} else {
			tex.curVal = int32(tex.curTok) - 4352
		}
		if tex.curVal > 255 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(698)
			tex.helpPtr = 2
			tex.helpLine[1] = 699
			tex.helpLine[0] = 700
			tex.curVal = 48
			tex.backError()
		} else {
			tex.getXToken()
			if tex.curCmd != 10 {
				tex.backInput()
			}
		}
	} else if (tex.curCmd >= 68) && (tex.curCmd <= 89) {
		tex.scanSomethingInternal(0, false)
	} else {
		tex.radix = 10
		m = 214748364
		if tex.curTok == 3111 {
			tex.radix = 8
			m = 268435456
			tex.getXToken()
		} else if tex.curTok == 3106 {
			tex.radix = 16
			m = 134217728
			tex.getXToken()
		}
		vacuous = true
		tex.curVal = 0
		for true {
			if (int32(tex.curTok) < (3120 + int32(tex.radix))) && (tex.curTok >= 3120) && (tex.curTok <= 3129) {
				d = byte(int32(tex.curTok) - 3120)
			} else if tex.radix == 16 {
				if (tex.curTok <= 2886) && (tex.curTok >= 2881) {
					d = byte(int32(tex.curTok) - 2871)
				} else if (tex.curTok <= 3142) && (tex.curTok >= 3137) {
					d = byte(int32(tex.curTok) - 3127)
				} else {
					goto label30
				}
			} else {
				goto label30
			}
			vacuous = false
			if (tex.curVal >= m) && ((tex.curVal > m) || (d > 7) || (tex.radix != 10)) {
				if OKSoFar {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(701)
					tex.helpPtr = 2
					tex.helpLine[1] = 702
					tex.helpLine[0] = 703
					tex.error1()
					tex.curVal = 2147483647
					OKSoFar = false
				}
			} else {
				tex.curVal = (tex.curVal * int32(tex.radix)) + int32(d)
			}
			tex.getXToken()
		}
	label30:
		if vacuous {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(664)
			tex.helpPtr = 3
			tex.helpLine[2] = 665
			tex.helpLine[1] = 666
			tex.helpLine[0] = 667
			tex.backError()
		} else if tex.curCmd != 10 {
			tex.backInput()
		}
	}
	if negative {
		tex.curVal = -tex.curVal
	}
}

func (tex *Context) scanDimen(mu, inf, shortcut bool) {
	var negative bool     // boolean
	var f int32           // integer
	var num, denom uint32 // 1..65536
	var k, kk byte        // 0..63
	var p, q uint16       // 0..65535
	var v int32           // integer
	var saveCurVal int32  // integer
	f = 0
	tex.arithError = false
	tex.curOrder = 0
	negative = false
	if !shortcut {
		negative = false
		for {
			for {
				tex.getXToken()
				if tex.curCmd != 10 {
					break
				}
			}
			if tex.curTok == 3117 {
				negative = !negative
				tex.curTok = 3115
			}
			if tex.curTok != 3115 {
				break
			}
		}
		if (tex.curCmd >= 68) && (tex.curCmd <= 89) {
			if mu {
				tex.scanSomethingInternal(3, false)
				if tex.curValLevel >= 2 {
					v = tex.mem[tex.curVal+1].int()
					tex.deleteGlueRef(uint16(tex.curVal))
					tex.curVal = v
				}
				if tex.curValLevel == 3 {
					goto label89
				}
				if tex.curValLevel != 0 {
					tex.muError()
				}
			} else {
				tex.scanSomethingInternal(1, false)
				if tex.curValLevel == 1 {
					goto label89
				}
			}
		} else {
			tex.backInput()
			if tex.curTok == 3116 {
				tex.curTok = 3118
			}
			if tex.curTok != 3118 {
				tex.scanInt()
			} else {
				tex.radix = 10
				tex.curVal = 0
			}
			if tex.curTok == 3116 {
				tex.curTok = 3118
			}
			if (tex.radix == 10) && (tex.curTok == 3118) {
				k = 0
				p = 0
				tex.getToken()
				for true {
					tex.getXToken()
					if (tex.curTok > 3129) || (tex.curTok < 3120) {
						goto label31
					}
					if k < 17 {
						q = tex.getAvail()
						tex.mem[q].pHh().rh = p
						*tex.mem[q].pHh().pLh() = uint16(int32(tex.curTok) - 3120)
						p = q
						k = byte(int32(k) + 1)
					}
				}
			label31:
				for _i := int64(k); _i >= int64(1); _i-- {
					kk = byte(_i)
					tex.dig[int32(kk)-1] = byte(tex.mem[p].hh().lh())
					q = p
					p = tex.mem[p].hh().rh
					tex.mem[q].pHh().rh = tex.avail
					tex.avail = q
				}
				f = tex.roundDecimals(k)
				if tex.curCmd != 10 {
					tex.backInput()
				}
			}
		}
	}
	if tex.curVal < 0 {
		negative = !negative
		tex.curVal = -tex.curVal
	}
	if inf {
		if tex.scanKeyword(311) {
			tex.curOrder = 1
			for tex.scanKeyword(108) {
				if tex.curOrder == 3 {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(705)
					tex.print(706)
					tex.helpPtr = 1
					tex.helpLine[0] = 707
					tex.error1()
				} else {
					tex.curOrder = byte(int32(tex.curOrder) + 1)
				}
			}
			goto label88
		}
	}
	saveCurVal = tex.curVal
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	if (tex.curCmd < 68) || (tex.curCmd > 89) {
		tex.backInput()
	} else {
		if mu {
			tex.scanSomethingInternal(3, false)
			if tex.curValLevel >= 2 {
				v = tex.mem[tex.curVal+1].int()
				tex.deleteGlueRef(uint16(tex.curVal))
				tex.curVal = v
			}
			if tex.curValLevel != 3 {
				tex.muError()
			}
		} else {
			tex.scanSomethingInternal(1, false)
		}
		v = tex.curVal
		goto label40
	}
	if mu {
		goto label45
	}
	if tex.scanKeyword(708) {
		v = tex.fontInfo[6+tex.paramBase[tex.eqtb[3934-1].hh().rh]].int()
	} else if tex.scanKeyword(709) {
		v = tex.fontInfo[5+tex.paramBase[tex.eqtb[3934-1].hh().rh]].int()
	} else {
		goto label45
	}
	tex.getXToken()
	if tex.curCmd != 10 {
		tex.backInput()
	}
label40:
	tex.curVal = tex.multAndAdd(saveCurVal, v, tex.xnOverD(v, f, 65536), 1073741823)
	goto label89
label45:
	if mu {
		if tex.scanKeyword(337) {
			goto label88
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(705)
			tex.print(710)
			tex.helpPtr = 4
			tex.helpLine[3] = 711
			tex.helpLine[2] = 712
			tex.helpLine[1] = 713
			tex.helpLine[0] = 714
			tex.error1()
			goto label88
		}
	}
	if tex.scanKeyword(704) {
		tex.prepareMag()
		if tex.eqtb[5280-1].int() != 1000 {
			tex.curVal = tex.xnOverD(tex.curVal, 1000, tex.eqtb[5280-1].int())
			f = (((1000 * f) + (65536 * tex.remainder)) / tex.eqtb[5280-1].int())
			tex.curVal = tex.curVal + (f / 65536)
			f = (f % 65536)
		}
	}
	if tex.scanKeyword(397) {
		goto label88
	}
	if tex.scanKeyword(715) {
		num = 7227
		denom = 100
	} else if tex.scanKeyword(716) {
		num = 12
		denom = 1
	} else if tex.scanKeyword(717) {
		num = 7227
		denom = 254
	} else if tex.scanKeyword(718) {
		num = 7227
		denom = 2540
	} else if tex.scanKeyword(719) {
		num = 7227
		denom = 7200
	} else if tex.scanKeyword(720) {
		num = 1238
		denom = 1157
	} else if tex.scanKeyword(721) {
		num = 14856
		denom = 1157
	} else if tex.scanKeyword(722) {
		goto label30
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(705)
		tex.print(723)
		tex.helpPtr = 6
		tex.helpLine[5] = 724
		tex.helpLine[4] = 725
		tex.helpLine[3] = 726
		tex.helpLine[2] = 712
		tex.helpLine[1] = 713
		tex.helpLine[0] = 714
		tex.error1()
		goto label32
	}
	tex.curVal = tex.xnOverD(tex.curVal, int32(num), int32(denom))
	f = (((int32(num) * f) + (65536 * tex.remainder)) / int32(denom))
	tex.curVal = tex.curVal + (f / 65536)
	f = (f % 65536)
label32:
label88:
	if tex.curVal >= 16384 {
		tex.arithError = true
	} else {
		tex.curVal = (tex.curVal * 65536) + f
	}
label30:
	tex.getXToken()
	if tex.curCmd != 10 {
		tex.backInput()
	}
label89:
	if tex.arithError || (iabs(tex.curVal) >= 1073741824) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(727)
		tex.helpPtr = 2
		tex.helpLine[1] = 728
		tex.helpLine[0] = 729
		tex.error1()
		tex.curVal = 1073741823
		tex.arithError = false
	}
	if negative {
		tex.curVal = -tex.curVal
	}
}

func (tex *Context) scanGlue(level byte) {
	var negative bool // boolean
	var q uint16      // 0..65535
	var mu bool       // boolean
	mu = (level == 3)
	negative = false
	for {
		for {
			tex.getXToken()
			if tex.curCmd != 10 {
				break
			}
		}
		if tex.curTok == 3117 {
			negative = !negative
			tex.curTok = 3115
		}
		if tex.curTok != 3115 {
			break
		}
	}
	if (tex.curCmd >= 68) && (tex.curCmd <= 89) {
		tex.scanSomethingInternal(level, negative)
		if tex.curValLevel >= 2 {
			if tex.curValLevel != level {
				tex.muError()
			}
			goto label10
		}
		if tex.curValLevel == 0 {
			tex.scanDimen(mu, false, true)
		} else if level == 3 {
			tex.muError()
		}
	} else {
		tex.backInput()
		tex.scanDimen(mu, false, false)
		if negative {
			tex.curVal = -tex.curVal
		}
	}
	q = tex.newSpec(0)
	*tex.mem[int32(q)+1].pInt() = tex.curVal
	if tex.scanKeyword(730) {
		tex.scanDimen(mu, true, false)
		*tex.mem[int32(q)+2].pInt() = tex.curVal
		*tex.mem[q].pHh().pB0() = tex.curOrder
	}
	if tex.scanKeyword(731) {
		tex.scanDimen(mu, true, false)
		*tex.mem[int32(q)+3].pInt() = tex.curVal
		*tex.mem[q].pHh().pB1() = tex.curOrder
	}
	tex.curVal = int32(q)
label10:
}

func (tex *Context) scanRuleSpec() (ret uint16) {
	var q uint16 // 0..65535
	q = tex.newRule()
	if tex.curCmd == 35 {
		*tex.mem[int32(q)+1].pInt() = 26214
	} else {
		*tex.mem[int32(q)+3].pInt() = 26214
		*tex.mem[int32(q)+2].pInt() = 0
	}
label21:
	if tex.scanKeyword(732) {
		tex.scanDimen(false, false, false)
		*tex.mem[int32(q)+1].pInt() = tex.curVal
		goto label21
	}
	if tex.scanKeyword(733) {
		tex.scanDimen(false, false, false)
		*tex.mem[int32(q)+3].pInt() = tex.curVal
		goto label21
	}
	if tex.scanKeyword(734) {
		tex.scanDimen(false, false, false)
		*tex.mem[int32(q)+2].pInt() = tex.curVal
		goto label21
	}
	ret = q
	return ret
}

func (tex *Context) strToks(b uint16) (ret uint16) {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	var t uint16 // 0..65535
	var k uint16 // 0..32000
	if int32(tex.poolPtr)+1 > poolSize {
		tex.overflow(257, poolSize-int32(tex.initPoolPtr))
	}
	p = 29997
	tex.mem[p].pHh().rh = 0
	k = b
	for k < tex.poolPtr {
		t = uint16(tex.strPool[k])
		if t == 32 {
			t = 2592
		} else {
			t = uint16(3072 + int32(t))
		}
		q = tex.avail
		if q == 0 {
			q = tex.getAvail()
		} else {
			tex.avail = tex.mem[q].hh().rh
			tex.mem[q].pHh().rh = 0
		}
		tex.mem[p].pHh().rh = q
		*tex.mem[q].pHh().pLh() = t
		p = q
		k = uint16(int32(k) + 1)
	}
	tex.poolPtr = b
	ret = p
	return ret
}

func (tex *Context) theToks() (ret uint16) {
	var oldSetting byte // 0..21
	var p, q, r uint16  // 0..65535
	var b uint16        // 0..32000
	tex.getXToken()
	tex.scanSomethingInternal(5, false)
	if tex.curValLevel >= 4 {
		p = 29997
		tex.mem[p].pHh().rh = 0
		if tex.curValLevel == 4 {
			q = tex.getAvail()
			tex.mem[p].pHh().rh = q
			*tex.mem[q].pHh().pLh() = uint16(4095 + tex.curVal)
			p = q
		} else if tex.curVal != 0 {
			r = tex.mem[tex.curVal].hh().rh
			for r != 0 {
				q = tex.avail
				if q == 0 {
					q = tex.getAvail()
				} else {
					tex.avail = tex.mem[q].hh().rh
					tex.mem[q].pHh().rh = 0
				}
				tex.mem[p].pHh().rh = q
				*tex.mem[q].pHh().pLh() = tex.mem[r].hh().lh()
				p = q
				r = tex.mem[r].hh().rh
			}
		}
		ret = p
	} else {
		oldSetting = tex.selector
		tex.selector = 21
		b = tex.poolPtr
		switch tex.curValLevel {
		case 0:
			tex.printInt(tex.curVal)
		case 1:
			tex.printScaled(tex.curVal)
			tex.print(397)
		case 2:
			tex.printSpec(tex.curVal, 397)
			tex.deleteGlueRef(uint16(tex.curVal))
		case 3:
			tex.printSpec(tex.curVal, 337)
			tex.deleteGlueRef(uint16(tex.curVal))
		}
		tex.selector = oldSetting
		ret = tex.strToks(b)
	}
	return ret
}

func (tex *Context) insTheToks() {
	tex.mem[29988].pHh().rh = tex.theToks()
	tex.beginTokenList(tex.mem[29997].hh().rh, 4)
}

func (tex *Context) convToks() {
	var oldSetting byte        // 0..21
	var c byte                 // 0..5
	var saveScannerStatus byte // 0..63
	var b uint16               // 0..32000
	c = byte(tex.curChr)
	switch c {
	case 0, 1:
		tex.scanInt()
	case 2, 3:
		saveScannerStatus = tex.scannerStatus
		tex.scannerStatus = 0
		tex.getToken()
		tex.scannerStatus = saveScannerStatus
	case 4:
		tex.scanFontIdent()
	case 5:
		if tex.jobName == 0 {
			tex.openLogFile()
		}
	}
	oldSetting = tex.selector
	tex.selector = 21
	b = tex.poolPtr
	switch c {
	case 0:
		tex.printInt(tex.curVal)
	case 1:
		tex.printRomanInt(tex.curVal)
	case 2:
		if tex.curCs != 0 {
			tex.sprintCs(tex.curCs)
		} else {
			tex.printChar(byte(tex.curChr))
		}
	case 3:
		tex.printMeaning()
	case 4:
		tex.print(int32(tex.fontName[tex.curVal]))
		if tex.fontSize[tex.curVal] != tex.fontDsize[tex.curVal] {
			tex.print(741)
			tex.printScaled(tex.fontSize[tex.curVal])
			tex.print(397)
		}
	case 5:
		tex.print(int32(tex.jobName))
	}
	tex.selector = oldSetting
	tex.mem[29988].pHh().rh = tex.strToks(b)
	tex.beginTokenList(tex.mem[29997].hh().rh, 4)
}

func (tex *Context) scanToks(macroDef, xpand bool) (ret uint16) {
	var t uint16         // 0..65535
	var s uint16         // 0..65535
	var p uint16         // 0..65535
	var q uint16         // 0..65535
	var unbalance uint16 // 0..65535
	var hashBrace uint16 // 0..65535
	if macroDef {
		tex.scannerStatus = 2
	} else {
		tex.scannerStatus = 5
	}
	tex.warningIndex = tex.curCs
	tex.defRef = tex.getAvail()
	*tex.mem[tex.defRef].pHh().pLh() = 0
	p = tex.defRef
	hashBrace = 0
	t = 3120
	if macroDef {
		for true {
		label22:
			tex.getToken()
			if tex.curTok < 768 {
				goto label31
			}
			if tex.curCmd == 6 {
				s = uint16(3328 + int32(tex.curChr))
				tex.getToken()
				if tex.curTok < 512 {
					hashBrace = tex.curTok
					q = tex.getAvail()
					tex.mem[p].pHh().rh = q
					*tex.mem[q].pHh().pLh() = tex.curTok
					p = q
					q = tex.getAvail()
					tex.mem[p].pHh().rh = q
					*tex.mem[q].pHh().pLh() = 3584
					p = q
					goto label30
				}
				if t == 3129 {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(744)
					tex.helpPtr = 2
					tex.helpLine[1] = 745
					tex.helpLine[0] = 746
					tex.error1()
					goto label22
				} else {
					t = uint16(int32(t) + 1)
					if tex.curTok != t {
						if tex.interaction == 3 {
						}
						tex.printNl(262)
						tex.print(747)
						tex.helpPtr = 2
						tex.helpLine[1] = 748
						tex.helpLine[0] = 749
						tex.backError()
					}
					tex.curTok = s
				}
			}
			q = tex.getAvail()
			tex.mem[p].pHh().rh = q
			*tex.mem[q].pHh().pLh() = tex.curTok
			p = q
		}
	label31:
		q = tex.getAvail()
		tex.mem[p].pHh().rh = q
		*tex.mem[q].pHh().pLh() = 3584
		p = q
		if tex.curCmd == 2 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(657)
			tex.alignState = tex.alignState + 1
			tex.helpPtr = 2
			tex.helpLine[1] = 742
			tex.helpLine[0] = 743
			tex.error1()
			goto label40
		}
	label30:
	} else {
		tex.scanLeftBrace()
	}
	unbalance = 1
	for true {
		if xpand {
			for true {
				tex.getNext()
				if tex.curCmd <= 100 {
					goto label32
				}
				if tex.curCmd != 109 {
					tex.expand()
				} else {
					q = tex.theToks()
					if tex.mem[29997].hh().rh != 0 {
						tex.mem[p].pHh().rh = tex.mem[29997].hh().rh
						p = q
					}
				}
			}
		label32:
			tex.xToken()
		} else {
			tex.getToken()
		}
		if tex.curTok < 768 {
			if tex.curCmd < 2 {
				unbalance = uint16(int32(unbalance) + 1)
			} else {
				unbalance = uint16(int32(unbalance) - 1)
				if unbalance == 0 {
					goto label40
				}
			}
		} else if tex.curCmd == 6 {
			if macroDef {
				s = tex.curTok
				if xpand {
					tex.getXToken()
				} else {
					tex.getToken()
				}
				if tex.curCmd != 6 {
					if (tex.curTok <= 3120) || (tex.curTok > t) {
						if tex.interaction == 3 {
						}
						tex.printNl(262)
						tex.print(750)
						tex.sprintCs(tex.warningIndex)
						tex.helpPtr = 3
						tex.helpLine[2] = 751
						tex.helpLine[1] = 752
						tex.helpLine[0] = 753
						tex.backError()
						tex.curTok = s
					} else {
						tex.curTok = uint16(1232 + int32(tex.curChr))
					}
				}
			}
		}
		q = tex.getAvail()
		tex.mem[p].pHh().rh = q
		*tex.mem[q].pHh().pLh() = tex.curTok
		p = q
	}
label40:
	tex.scannerStatus = 0
	if hashBrace != 0 {
		q = tex.getAvail()
		tex.mem[p].pHh().rh = q
		*tex.mem[q].pHh().pLh() = hashBrace
		p = q
	}
	ret = p
	return ret
}

func (tex *Context) readToks(n int32, r uint16) {
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	var s int32  // integer
	var m byte   // 0..63
	tex.scannerStatus = 2
	tex.warningIndex = r
	tex.defRef = tex.getAvail()
	*tex.mem[tex.defRef].pHh().pLh() = 0
	p = tex.defRef
	q = tex.getAvail()
	tex.mem[p].pHh().rh = q
	*tex.mem[q].pHh().pLh() = 3584
	p = q
	if (n < 0) || (n > 15) {
		m = 16
	} else {
		m = byte(n)
	}
	s = tex.alignState
	tex.alignState = 1000000
	for {
		tex.beginFileReading()
		tex.curInput.nameField = uint16(int32(m) + 1)
		if tex.readOpen[m] == 2 {
			if tex.interaction > 1 {
				if n < 0 {
					tex.print(338)
					tex.termInput()
				} else {
					tex.printLn()
					tex.sprintCs(r)
					tex.print(61)
					tex.termInput()
					n = -1
				}
			} else {
				tex.fatalError(754)
			}
		} else if tex.readOpen[m] == 1 {
			if tex.inputLn(&tex.readFile[m], false) {
				tex.readOpen[m] = 0
			} else {
				tex.aClose(&tex.readFile[m])
				tex.readOpen[m] = 2
			}
		} else {
			if !tex.inputLn(&tex.readFile[m], true) {
				tex.aClose(&tex.readFile[m])
				tex.readOpen[m] = 2
				if tex.alignState != 1000000 {
					tex.runaway()
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(755)
					tex.printEsc(534)
					tex.helpPtr = 1
					tex.helpLine[0] = 756
					tex.alignState = 1000000
					tex.curInput.limitField = 0
					tex.error1()
				}
			}
		}
		tex.curInput.limitField = tex.last
		if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
			tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - 1)
		} else {
			tex.buffer[tex.curInput.limitField] = byte(tex.eqtb[5311-1].int())
		}
		tex.first = uint16(int32(tex.curInput.limitField) + 1)
		tex.curInput.locField = tex.curInput.startField
		tex.curInput.stateField = 33
		for true {
			tex.getToken()
			if tex.curTok == 0 {
				goto label30
			}
			if tex.alignState < 1000000 {
				for {
					tex.getToken()
					if tex.curTok == 0 {
						break
					}
				}
				tex.alignState = 1000000
				goto label30
			}
			q = tex.getAvail()
			tex.mem[p].pHh().rh = q
			*tex.mem[q].pHh().pLh() = tex.curTok
			p = q
		}
	label30:
		tex.endFileReading()
		if tex.alignState == 1000000 {
			break
		}
	}
	tex.curVal = int32(tex.defRef)
	tex.scannerStatus = 0
	tex.alignState = s
}

func (tex *Context) passText() {
	var l int32                // integer
	var saveScannerStatus byte // 0..63
	saveScannerStatus = tex.scannerStatus
	tex.scannerStatus = 1
	l = 0
	tex.skipLine = tex.line
	for true {
		tex.getNext()
		if tex.curCmd == 106 {
			if l == 0 {
				goto label30
			}
			if tex.curChr == 2 {
				l = l - 1
			}
		} else if tex.curCmd == 105 {
			l = l + 1
		}
	}
label30:
	tex.scannerStatus = saveScannerStatus
}

func (tex *Context) changeIfLimit(l byte, p uint16) {
	var q uint16 // 0..65535
	if p == tex.condPtr {
		tex.ifLimit = l
	} else {
		q = tex.condPtr
		for true {
			if q == 0 {
				tex.confusion(757)
			}
			if tex.mem[q].hh().rh == p {
				*tex.mem[q].pHh().pB0() = l
				goto label10
			}
			q = tex.mem[q].hh().rh
		}
	}
label10:
}

func (tex *Context) conditional() {
	var b bool                 // boolean
	var r byte                 // 60..62
	var m, n int32             // integer
	var p, q uint16            // 0..65535
	var saveScannerStatus byte // 0..63
	var saveCondPtr uint16     // 0..65535
	var thisIf byte            // 0..63
	p = tex.getNode(2)
	tex.mem[p].pHh().rh = tex.condPtr
	*tex.mem[p].pHh().pB0() = tex.ifLimit
	*tex.mem[p].pHh().pB1() = tex.curIf
	*tex.mem[int32(p)+1].pInt() = tex.ifLine
	tex.condPtr = p
	tex.curIf = byte(tex.curChr)
	tex.ifLimit = 1
	tex.ifLine = tex.line
	saveCondPtr = tex.condPtr
	thisIf = byte(tex.curChr)
	switch thisIf {
	case 0, 1:
		tex.getXToken()
		if tex.curCmd == 0 {
			if tex.curChr == 257 {
				tex.curCmd = 13
				tex.curChr = uint16(int32(tex.curTok) - 4096)
			}
		}
		if (tex.curCmd > 13) || (tex.curChr > 255) {
			m = 0
			n = 256
		} else {
			m = int32(tex.curCmd)
			n = int32(tex.curChr)
		}
		tex.getXToken()
		if tex.curCmd == 0 {
			if tex.curChr == 257 {
				tex.curCmd = 13
				tex.curChr = uint16(int32(tex.curTok) - 4096)
			}
		}
		if (tex.curCmd > 13) || (tex.curChr > 255) {
			tex.curCmd = 0
			tex.curChr = 256
		}
		if thisIf == 0 {
			b = (n == int32(tex.curChr))
		} else {
			b = (m == int32(tex.curCmd))
		}
	case 2, 3:
		if thisIf == 2 {
			tex.scanInt()
		} else {
			tex.scanDimen(false, false, false)
		}
		n = tex.curVal
		for {
			tex.getXToken()
			if tex.curCmd != 10 {
				break
			}
		}
		if (tex.curTok >= 3132) && (tex.curTok <= 3134) {
			r = byte(int32(tex.curTok) - 3072)
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(781)
			tex.printCmdChr(105, uint16(thisIf))
			tex.helpPtr = 1
			tex.helpLine[0] = 782
			tex.backError()
			r = 61
		}
		if thisIf == 2 {
			tex.scanInt()
		} else {
			tex.scanDimen(false, false, false)
		}
		switch r {
		case 60:
			b = (n < tex.curVal)
		case 61:
			b = (n == tex.curVal)
		case 62:
			b = (n > tex.curVal)
		}
	case 4:
		tex.scanInt()
		b = odd(tex.curVal)
	case 5:
		b = (iabs(int32(tex.curList.modeField)) == 1)
	case 6:
		b = (iabs(int32(tex.curList.modeField)) == 102)
	case 7:
		b = (iabs(int32(tex.curList.modeField)) == 203)
	case 8:
		b = (tex.curList.modeField < 0)
	case 9, 10, 11:
		tex.scanEightBitInt()
		p = tex.eqtb[3678+tex.curVal-1].hh().rh
		if thisIf == 9 {
			b = (p == 0)
		} else if p == 0 {
			b = false
		} else if thisIf == 10 {
			b = (tex.mem[p].hh().b0() == 0)
		} else {
			b = (tex.mem[p].hh().b0() == 1)
		}
	case 12:
		saveScannerStatus = tex.scannerStatus
		tex.scannerStatus = 0
		tex.getNext()
		n = int32(tex.curCs)
		p = uint16(tex.curCmd)
		q = tex.curChr
		tex.getNext()
		if uint16(tex.curCmd) != p {
			b = false
		} else if tex.curCmd < 111 {
			b = (tex.curChr == q)
		} else {
			p = tex.mem[tex.curChr].hh().rh
			q = tex.mem[tex.eqtb[n-1].hh().rh].hh().rh
			if p == q {
				b = true
			} else {
				for (p != 0) && (q != 0) {
					if tex.mem[p].hh().lh() != tex.mem[q].hh().lh() {
						p = 0
					} else {
						p = tex.mem[p].hh().rh
						q = tex.mem[q].hh().rh
					}
				}
				b = ((p == 0) && (q == 0))
			}
		}
		tex.scannerStatus = saveScannerStatus
	case 13:
		tex.scanFourBitInt()
		b = (tex.readOpen[tex.curVal] == 2)
	case 14:
		b = true
	case 15:
		b = false
	case 16:
		tex.scanInt()
		n = tex.curVal
		if tex.eqtb[5299-1].int() > 1 {
			tex.beginDiagnostic()
			tex.print(783)
			tex.printInt(n)
			tex.printChar(125)
			tex.endDiagnostic(false)
		}
		for n != 0 {
			tex.passText()
			if tex.condPtr == saveCondPtr {
				if tex.curChr == 4 {
					n = n - 1
				} else {
					goto label50
				}
			} else if tex.curChr == 2 {
				p = tex.condPtr
				tex.ifLine = tex.mem[int32(p)+1].int()
				tex.curIf = tex.mem[p].hh().b1()
				tex.ifLimit = tex.mem[p].hh().b0()
				tex.condPtr = tex.mem[p].hh().rh
				tex.freeNode(p, 2)
			}
		}
		tex.changeIfLimit(4, saveCondPtr)
		goto label10
	}
	if tex.eqtb[5299-1].int() > 1 {
		tex.beginDiagnostic()
		if b {
			tex.print(779)
		} else {
			tex.print(780)
		}
		tex.endDiagnostic(false)
	}
	if b {
		tex.changeIfLimit(3, saveCondPtr)
		goto label10
	}
	for true {
		tex.passText()
		if tex.condPtr == saveCondPtr {
			if tex.curChr != 4 {
				goto label50
			}
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(777)
			tex.printEsc(775)
			tex.helpPtr = 1
			tex.helpLine[0] = 778
			tex.error1()
		} else if tex.curChr == 2 {
			p = tex.condPtr
			tex.ifLine = tex.mem[int32(p)+1].int()
			tex.curIf = tex.mem[p].hh().b1()
			tex.ifLimit = tex.mem[p].hh().b0()
			tex.condPtr = tex.mem[p].hh().rh
			tex.freeNode(p, 2)
		}
	}
label50:
	if tex.curChr == 2 {
		p = tex.condPtr
		tex.ifLine = tex.mem[int32(p)+1].int()
		tex.curIf = tex.mem[p].hh().b1()
		tex.ifLimit = tex.mem[p].hh().b0()
		tex.condPtr = tex.mem[p].hh().rh
		tex.freeNode(p, 2)
	} else {
		tex.ifLimit = 2
	}
label10:
}

func (tex *Context) beginName() {
	tex.areaDelimiter = 0
	tex.extDelimiter = 0
}

func (tex *Context) moreName(c byte) (ret bool) {
	if c == 32 {
		ret = false
	} else {
		if int32(tex.poolPtr)+1 > poolSize {
			tex.overflow(257, poolSize-int32(tex.initPoolPtr))
		}
		tex.strPool[tex.poolPtr] = c
		tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
		if (c == 62) || (c == 58) {
			tex.areaDelimiter = uint16((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])))
			tex.extDelimiter = 0
		} else if (c == 46) && (tex.extDelimiter == 0) {
			tex.extDelimiter = uint16((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])))
		}
		ret = true
	}
	return ret
}

func (tex *Context) endName() {
	if int32(tex.strPtr)+3 > maxStrings {
		tex.overflow(258, maxStrings-int32(tex.initStrPtr))
	}
	if tex.areaDelimiter == 0 {
		tex.curArea = 338
	} else {
		tex.curArea = tex.strPtr
		tex.strStart[int32(tex.strPtr)+1] = uint16(int32(tex.strStart[tex.strPtr]) + int32(tex.areaDelimiter))
		tex.strPtr = uint16(int32(tex.strPtr) + 1)
	}
	if tex.extDelimiter == 0 {
		tex.curExt = 338
		tex.curName = tex.makeString()
	} else {
		tex.curName = tex.strPtr
		tex.strStart[int32(tex.strPtr)+1] = uint16(int32(tex.strStart[tex.strPtr]) + int32(tex.extDelimiter) - int32(tex.areaDelimiter) - 1)
		tex.strPtr = uint16(int32(tex.strPtr) + 1)
		tex.curExt = tex.makeString()
	}
}

func (tex *Context) packFileName(n, a, e uint16) {
	var k int32  // integer
	var c byte   // 0..255
	var j uint16 // 0..32000
	k = 0
	for _i := int64(tex.strStart[a]); _i <= int64(int32(tex.strStart[int32(a)+1])-1); _i++ {
		j = uint16(_i)
		c = tex.strPool[j]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	for _i := int64(tex.strStart[n]); _i <= int64(int32(tex.strStart[int32(n)+1])-1); _i++ {
		j = uint16(_i)
		c = tex.strPool[j]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	for _i := int64(tex.strStart[e]); _i <= int64(int32(tex.strStart[int32(e)+1])-1); _i++ {
		j = uint16(_i)
		c = tex.strPool[j]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	if k <= fileNameSize {
		tex.nameLength = byte(k)
	} else {
		tex.nameLength = fileNameSize
	}
	for _i := int64(int32(tex.nameLength) + 1); _i <= int64(fileNameSize); _i++ {
		k = int32(_i)
		tex.nameOfFile[k-1] = ' '
	}
}

func (tex *Context) packBufferedName(n byte, a, b int32) {
	var k int32 // integer
	var c byte  // 0..255
	var j int32 // integer
	if int32(n)+b-a+5 > fileNameSize {
		b = a + fileNameSize - int32(n) - 5
	}
	k = 0
	for _i := int64(1); _i <= int64(n); _i++ {
		j = int32(_i)
		c = tex.xord[tex.TEXFormatDefault[j-1]]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	for _i := int64(a); _i <= int64(b); _i++ {
		j = int32(_i)
		c = tex.buffer[j]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	for _i := int64(17); _i <= int64(20); _i++ {
		j = int32(_i)
		c = tex.xord[tex.TEXFormatDefault[j-1]]
		k = k + 1
		if k <= fileNameSize {
			tex.nameOfFile[k-1] = tex.xchr[c]
		}
	}
	if k <= fileNameSize {
		tex.nameLength = byte(k)
	} else {
		tex.nameLength = fileNameSize
	}
	for _i := int64(int32(tex.nameLength) + 1); _i <= int64(fileNameSize); _i++ {
		k = int32(_i)
		tex.nameOfFile[k-1] = ' '
	}
}

func (tex *Context) makeNameString() (ret uint16) {
	var k byte // 1..40
	if ((int32(tex.poolPtr) + int32(tex.nameLength)) > poolSize) || (tex.strPtr == maxStrings) || ((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])) > 0) {
		ret = 63
	} else {
		for _i := int64(1); _i <= int64(tex.nameLength); _i++ {
			k = byte(_i)
			tex.strPool[tex.poolPtr] = tex.xord[tex.nameOfFile[k-1]]
			tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
		}
		ret = tex.makeString()
	}
	return ret
}

func (tex *Context) aMakeNameString(f *pasFile) (ret uint16) {
	ret = tex.makeNameString()
	return ret
}

func (tex *Context) bMakeNameString(f *pasFile) (ret uint16) {
	ret = tex.makeNameString()
	return ret
}

func (tex *Context) wMakeNameString(f *pasFile) (ret uint16) {
	ret = tex.makeNameString()
	return ret
}

func (tex *Context) scanFileName() {
	tex.nameInProgress = true
	tex.beginName()
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	for true {
		if (tex.curCmd > 12) || (tex.curChr > 255) {
			tex.backInput()
			goto label30
		}
		if !tex.moreName(byte(tex.curChr)) {
			goto label30
		}
		tex.getXToken()
	}
label30:
	tex.endName()
	tex.nameInProgress = false
}

func (tex *Context) packJobName(s uint16) {
	tex.curArea = 338
	tex.curExt = s
	tex.curName = tex.jobName
	tex.packFileName(tex.curName, tex.curArea, tex.curExt)
}

func (tex *Context) promptFileName(s, e uint16) {
	var k uint16 // 0..500
	if tex.interaction == 2 {
	}
	if s == 787 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(788)
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(789)
	}
	tex.printFileName(int32(tex.curName), int32(tex.curArea), int32(tex.curExt))
	tex.print(790)
	if e == 791 {
		tex.showContext()
	}
	tex.printNl(792)
	tex.print(int32(s))
	if tex.interaction < 2 {
		tex.fatalError(793)
	}
	breakIn(&tex.termIn, true)
	tex.print(568)
	tex.termInput()
	tex.beginName()
	k = tex.first
	for (tex.buffer[k] == 32) && (k < tex.last) {
		k = uint16(int32(k) + 1)
	}
	for true {
		if k == tex.last {
			goto label30
		}
		if !tex.moreName(tex.buffer[k]) {
			goto label30
		}
		k = uint16(int32(k) + 1)
	}
label30:
	tex.endName()
	if tex.curExt == 338 {
		tex.curExt = e
	}
	tex.packFileName(tex.curName, tex.curArea, tex.curExt)
}

func (tex *Context) openLogFile() {
	var oldSetting byte // 0..21
	var k uint16        // 0..500
	var l uint16        // 0..500
	var months [36]byte // array[1..36] of char
	oldSetting = tex.selector
	if tex.jobName == 0 {
		tex.jobName = 796
	}
	tex.packJobName(797)
	for !tex.aOpenOut(&tex.logFile) {
		tex.selector = 17
		tex.promptFileName(799, 797)
	}
	tex.logName = tex.aMakeNameString(&tex.logFile)
	tex.selector = 18
	tex.logOpened = true
	write(&tex.logFile, "This is TeX, Version 3.141592653")
	tex.slowPrint(int32(tex.formatIdent))
	tex.print(800)
	tex.printInt(pasSysDay())
	tex.printChar(32)
	setString(months[:], "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC")
	for _i := int64((3 * pasSysMonth()) - 2); _i <= int64((3 * pasSysMonth())); _i++ {
		k = uint16(_i)
		write(&tex.logFile, months[k-1])
	}
	tex.printChar(32)
	tex.printInt(pasSysYear())
	tex.printChar(32)
	tex.printTwo((pasSysTime() / 60))
	tex.printChar(58)
	tex.printTwo((pasSysTime() % 60))
	tex.inputStack[tex.inputPtr] = tex.curInput
	tex.printNl(798)
	l = tex.inputStack[0].limitField
	if int32(tex.buffer[l]) == tex.eqtb[5311-1].int() {
		l = uint16(int32(l) - 1)
	}
	for _i := int64(1); _i <= int64(l); _i++ {
		k = uint16(_i)
		tex.print(int32(tex.buffer[k]))
	}
	tex.printLn()
	tex.selector = byte(int32(oldSetting) + 2)
}

func (tex *Context) startInput() {
	tex.scanFileName()
	if tex.curExt == 338 {
		tex.curExt = 791
	}
	tex.packFileName(tex.curName, tex.curArea, tex.curExt)
	for true {
		tex.beginFileReading()
		if tex.aOpenIn(&tex.inputFile[tex.curInput.indexField-1]) {
			goto label30
		}
		if tex.curArea == 338 {
			tex.packFileName(tex.curName, 784, tex.curExt)
			if tex.aOpenIn(&tex.inputFile[tex.curInput.indexField-1]) {
				goto label30
			}
		}
		tex.endFileReading()
		tex.promptFileName(787, 791)
	}
label30:
	tex.curInput.nameField = tex.aMakeNameString(&tex.inputFile[tex.curInput.indexField-1])
	if tex.jobName == 0 {
		tex.jobName = tex.curName
		tex.openLogFile()
	}
	if int32(tex.termOffset)+(int32(tex.strStart[int32(tex.curInput.nameField)+1])-int32(tex.strStart[tex.curInput.nameField])) > maxPrintLine-2 {
		tex.printLn()
	} else if (tex.termOffset > 0) || (tex.fileOffset > 0) {
		tex.printChar(32)
	}
	tex.printChar(40)
	tex.openParens = byte(int32(tex.openParens) + 1)
	tex.slowPrint(int32(tex.curInput.nameField))
	break1(&tex.termOut)
	tex.curInput.stateField = 33
	if int32(tex.curInput.nameField) == int32(tex.strPtr)-1 {
		tex.strPtr = uint16(int32(tex.strPtr) - 1)
		tex.poolPtr = tex.strStart[tex.strPtr]
		tex.curInput.nameField = tex.curName
	}
	tex.line = 1
	if tex.inputLn(&tex.inputFile[tex.curInput.indexField-1], false) {
	}
	tex.firmUpTheLine()
	if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
		tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - 1)
	} else {
		tex.buffer[tex.curInput.limitField] = byte(tex.eqtb[5311-1].int())
	}
	tex.first = uint16(int32(tex.curInput.limitField) + 1)
	tex.curInput.locField = tex.curInput.startField
}

func (tex *Context) readFontInfo(u uint16, nom, aire uint16, s int32) (ret byte) {
	var k uint16                                              // 0..20000
	var fileOpened bool                                       // boolean
	var lf, lh, bc, ec, nw, nh, nd, ni, nl, nk, ne, np uint16 // 0..65535
	var f byte                                                // 0..75
	var g byte                                                // 0..75
	var a, b, c, d byte                                       // 0..255
	var qw fourQuarters                                       // record fourQuarters
	var sw int32                                              // integer
	var bchLabel int32                                        // integer
	var bchar uint16                                          // 0..256
	var z int32                                               // integer
	var alpha int32                                           // integer
	var beta byte                                             // 1..16
	g = 0
	fileOpened = false
	if aire == 338 {
		tex.packFileName(nom, 785, 811)
	} else {
		tex.packFileName(nom, aire, 811)
	}
	if !tex.bOpenIn(&tex.tfmFile) {
		goto label11
	}
	fileOpened = true
	lf = uint16(tex.tfmFile.byte())
	if lf > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	lf = uint16((int32(lf) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	lh = uint16(tex.tfmFile.byte())
	if lh > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	lh = uint16((int32(lh) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	bc = uint16(tex.tfmFile.byte())
	if bc > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	bc = uint16((int32(bc) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	ec = uint16(tex.tfmFile.byte())
	if ec > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	ec = uint16((int32(ec) * 256) + int32(tex.tfmFile.byte()))
	if (int32(bc) > (int32(ec) + 1)) || (ec > 255) {
		goto label11
	}
	if bc > 255 {
		bc = 1
		ec = 0
	}
	get(&tex.tfmFile)
	nw = uint16(tex.tfmFile.byte())
	if nw > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	nw = uint16((int32(nw) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	nh = uint16(tex.tfmFile.byte())
	if nh > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	nh = uint16((int32(nh) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	nd = uint16(tex.tfmFile.byte())
	if nd > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	nd = uint16((int32(nd) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	ni = uint16(tex.tfmFile.byte())
	if ni > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	ni = uint16((int32(ni) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	nl = uint16(tex.tfmFile.byte())
	if nl > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	nl = uint16((int32(nl) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	nk = uint16(tex.tfmFile.byte())
	if nk > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	nk = uint16((int32(nk) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	ne = uint16(tex.tfmFile.byte())
	if ne > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	ne = uint16((int32(ne) * 256) + int32(tex.tfmFile.byte()))
	get(&tex.tfmFile)
	np = uint16(tex.tfmFile.byte())
	if np > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	np = uint16((int32(np) * 256) + int32(tex.tfmFile.byte()))
	if int32(lf) != 6+int32(lh)+(int32(ec)-int32(bc)+1)+int32(nw)+int32(nh)+int32(nd)+int32(ni)+int32(nl)+int32(nk)+int32(ne)+int32(np) {
		goto label11
	}
	if (nw == 0) || (nh == 0) || (nd == 0) || (ni == 0) {
		goto label11
	}
	lf = uint16(int32(lf) - 6 - int32(lh))
	if np < 7 {
		lf = uint16(int32(lf) + 7 - int32(np))
	}
	if (tex.fontPtr == fontMax) || ((int32(tex.fmemPtr) + int32(lf)) > fontMemSize) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(802)
		tex.sprintCs(u)
		tex.printChar(61)
		tex.printFileName(int32(nom), int32(aire), 338)
		if s >= 0 {
			tex.print(741)
			tex.printScaled(s)
			tex.print(397)
		} else if s != -1000 {
			tex.print(803)
			tex.printInt(-s)
		}
		tex.print(812)
		tex.helpPtr = 4
		tex.helpLine[3] = 813
		tex.helpLine[2] = 814
		tex.helpLine[1] = 815
		tex.helpLine[0] = 816
		tex.error1()
		goto label30
	}
	f = byte(int32(tex.fontPtr) + 1)
	tex.charBase[f] = int32(tex.fmemPtr) - int32(bc)
	tex.widthBase[f] = tex.charBase[f] + int32(ec) + 1
	tex.heightBase[f] = tex.widthBase[f] + int32(nw)
	tex.depthBase[f] = tex.heightBase[f] + int32(nh)
	tex.italicBase[f] = tex.depthBase[f] + int32(nd)
	tex.ligKernBase[f] = tex.italicBase[f] + int32(ni)
	tex.kernBase[f] = tex.ligKernBase[f] + int32(nl) - (256 * 128)
	tex.extenBase[f] = tex.kernBase[f] + (256 * 128) + int32(nk)
	tex.paramBase[f] = tex.extenBase[f] + int32(ne)
	if lh < 2 {
		goto label11
	}
	get(&tex.tfmFile)
	a = tex.tfmFile.byte()
	qw.b0 = byte(int32(a) + 0)
	get(&tex.tfmFile)
	b = tex.tfmFile.byte()
	qw.b1 = byte(int32(b) + 0)
	get(&tex.tfmFile)
	c = tex.tfmFile.byte()
	qw.b2 = byte(int32(c) + 0)
	get(&tex.tfmFile)
	d = tex.tfmFile.byte()
	qw.b3 = byte(int32(d) + 0)
	tex.fontCheck[f] = qw
	get(&tex.tfmFile)
	z = int32(tex.tfmFile.byte())
	if z > 127 {
		goto label11
	}
	get(&tex.tfmFile)
	z = (z * 256) + int32(tex.tfmFile.byte())
	get(&tex.tfmFile)
	z = (z * 256) + int32(tex.tfmFile.byte())
	get(&tex.tfmFile)
	z = (z * 16) + (int32(tex.tfmFile.byte()) / 16)
	if z < 65536 {
		goto label11
	}
	for lh > 2 {
		get(&tex.tfmFile)
		get(&tex.tfmFile)
		get(&tex.tfmFile)
		get(&tex.tfmFile)
		lh = uint16(int32(lh) - 1)
	}
	tex.fontDsize[f] = z
	if s != -1000 {
		if s >= 0 {
			z = s
		} else {
			z = tex.xnOverD(z, -s, 1000)
		}
	}
	tex.fontSize[f] = z
	for _i := int64(tex.fmemPtr); _i <= int64(tex.widthBase[f]-1); _i++ {
		k = uint16(_i)
		get(&tex.tfmFile)
		a = tex.tfmFile.byte()
		qw.b0 = byte(int32(a) + 0)
		get(&tex.tfmFile)
		b = tex.tfmFile.byte()
		qw.b1 = byte(int32(b) + 0)
		get(&tex.tfmFile)
		c = tex.tfmFile.byte()
		qw.b2 = byte(int32(c) + 0)
		get(&tex.tfmFile)
		d = tex.tfmFile.byte()
		qw.b3 = byte(int32(d) + 0)
		*tex.fontInfo[k].pQqqq() = qw
		if (uint16(a) >= nw) || ((int32(b) / 16) >= int32(nh)) || ((int32(b) % 16) >= int32(nd)) || ((int32(c) / 4) >= int32(ni)) {
			goto label11
		}
		switch int32(c) % 4 {
		case 1:
			if uint16(d) >= nl {
				goto label11
			}
		case 3:
			if uint16(d) >= ne {
				goto label11
			}
		case 2:
			if (uint16(d) < bc) || (uint16(d) > ec) {
				goto label11
			}
			for int32(d) < int32(k)+int32(bc)-int32(tex.fmemPtr) {
				qw = tex.fontInfo[tex.charBase[f]+int32(d)].qqqq()
				if ((int32(qw.b2) - 0) % 4) != 2 {
					goto label45
				}
				d = byte(int32(qw.b3) - 0)
			}
			if int32(d) == int32(k)+int32(bc)-int32(tex.fmemPtr) {
				goto label11
			}
		label45:
			;
		default:
		}
	}
	alpha = 16
	for z >= 8388608 {
		z = (z / 2)
		alpha = alpha + alpha
	}
	beta = byte((256 / alpha))
	alpha = (alpha * z)
	for _i := int64(tex.widthBase[f]); _i <= int64(tex.ligKernBase[f]-1); _i++ {
		k = uint16(_i)
		get(&tex.tfmFile)
		a = tex.tfmFile.byte()
		get(&tex.tfmFile)
		b = tex.tfmFile.byte()
		get(&tex.tfmFile)
		c = tex.tfmFile.byte()
		get(&tex.tfmFile)
		d = tex.tfmFile.byte()
		sw = ((((((int32(d) * z) / 256) + (int32(c) * z)) / 256) + (int32(b) * z)) / int32(beta))
		if a == 0 {
			*tex.fontInfo[k].pInt() = sw
		} else if a == 255 {
			*tex.fontInfo[k].pInt() = sw - alpha
		} else {
			goto label11
		}
	}
	if tex.fontInfo[tex.widthBase[f]].int() != 0 {
		goto label11
	}
	if tex.fontInfo[tex.heightBase[f]].int() != 0 {
		goto label11
	}
	if tex.fontInfo[tex.depthBase[f]].int() != 0 {
		goto label11
	}
	if tex.fontInfo[tex.italicBase[f]].int() != 0 {
		goto label11
	}
	bchLabel = 32767
	bchar = 256
	if nl > 0 {
		for _i := int64(tex.ligKernBase[f]); _i <= int64(tex.kernBase[f]+(256*128)-1); _i++ {
			k = uint16(_i)
			get(&tex.tfmFile)
			a = tex.tfmFile.byte()
			qw.b0 = byte(int32(a) + 0)
			get(&tex.tfmFile)
			b = tex.tfmFile.byte()
			qw.b1 = byte(int32(b) + 0)
			get(&tex.tfmFile)
			c = tex.tfmFile.byte()
			qw.b2 = byte(int32(c) + 0)
			get(&tex.tfmFile)
			d = tex.tfmFile.byte()
			qw.b3 = byte(int32(d) + 0)
			*tex.fontInfo[k].pQqqq() = qw
			if a > 128 {
				if (256*int32(c))+int32(d) >= int32(nl) {
					goto label11
				}
				if a == 255 {
					if int32(k) == tex.ligKernBase[f] {
						bchar = uint16(b)
					}
				}
			} else {
				if uint16(b) != bchar {
					if (uint16(b) < bc) || (uint16(b) > ec) {
						goto label11
					}
					qw = tex.fontInfo[tex.charBase[f]+int32(b)].qqqq()
					if !(qw.b0 > 0) {
						goto label11
					}
				}
				if c < 128 {
					if (uint16(d) < bc) || (uint16(d) > ec) {
						goto label11
					}
					qw = tex.fontInfo[tex.charBase[f]+int32(d)].qqqq()
					if !(qw.b0 > 0) {
						goto label11
					}
				} else if (256*(int32(c)-128))+int32(d) >= int32(nk) {
					goto label11
				}
				if a < 128 {
					if int32(k)-tex.ligKernBase[f]+int32(a)+1 >= int32(nl) {
						goto label11
					}
				}
			}
		}
		if a == 255 {
			bchLabel = (256 * int32(c)) + int32(d)
		}
	}
	for _i := int64(tex.kernBase[f] + (256 * 128)); _i <= int64(tex.extenBase[f]-1); _i++ {
		k = uint16(_i)
		get(&tex.tfmFile)
		a = tex.tfmFile.byte()
		get(&tex.tfmFile)
		b = tex.tfmFile.byte()
		get(&tex.tfmFile)
		c = tex.tfmFile.byte()
		get(&tex.tfmFile)
		d = tex.tfmFile.byte()
		sw = ((((((int32(d) * z) / 256) + (int32(c) * z)) / 256) + (int32(b) * z)) / int32(beta))
		if a == 0 {
			*tex.fontInfo[k].pInt() = sw
		} else if a == 255 {
			*tex.fontInfo[k].pInt() = sw - alpha
		} else {
			goto label11
		}
	}
	for _i := int64(tex.extenBase[f]); _i <= int64(tex.paramBase[f]-1); _i++ {
		k = uint16(_i)
		get(&tex.tfmFile)
		a = tex.tfmFile.byte()
		qw.b0 = byte(int32(a) + 0)
		get(&tex.tfmFile)
		b = tex.tfmFile.byte()
		qw.b1 = byte(int32(b) + 0)
		get(&tex.tfmFile)
		c = tex.tfmFile.byte()
		qw.b2 = byte(int32(c) + 0)
		get(&tex.tfmFile)
		d = tex.tfmFile.byte()
		qw.b3 = byte(int32(d) + 0)
		*tex.fontInfo[k].pQqqq() = qw
		if a != 0 {
			if (uint16(a) < bc) || (uint16(a) > ec) {
				goto label11
			}
			qw = tex.fontInfo[tex.charBase[f]+int32(a)].qqqq()
			if !(qw.b0 > 0) {
				goto label11
			}
		}
		if b != 0 {
			if (uint16(b) < bc) || (uint16(b) > ec) {
				goto label11
			}
			qw = tex.fontInfo[tex.charBase[f]+int32(b)].qqqq()
			if !(qw.b0 > 0) {
				goto label11
			}
		}
		if c != 0 {
			if (uint16(c) < bc) || (uint16(c) > ec) {
				goto label11
			}
			qw = tex.fontInfo[tex.charBase[f]+int32(c)].qqqq()
			if !(qw.b0 > 0) {
				goto label11
			}
		}
		if (uint16(d) < bc) || (uint16(d) > ec) {
			goto label11
		}
		qw = tex.fontInfo[tex.charBase[f]+int32(d)].qqqq()
		if !(qw.b0 > 0) {
			goto label11
		}
	}
	for _i := int64(1); _i <= int64(np); _i++ {
		k = uint16(_i)
		if k == 1 {
			get(&tex.tfmFile)
			sw = int32(tex.tfmFile.byte())
			if sw > 127 {
				sw = sw - 256
			}
			get(&tex.tfmFile)
			sw = (sw * 256) + int32(tex.tfmFile.byte())
			get(&tex.tfmFile)
			sw = (sw * 256) + int32(tex.tfmFile.byte())
			get(&tex.tfmFile)
			*tex.fontInfo[tex.paramBase[f]].pInt() = (sw * 16) + (int32(tex.tfmFile.byte()) / 16)
		} else {
			get(&tex.tfmFile)
			a = tex.tfmFile.byte()
			get(&tex.tfmFile)
			b = tex.tfmFile.byte()
			get(&tex.tfmFile)
			c = tex.tfmFile.byte()
			get(&tex.tfmFile)
			d = tex.tfmFile.byte()
			sw = ((((((int32(d) * z) / 256) + (int32(c) * z)) / 256) + (int32(b) * z)) / int32(beta))
			if a == 0 {
				*tex.fontInfo[tex.paramBase[f]+int32(k)-1].pInt() = sw
			} else if a == 255 {
				*tex.fontInfo[tex.paramBase[f]+int32(k)-1].pInt() = sw - alpha
			} else {
				goto label11
			}
		}
	}
	if eof(&tex.tfmFile) {
		goto label11
	}
	for _i := int64(int32(np) + 1); _i <= int64(7); _i++ {
		k = uint16(_i)
		*tex.fontInfo[tex.paramBase[f]+int32(k)-1].pInt() = 0
	}
	if np >= 7 {
		tex.fontParams[f] = np
	} else {
		tex.fontParams[f] = 7
	}
	tex.hyphenChar[f] = tex.eqtb[5309-1].int()
	tex.skewChar[f] = tex.eqtb[5310-1].int()
	if bchLabel < int32(nl) {
		tex.bcharLabel[f] = uint16(bchLabel + tex.ligKernBase[f])
	} else {
		tex.bcharLabel[f] = 0
	}
	tex.fontBchar[f] = uint16(int32(bchar) + 0)
	tex.fontFalseBchar[f] = uint16(int32(bchar) + 0)
	if bchar <= ec {
		if bchar >= bc {
			qw = tex.fontInfo[tex.charBase[f]+int32(bchar)].qqqq()
			if qw.b0 > 0 {
				tex.fontFalseBchar[f] = 256
			}
		}
	}
	tex.fontName[f] = nom
	tex.fontArea[f] = aire
	tex.fontBc[f] = byte(bc)
	tex.fontEc[f] = byte(ec)
	tex.fontGlue[f] = 0
	tex.charBase[f] = tex.charBase[f] - 0
	tex.widthBase[f] = tex.widthBase[f] - 0
	tex.ligKernBase[f] = tex.ligKernBase[f] - 0
	tex.kernBase[f] = tex.kernBase[f] - 0
	tex.extenBase[f] = tex.extenBase[f] - 0
	tex.paramBase[f] = tex.paramBase[f] - 1
	tex.fmemPtr = uint16(int32(tex.fmemPtr) + int32(lf))
	tex.fontPtr = f
	g = f
	goto label30
label11:
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(802)
	tex.sprintCs(u)
	tex.printChar(61)
	tex.printFileName(int32(nom), int32(aire), 338)
	if s >= 0 {
		tex.print(741)
		tex.printScaled(s)
		tex.print(397)
	} else if s != -1000 {
		tex.print(803)
		tex.printInt(-s)
	}
	if fileOpened {
		tex.print(804)
	} else {
		tex.print(805)
	}
	tex.helpPtr = 5
	tex.helpLine[4] = 806
	tex.helpLine[3] = 807
	tex.helpLine[2] = 808
	tex.helpLine[1] = 809
	tex.helpLine[0] = 810
	tex.error1()
label30:
	if fileOpened {
		tex.bClose(&tex.tfmFile)
	}
	ret = g
	return ret
}

func (tex *Context) charWarning(f byte, c byte) {
	if tex.eqtb[5298-1].int() > 0 {
		tex.beginDiagnostic()
		tex.printNl(825)
		tex.print(int32(c))
		tex.print(826)
		tex.slowPrint(int32(tex.fontName[f]))
		tex.printChar(33)
		tex.endDiagnostic(false)
	}
}

func (tex *Context) newCharacter(f byte, c byte) (ret uint16) {
	var p uint16 // 0..65535
	if tex.fontBc[f] <= c {
		if tex.fontEc[f] >= c {
			if tex.fontInfo[tex.charBase[f]+int32(c)+0].qqqq().b0 > 0 {
				p = tex.getAvail()
				*tex.mem[p].pHh().pB0() = f
				*tex.mem[p].pHh().pB1() = byte(int32(c) + 0)
				ret = p
				goto label10
			}
		}
	}
	tex.charWarning(f, c)
	ret = 0
label10:
	return ret
}

func (tex *Context) writeDvi(a, b uint16) {
	var k uint16 // 0..800
	for _i := int64(a); _i <= int64(b); _i++ {
		k = uint16(_i)
		write(&tex.dviFile, tex.dviBuf[k])
	}
}

func (tex *Context) dviSwap() {
	if tex.dviLimit == dviBufSize {
		tex.writeDvi(0, uint16(int32(tex.halfBuf)-1))
		tex.dviLimit = tex.halfBuf
		tex.dviOffset = tex.dviOffset + dviBufSize
		tex.dviPtr = 0
	} else {
		tex.writeDvi(tex.halfBuf, uint16(dviBufSize-1))
		tex.dviLimit = dviBufSize
	}
	tex.dviGone = tex.dviGone + int32(tex.halfBuf)
}

func (tex *Context) dviFour(x int32) {
	if x >= 0 {
		tex.dviBuf[tex.dviPtr] = byte((x / 16777216))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	} else {
		x = x + 1073741824
		x = x + 1073741824
		tex.dviBuf[tex.dviPtr] = byte((x / 16777216) + 128)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
	x = (x % 16777216)
	tex.dviBuf[tex.dviPtr] = byte((x / 65536))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	x = (x % 65536)
	tex.dviBuf[tex.dviPtr] = byte((x / 256))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte((x % 256))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
}

func (tex *Context) dviPop(l int32) {
	if (l == (tex.dviOffset + int32(tex.dviPtr))) && (tex.dviPtr > 0) {
		tex.dviPtr = uint16(int32(tex.dviPtr) - 1)
	} else {
		tex.dviBuf[tex.dviPtr] = 142
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
}

func (tex *Context) dviFontDef(f byte) {
	var k uint16 // 0..32000
	tex.dviBuf[tex.dviPtr] = 243
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte(int32(f) - 1)
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte(int32(tex.fontCheck[f].b0) - 0)
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte(int32(tex.fontCheck[f].b1) - 0)
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte(int32(tex.fontCheck[f].b2) - 0)
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte(int32(tex.fontCheck[f].b3) - 0)
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviFour(tex.fontSize[f])
	tex.dviFour(tex.fontDsize[f])
	tex.dviBuf[tex.dviPtr] = byte((int32(tex.strStart[int32(tex.fontArea[f])+1]) - int32(tex.strStart[tex.fontArea[f]])))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.dviBuf[tex.dviPtr] = byte((int32(tex.strStart[int32(tex.fontName[f])+1]) - int32(tex.strStart[tex.fontName[f]])))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	for _i := int64(tex.strStart[tex.fontArea[f]]); _i <= int64(int32(tex.strStart[int32(tex.fontArea[f])+1])-1); _i++ {
		k = uint16(_i)
		tex.dviBuf[tex.dviPtr] = tex.strPool[k]
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
	for _i := int64(tex.strStart[tex.fontName[f]]); _i <= int64(int32(tex.strStart[int32(tex.fontName[f])+1])-1); _i++ {
		k = uint16(_i)
		tex.dviBuf[tex.dviPtr] = tex.strPool[k]
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
}

func (tex *Context) movement(w int32, o byte) {
	var mstate byte // 0..63
	var p, q uint16 // 0..65535
	var k int32     // integer
	q = tex.getNode(3)
	*tex.mem[int32(q)+1].pInt() = w
	*tex.mem[int32(q)+2].pInt() = tex.dviOffset + int32(tex.dviPtr)
	if o == 157 {
		tex.mem[q].pHh().rh = tex.downPtr
		tex.downPtr = q
	} else {
		tex.mem[q].pHh().rh = tex.rightPtr
		tex.rightPtr = q
	}
	p = tex.mem[q].hh().rh
	mstate = 0
	for p != 0 {
		if tex.mem[int32(p)+1].int() == w {
			switch int32(mstate) + int32(tex.mem[p].hh().lh()) {
			case 3, 4, 15, 16:
				if tex.mem[int32(p)+2].int() < tex.dviGone {
					goto label45
				} else {
					k = tex.mem[int32(p)+2].int() - tex.dviOffset
					if k < 0 {
						k = k + dviBufSize
					}
					tex.dviBuf[k] = byte(int32(tex.dviBuf[k]) + 5)
					*tex.mem[p].pHh().pLh() = 1
					goto label40
				}
			case 5, 9, 11:
				if tex.mem[int32(p)+2].int() < tex.dviGone {
					goto label45
				} else {
					k = tex.mem[int32(p)+2].int() - tex.dviOffset
					if k < 0 {
						k = k + dviBufSize
					}
					tex.dviBuf[k] = byte(int32(tex.dviBuf[k]) + 10)
					*tex.mem[p].pHh().pLh() = 2
					goto label40
				}
			case 1, 2, 8, 13:
				goto label40
			default:
			}
		} else {
			switch int32(mstate) + int32(tex.mem[p].hh().lh()) {
			case 1:
				mstate = 6
			case 2:
				mstate = 12
			case 8, 13:
				goto label45
			default:
			}
		}
		p = tex.mem[p].hh().rh
	}
label45:
	*tex.mem[q].pHh().pLh() = 3
	if iabs(w) >= 8388608 {
		tex.dviBuf[tex.dviPtr] = byte(int32(o) + 3)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviFour(w)
		goto label10
	}
	if iabs(w) >= 32768 {
		tex.dviBuf[tex.dviPtr] = byte(int32(o) + 2)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		if w < 0 {
			w = w + 16777216
		}
		tex.dviBuf[tex.dviPtr] = byte((w / 65536))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		w = (w % 65536)
		goto label2
	}
	if iabs(w) >= 128 {
		tex.dviBuf[tex.dviPtr] = byte(int32(o) + 1)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		if w < 0 {
			w = w + 65536
		}
		goto label2
	}
	tex.dviBuf[tex.dviPtr] = o
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	if w < 0 {
		w = w + 256
	}
	goto label1
label2:
	tex.dviBuf[tex.dviPtr] = byte((w / 256))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
label1:
	tex.dviBuf[tex.dviPtr] = byte((w % 256))
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	goto label10
label40:
	*tex.mem[q].pHh().pLh() = tex.mem[p].hh().lh()
	if tex.mem[q].hh().lh() == 1 {
		tex.dviBuf[tex.dviPtr] = byte(int32(o) + 4)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		for tex.mem[q].hh().rh != p {
			q = tex.mem[q].hh().rh
			switch tex.mem[q].hh().lh() {
			case 3:
				*tex.mem[q].pHh().pLh() = 5
			case 4:
				*tex.mem[q].pHh().pLh() = 6
			default:
			}
		}
	} else {
		tex.dviBuf[tex.dviPtr] = byte(int32(o) + 9)
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		for tex.mem[q].hh().rh != p {
			q = tex.mem[q].hh().rh
			switch tex.mem[q].hh().lh() {
			case 3:
				*tex.mem[q].pHh().pLh() = 4
			case 5:
				*tex.mem[q].pHh().pLh() = 6
			default:
			}
		}
	}
label10:
}

func (tex *Context) pruneMovements(l int32) {
	var p uint16 // 0..65535
	for tex.downPtr != 0 {
		if tex.mem[int32(tex.downPtr)+2].int() < l {
			goto label30
		}
		p = tex.downPtr
		tex.downPtr = tex.mem[p].hh().rh
		tex.freeNode(p, 3)
	}
label30:
	for tex.rightPtr != 0 {
		if tex.mem[int32(tex.rightPtr)+2].int() < l {
			goto label10
		}
		p = tex.rightPtr
		tex.rightPtr = tex.mem[p].hh().rh
		tex.freeNode(p, 3)
	}
label10:
}

func (tex *Context) specialOut(p uint16) {
	var oldSetting byte // 0..21
	var k uint16        // 0..32000
	if tex.curH != tex.dviH {
		tex.movement(tex.curH-tex.dviH, 143)
		tex.dviH = tex.curH
	}
	if tex.curV != tex.dviV {
		tex.movement(tex.curV-tex.dviV, 157)
		tex.dviV = tex.curV
	}
	oldSetting = tex.selector
	tex.selector = 21
	tex.showTokenList(int32(tex.mem[tex.mem[int32(p)+1].hh().rh].hh().rh), 0, poolSize-int32(tex.poolPtr))
	tex.selector = oldSetting
	if int32(tex.poolPtr)+1 > poolSize {
		tex.overflow(257, poolSize-int32(tex.initPoolPtr))
	}
	if (int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])) < 256 {
		tex.dviBuf[tex.dviPtr] = 239
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviBuf[tex.dviPtr] = byte((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	} else {
		tex.dviBuf[tex.dviPtr] = 242
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviFour((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])))
	}
	for _i := int64(tex.strStart[tex.strPtr]); _i <= int64(int32(tex.poolPtr)-1); _i++ {
		k = uint16(_i)
		tex.dviBuf[tex.dviPtr] = tex.strPool[k]
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
	tex.poolPtr = tex.strStart[tex.strPtr]
}

func (tex *Context) writeOut(p uint16) {
	var oldSetting byte // 0..21
	var oldMode int32   // integer
	var j byte          // 0..63
	var q, r uint16     // 0..65535
	q = tex.getAvail()
	*tex.mem[q].pHh().pLh() = 637
	r = tex.getAvail()
	tex.mem[q].pHh().rh = r
	*tex.mem[r].pHh().pLh() = 6717
	tex.beginTokenList(q, 4)
	tex.beginTokenList(tex.mem[int32(p)+1].hh().rh, 15)
	q = tex.getAvail()
	*tex.mem[q].pHh().pLh() = 379
	tex.beginTokenList(q, 4)
	oldMode = int32(tex.curList.modeField)
	tex.curList.modeField = 0
	tex.curCs = tex.writeLoc
	q = tex.scanToks(false, true)
	tex.getToken()
	if tex.curTok != 6717 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1297)
		tex.helpPtr = 2
		tex.helpLine[1] = 1298
		tex.helpLine[0] = 1012
		tex.error1()
		for {
			tex.getToken()
			if tex.curTok == 6717 {
				break
			}
		}
	}
	tex.curList.modeField = int16(oldMode)
	tex.endTokenList()
	oldSetting = tex.selector
	j = byte(tex.mem[int32(p)+1].hh().lh())
	if tex.writeOpen[j] {
		tex.selector = j
	} else {
		if (j == 17) && (tex.selector == 19) {
			tex.selector = 18
		}
		tex.printNl(338)
	}
	tex.tokenShow(tex.defRef)
	tex.printLn()
	tex.flushList(tex.defRef)
	tex.selector = oldSetting
}

func (tex *Context) outWhat(p uint16) {
	var j byte // 0..63
	switch tex.mem[p].hh().b1() {
	case 0, 1, 2:
		if !tex.doingLeaders {
			j = byte(tex.mem[int32(p)+1].hh().lh())
			if tex.mem[p].hh().b1() == 1 {
				tex.writeOut(p)
			} else {
				if tex.writeOpen[j] {
					tex.aClose(&tex.writeFile[j])
				}
				if tex.mem[p].hh().b1() == 2 {
					tex.writeOpen[j] = false
				} else if j < 16 {
					tex.curName = tex.mem[int32(p)+1].hh().rh
					tex.curArea = tex.mem[int32(p)+2].hh().lh()
					tex.curExt = tex.mem[int32(p)+2].hh().rh
					if tex.curExt == 338 {
						tex.curExt = 791
					}
					tex.packFileName(tex.curName, tex.curArea, tex.curExt)
					for !tex.aOpenOut(&tex.writeFile[j]) {
						tex.promptFileName(1300, 791)
					}
					tex.writeOpen[j] = true
				}
			}
		}
	case 3:
		tex.specialOut(p)
	case 4:
	default:
		tex.confusion(1299)
	}
}

func (tex *Context) hlistOut() {
	var baseLine int32         // integer
	var leftEdge int32         // integer
	var saveH, saveV int32     // integer
	var thisBox uint16         // 0..65535
	var gOrder byte            // 0..3
	var gSign byte             // 0..2
	var p uint16               // 0..65535
	var saveLoc int32          // integer
	var leaderBox uint16       // 0..65535
	var leaderWd int32         // integer
	var lx int32               // integer
	var outerDoingLeaders bool // boolean
	var edge int32             // integer
	var glueTemp float32       // real
	var curGlue float32        // real
	var curG int32             // integer
	curG = 0
	curGlue = 0
	thisBox = tex.tempPtr
	gOrder = tex.mem[int32(thisBox)+5].hh().b1()
	gSign = tex.mem[int32(thisBox)+5].hh().b0()
	p = tex.mem[int32(thisBox)+5].hh().rh
	tex.curS = tex.curS + 1
	if tex.curS > 0 {
		tex.dviBuf[tex.dviPtr] = 141
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
	if tex.curS > tex.maxPush {
		tex.maxPush = tex.curS
	}
	saveLoc = tex.dviOffset + int32(tex.dviPtr)
	baseLine = tex.curV
	leftEdge = tex.curH
	for p != 0 {
	label21:
		if p >= tex.hiMemMin {
			if tex.curH != tex.dviH {
				tex.movement(tex.curH-tex.dviH, 143)
				tex.dviH = tex.curH
			}
			if tex.curV != tex.dviV {
				tex.movement(tex.curV-tex.dviV, 157)
				tex.dviV = tex.curV
			}
			for {
				tex.f = tex.mem[p].hh().b0()
				tex.c = tex.mem[p].hh().b1()
				if tex.f != tex.dviF {
					if !tex.fontUsed[tex.f] {
						tex.dviFontDef(tex.f)
						tex.fontUsed[tex.f] = true
					}
					if tex.f <= 64 {
						tex.dviBuf[tex.dviPtr] = byte(int32(tex.f) + 170)
						tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
						if tex.dviPtr == tex.dviLimit {
							tex.dviSwap()
						}
					} else {
						tex.dviBuf[tex.dviPtr] = 235
						tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
						if tex.dviPtr == tex.dviLimit {
							tex.dviSwap()
						}
						tex.dviBuf[tex.dviPtr] = byte(int32(tex.f) - 1)
						tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
						if tex.dviPtr == tex.dviLimit {
							tex.dviSwap()
						}
					}
					tex.dviF = tex.f
				}
				if tex.c >= 128 {
					tex.dviBuf[tex.dviPtr] = 128
					tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
					if tex.dviPtr == tex.dviLimit {
						tex.dviSwap()
					}
				}

				{
					tex.dviBuf[tex.dviPtr] = byte(int32(tex.c) - 0)
					tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
					if tex.dviPtr == tex.dviLimit {
						tex.dviSwap()
					}
				}
				tex.curH = tex.curH + tex.fontInfo[tex.widthBase[tex.f]+int32(tex.fontInfo[tex.charBase[tex.f]+int32(tex.c)].qqqq().b0)].int()
				p = tex.mem[p].hh().rh
				if !(p >= tex.hiMemMin) {
					break
				}
			}
			tex.dviH = tex.curH
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1:
				if tex.mem[int32(p)+5].hh().rh == 0 {
					tex.curH = tex.curH + tex.mem[int32(p)+1].int()
				} else {
					saveH = tex.dviH
					saveV = tex.dviV
					tex.curV = baseLine + tex.mem[int32(p)+4].int()
					tex.tempPtr = p
					edge = tex.curH
					if tex.mem[p].hh().b0() == 1 {
						tex.vlistOut()
					} else {
						tex.hlistOut()
					}
					tex.dviH = saveH
					tex.dviV = saveV
					tex.curH = edge + tex.mem[int32(p)+1].int()
					tex.curV = baseLine
				}
			case 2:
				tex.ruleHt = tex.mem[int32(p)+3].int()
				tex.ruleDp = tex.mem[int32(p)+2].int()
				tex.ruleWd = tex.mem[int32(p)+1].int()
				goto label14
			case 8:
				tex.outWhat(p)
			case 10:
				tex.g = tex.mem[int32(p)+1].hh().lh()
				tex.ruleWd = tex.mem[int32(tex.g)+1].int() - curG
				if gSign != 0 {
					if gSign == 1 {
						if tex.mem[tex.g].hh().b0() == gOrder {
							curGlue = curGlue + float32(tex.mem[int32(tex.g)+2].int())
							glueTemp = (tex.mem[int32(thisBox)+6].gr() * curGlue)
							if glueTemp > 1e+09 {
								glueTemp = 1e+09
							} else if glueTemp < -1e+09 {
								glueTemp = -1e+09
							}
							curG = round(glueTemp)
						}
					} else if tex.mem[tex.g].hh().b1() == gOrder {
						curGlue = curGlue - float32(tex.mem[int32(tex.g)+3].int())
						glueTemp = (tex.mem[int32(thisBox)+6].gr() * curGlue)
						if glueTemp > 1e+09 {
							glueTemp = 1e+09
						} else if glueTemp < -1e+09 {
							glueTemp = -1e+09
						}
						curG = round(glueTemp)
					}
				}
				tex.ruleWd = tex.ruleWd + curG
				if tex.mem[p].hh().b1() >= 100 {
					leaderBox = tex.mem[int32(p)+1].hh().rh
					if tex.mem[leaderBox].hh().b0() == 2 {
						tex.ruleHt = tex.mem[int32(leaderBox)+3].int()
						tex.ruleDp = tex.mem[int32(leaderBox)+2].int()
						goto label14
					}
					leaderWd = tex.mem[int32(leaderBox)+1].int()
					if (leaderWd > 0) && (tex.ruleWd > 0) {
						tex.ruleWd = tex.ruleWd + 10
						edge = tex.curH + tex.ruleWd
						lx = 0
						if tex.mem[p].hh().b1() == 100 {
							saveH = tex.curH
							tex.curH = leftEdge + (leaderWd * ((tex.curH - leftEdge) / leaderWd))
							if tex.curH < saveH {
								tex.curH = tex.curH + leaderWd
							}
						} else {
							tex.lq = (tex.ruleWd / leaderWd)
							tex.lr = (tex.ruleWd % leaderWd)
							if tex.mem[p].hh().b1() == 101 {
								tex.curH = tex.curH + (tex.lr / 2)
							} else {
								lx = (tex.lr / (tex.lq + 1))
								tex.curH = tex.curH + ((tex.lr - ((tex.lq - 1) * lx)) / 2)
							}
						}
						for tex.curH+leaderWd <= edge {
							tex.curV = baseLine + tex.mem[int32(leaderBox)+4].int()
							if tex.curV != tex.dviV {
								tex.movement(tex.curV-tex.dviV, 157)
								tex.dviV = tex.curV
							}
							saveV = tex.dviV
							if tex.curH != tex.dviH {
								tex.movement(tex.curH-tex.dviH, 143)
								tex.dviH = tex.curH
							}
							saveH = tex.dviH
							tex.tempPtr = leaderBox
							outerDoingLeaders = tex.doingLeaders
							tex.doingLeaders = true
							if tex.mem[leaderBox].hh().b0() == 1 {
								tex.vlistOut()
							} else {
								tex.hlistOut()
							}
							tex.doingLeaders = outerDoingLeaders
							tex.dviV = saveV
							tex.dviH = saveH
							tex.curV = baseLine
							tex.curH = saveH + leaderWd + lx
						}
						tex.curH = edge - 10
						goto label15
					}
				}
				goto label13
			case 11, 9:
				tex.curH = tex.curH + tex.mem[int32(p)+1].int()
			case 6:
				tex.mem[29988] = tex.mem[int32(p)+1]
				tex.mem[29988].pHh().rh = tex.mem[p].hh().rh
				p = 29988
				goto label21
			default:
			}
			goto label15
		label14:
			if tex.ruleHt == -1073741824 {
				tex.ruleHt = tex.mem[int32(thisBox)+3].int()
			}
			if tex.ruleDp == -1073741824 {
				tex.ruleDp = tex.mem[int32(thisBox)+2].int()
			}
			tex.ruleHt = tex.ruleHt + tex.ruleDp
			if (tex.ruleHt > 0) && (tex.ruleWd > 0) {
				if tex.curH != tex.dviH {
					tex.movement(tex.curH-tex.dviH, 143)
					tex.dviH = tex.curH
				}
				tex.curV = baseLine + tex.ruleDp
				if tex.curV != tex.dviV {
					tex.movement(tex.curV-tex.dviV, 157)
					tex.dviV = tex.curV
				}
				tex.dviBuf[tex.dviPtr] = 132
				tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
				if tex.dviPtr == tex.dviLimit {
					tex.dviSwap()
				}
				tex.dviFour(tex.ruleHt)
				tex.dviFour(tex.ruleWd)
				tex.curV = baseLine
				tex.dviH = tex.dviH + tex.ruleWd
			}
		label13:
			tex.curH = tex.curH + tex.ruleWd
		label15:
			p = tex.mem[p].hh().rh
		}
	}
	tex.pruneMovements(saveLoc)
	if tex.curS > 0 {
		tex.dviPop(saveLoc)
	}
	tex.curS = tex.curS - 1
}

func (tex *Context) vlistOut() {
	var leftEdge int32         // integer
	var topEdge int32          // integer
	var saveH, saveV int32     // integer
	var thisBox uint16         // 0..65535
	var gOrder byte            // 0..3
	var gSign byte             // 0..2
	var p uint16               // 0..65535
	var saveLoc int32          // integer
	var leaderBox uint16       // 0..65535
	var leaderHt int32         // integer
	var lx int32               // integer
	var outerDoingLeaders bool // boolean
	var edge int32             // integer
	var glueTemp float32       // real
	var curGlue float32        // real
	var curG int32             // integer
	curG = 0
	curGlue = 0
	thisBox = tex.tempPtr
	gOrder = tex.mem[int32(thisBox)+5].hh().b1()
	gSign = tex.mem[int32(thisBox)+5].hh().b0()
	p = tex.mem[int32(thisBox)+5].hh().rh
	tex.curS = tex.curS + 1
	if tex.curS > 0 {
		tex.dviBuf[tex.dviPtr] = 141
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
	}
	if tex.curS > tex.maxPush {
		tex.maxPush = tex.curS
	}
	saveLoc = tex.dviOffset + int32(tex.dviPtr)
	leftEdge = tex.curH
	tex.curV = tex.curV - tex.mem[int32(thisBox)+3].int()
	topEdge = tex.curV
	for p != 0 {
		if p >= tex.hiMemMin {
			tex.confusion(828)
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1:
				if tex.mem[int32(p)+5].hh().rh == 0 {
					tex.curV = tex.curV + tex.mem[int32(p)+3].int() + tex.mem[int32(p)+2].int()
				} else {
					tex.curV = tex.curV + tex.mem[int32(p)+3].int()
					if tex.curV != tex.dviV {
						tex.movement(tex.curV-tex.dviV, 157)
						tex.dviV = tex.curV
					}
					saveH = tex.dviH
					saveV = tex.dviV
					tex.curH = leftEdge + tex.mem[int32(p)+4].int()
					tex.tempPtr = p
					if tex.mem[p].hh().b0() == 1 {
						tex.vlistOut()
					} else {
						tex.hlistOut()
					}
					tex.dviH = saveH
					tex.dviV = saveV
					tex.curV = saveV + tex.mem[int32(p)+2].int()
					tex.curH = leftEdge
				}
			case 2:
				tex.ruleHt = tex.mem[int32(p)+3].int()
				tex.ruleDp = tex.mem[int32(p)+2].int()
				tex.ruleWd = tex.mem[int32(p)+1].int()
				goto label14
			case 8:
				tex.outWhat(p)
			case 10:
				tex.g = tex.mem[int32(p)+1].hh().lh()
				tex.ruleHt = tex.mem[int32(tex.g)+1].int() - curG
				if gSign != 0 {
					if gSign == 1 {
						if tex.mem[tex.g].hh().b0() == gOrder {
							curGlue = curGlue + float32(tex.mem[int32(tex.g)+2].int())
							glueTemp = (tex.mem[int32(thisBox)+6].gr() * curGlue)
							if glueTemp > 1e+09 {
								glueTemp = 1e+09
							} else if glueTemp < -1e+09 {
								glueTemp = -1e+09
							}
							curG = round(glueTemp)
						}
					} else if tex.mem[tex.g].hh().b1() == gOrder {
						curGlue = curGlue - float32(tex.mem[int32(tex.g)+3].int())
						glueTemp = (tex.mem[int32(thisBox)+6].gr() * curGlue)
						if glueTemp > 1e+09 {
							glueTemp = 1e+09
						} else if glueTemp < -1e+09 {
							glueTemp = -1e+09
						}
						curG = round(glueTemp)
					}
				}
				tex.ruleHt = tex.ruleHt + curG
				if tex.mem[p].hh().b1() >= 100 {
					leaderBox = tex.mem[int32(p)+1].hh().rh
					if tex.mem[leaderBox].hh().b0() == 2 {
						tex.ruleWd = tex.mem[int32(leaderBox)+1].int()
						tex.ruleDp = 0
						goto label14
					}
					leaderHt = tex.mem[int32(leaderBox)+3].int() + tex.mem[int32(leaderBox)+2].int()
					if (leaderHt > 0) && (tex.ruleHt > 0) {
						tex.ruleHt = tex.ruleHt + 10
						edge = tex.curV + tex.ruleHt
						lx = 0
						if tex.mem[p].hh().b1() == 100 {
							saveV = tex.curV
							tex.curV = topEdge + (leaderHt * ((tex.curV - topEdge) / leaderHt))
							if tex.curV < saveV {
								tex.curV = tex.curV + leaderHt
							}
						} else {
							tex.lq = (tex.ruleHt / leaderHt)
							tex.lr = (tex.ruleHt % leaderHt)
							if tex.mem[p].hh().b1() == 101 {
								tex.curV = tex.curV + (tex.lr / 2)
							} else {
								lx = (tex.lr / (tex.lq + 1))
								tex.curV = tex.curV + ((tex.lr - ((tex.lq - 1) * lx)) / 2)
							}
						}
						for tex.curV+leaderHt <= edge {
							tex.curH = leftEdge + tex.mem[int32(leaderBox)+4].int()
							if tex.curH != tex.dviH {
								tex.movement(tex.curH-tex.dviH, 143)
								tex.dviH = tex.curH
							}
							saveH = tex.dviH
							tex.curV = tex.curV + tex.mem[int32(leaderBox)+3].int()
							if tex.curV != tex.dviV {
								tex.movement(tex.curV-tex.dviV, 157)
								tex.dviV = tex.curV
							}
							saveV = tex.dviV
							tex.tempPtr = leaderBox
							outerDoingLeaders = tex.doingLeaders
							tex.doingLeaders = true
							if tex.mem[leaderBox].hh().b0() == 1 {
								tex.vlistOut()
							} else {
								tex.hlistOut()
							}
							tex.doingLeaders = outerDoingLeaders
							tex.dviV = saveV
							tex.dviH = saveH
							tex.curH = leftEdge
							tex.curV = saveV - tex.mem[int32(leaderBox)+3].int() + leaderHt + lx
						}
						tex.curV = edge - 10
						goto label15
					}
				}
				goto label13
			case 11:
				tex.curV = tex.curV + tex.mem[int32(p)+1].int()
			default:
			}
			goto label15
		label14:
			if tex.ruleWd == -1073741824 {
				tex.ruleWd = tex.mem[int32(thisBox)+1].int()
			}
			tex.ruleHt = tex.ruleHt + tex.ruleDp
			tex.curV = tex.curV + tex.ruleHt
			if (tex.ruleHt > 0) && (tex.ruleWd > 0) {
				if tex.curH != tex.dviH {
					tex.movement(tex.curH-tex.dviH, 143)
					tex.dviH = tex.curH
				}
				if tex.curV != tex.dviV {
					tex.movement(tex.curV-tex.dviV, 157)
					tex.dviV = tex.curV
				}
				tex.dviBuf[tex.dviPtr] = 137
				tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
				if tex.dviPtr == tex.dviLimit {
					tex.dviSwap()
				}
				tex.dviFour(tex.ruleHt)
				tex.dviFour(tex.ruleWd)
			}
			goto label15
		label13:
			tex.curV = tex.curV + tex.ruleHt
		}
	label15:
		p = tex.mem[p].hh().rh
	}
	tex.pruneMovements(saveLoc)
	if tex.curS > 0 {
		tex.dviPop(saveLoc)
	}
	tex.curS = tex.curS - 1
}

func (tex *Context) shipOut(p uint16) {
	var pageLoc int32   // integer
	var j, k byte       // 0..9
	var s uint16        // 0..32000
	var oldSetting byte // 0..21
	if tex.eqtb[5297-1].int() > 0 {
		tex.printNl(338)
		tex.printLn()
		tex.print(829)
	}
	if int32(tex.termOffset) > maxPrintLine-9 {
		tex.printLn()
	} else if (tex.termOffset > 0) || (tex.fileOffset > 0) {
		tex.printChar(32)
	}
	tex.printChar(91)
	j = 9
	for (tex.eqtb[5318+int32(j)-1].int() == 0) && (j > 0) {
		j = byte(int32(j) - 1)
	}
	for _i := int64(0); _i <= int64(j); _i++ {
		k = byte(_i)
		tex.printInt(tex.eqtb[5318+int32(k)-1].int())
		if k < j {
			tex.printChar(46)
		}
	}
	break1(&tex.termOut)
	if tex.eqtb[5297-1].int() > 0 {
		tex.printChar(93)
		tex.beginDiagnostic()
		tex.showBox(p)
		tex.endDiagnostic(true)
	}
	if (tex.mem[int32(p)+3].int() > 1073741823) || (tex.mem[int32(p)+2].int() > 1073741823) || ((tex.mem[int32(p)+3].int() + tex.mem[int32(p)+2].int() + tex.eqtb[5849-1].int()) > 1073741823) || ((tex.mem[int32(p)+1].int() + tex.eqtb[5848-1].int()) > 1073741823) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(833)
		tex.helpPtr = 2
		tex.helpLine[1] = 834
		tex.helpLine[0] = 835
		tex.error1()
		if tex.eqtb[5297-1].int() <= 0 {
			tex.beginDiagnostic()
			tex.printNl(836)
			tex.showBox(p)
			tex.endDiagnostic(true)
		}
		goto label30
	}
	if tex.mem[int32(p)+3].int()+tex.mem[int32(p)+2].int()+tex.eqtb[5849-1].int() > tex.maxV {
		tex.maxV = tex.mem[int32(p)+3].int() + tex.mem[int32(p)+2].int() + tex.eqtb[5849-1].int()
	}
	if tex.mem[int32(p)+1].int()+tex.eqtb[5848-1].int() > tex.maxH {
		tex.maxH = tex.mem[int32(p)+1].int() + tex.eqtb[5848-1].int()
	}
	tex.dviH = 0
	tex.dviV = 0
	tex.curH = tex.eqtb[5848-1].int()
	tex.dviF = 0
	if tex.outputFileName == 0 {
		if tex.jobName == 0 {
			tex.openLogFile()
		}
		tex.packJobName(794)
		for !tex.bOpenOut(&tex.dviFile) {
			tex.promptFileName(795, 794)
		}
		tex.outputFileName = tex.bMakeNameString(&tex.dviFile)
	}
	if tex.totalPages == 0 {
		tex.dviBuf[tex.dviPtr] = 247
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviBuf[tex.dviPtr] = 2
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviFour(25400000)
		tex.dviFour(473628672)
		tex.prepareMag()
		tex.dviFour(tex.eqtb[5280-1].int())
		oldSetting = tex.selector
		tex.selector = 21
		tex.print(827)
		tex.printInt(tex.eqtb[5286-1].int())
		tex.printChar(46)
		tex.printTwo(tex.eqtb[5285-1].int())
		tex.printChar(46)
		tex.printTwo(tex.eqtb[5284-1].int())
		tex.printChar(58)
		tex.printTwo((tex.eqtb[5283-1].int() / 60))
		tex.printTwo((tex.eqtb[5283-1].int() % 60))
		tex.selector = oldSetting
		tex.dviBuf[tex.dviPtr] = byte((int32(tex.poolPtr) - int32(tex.strStart[tex.strPtr])))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		for _i := int64(tex.strStart[tex.strPtr]); _i <= int64(int32(tex.poolPtr)-1); _i++ {
			s = uint16(_i)
			tex.dviBuf[tex.dviPtr] = tex.strPool[s]
			tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
			if tex.dviPtr == tex.dviLimit {
				tex.dviSwap()
			}
		}
		tex.poolPtr = tex.strStart[tex.strPtr]
	}
	pageLoc = tex.dviOffset + int32(tex.dviPtr)
	tex.dviBuf[tex.dviPtr] = 139
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	for _i := int64(0); _i <= int64(9); _i++ {
		k = byte(_i)
		tex.dviFour(tex.eqtb[5318+int32(k)-1].int())
	}
	tex.dviFour(tex.lastBop)
	tex.lastBop = pageLoc
	tex.curV = tex.mem[int32(p)+3].int() + tex.eqtb[5849-1].int()
	tex.tempPtr = p
	if tex.mem[p].hh().b0() == 1 {
		tex.vlistOut()
	} else {
		tex.hlistOut()
	}
	tex.dviBuf[tex.dviPtr] = 140
	tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
	if tex.dviPtr == tex.dviLimit {
		tex.dviSwap()
	}
	tex.totalPages = tex.totalPages + 1
	tex.curS = -1
label30:
	if tex.eqtb[5297-1].int() <= 0 {
		tex.printChar(93)
	}
	tex.deadCycles = 0
	break1(&tex.termOut)
	tex.flushNodeList(p)
}

func (tex *Context) scanSpec(c byte, threeCodes bool) {
	var s int32       // integer
	var specCode byte // 0..1
	if threeCodes {
		s = tex.saveStack[int32(tex.savePtr)+0].int()
	}
	if tex.scanKeyword(842) {
		specCode = 0
	} else if tex.scanKeyword(843) {
		specCode = 1
	} else {
		specCode = 1
		tex.curVal = 0
		goto label40
	}
	tex.scanDimen(false, false, false)
label40:
	if threeCodes {
		*tex.saveStack[int32(tex.savePtr)+0].pInt() = s
		tex.savePtr = uint16(int32(tex.savePtr) + 1)
	}
	*tex.saveStack[int32(tex.savePtr)+0].pInt() = int32(specCode)
	*tex.saveStack[int32(tex.savePtr)+1].pInt() = tex.curVal
	tex.savePtr = uint16(int32(tex.savePtr) + 2)
	tex.newSaveLevel(c)
	tex.scanLeftBrace()
}

func (tex *Context) hpack(p uint16, w int32, m byte) (ret uint16) {
	var r uint16       // 0..65535
	var q uint16       // 0..65535
	var h, d, x int32  // integer
	var s int32        // integer
	var g uint16       // 0..65535
	var o byte         // 0..3
	var f byte         // 0..75
	var i fourQuarters // record fourQuarters
	var hd byte        // 0..255
	tex.lastBadness = 0
	r = tex.getNode(7)
	*tex.mem[r].pHh().pB0() = 0
	*tex.mem[r].pHh().pB1() = 0
	*tex.mem[int32(r)+4].pInt() = 0
	q = uint16(int32(r) + 5)
	tex.mem[q].pHh().rh = p
	h = 0
	d = 0
	x = 0
	tex.totalStretch[0] = 0
	tex.totalShrink[0] = 0
	tex.totalStretch[1] = 0
	tex.totalShrink[1] = 0
	tex.totalStretch[2] = 0
	tex.totalShrink[2] = 0
	tex.totalStretch[3] = 0
	tex.totalShrink[3] = 0
	for p != 0 {
	label21:
		for p >= tex.hiMemMin {
			f = tex.mem[p].hh().b0()
			i = tex.fontInfo[tex.charBase[f]+int32(tex.mem[p].hh().b1())].qqqq()
			hd = byte(int32(i.b1) - 0)
			x = x + tex.fontInfo[tex.widthBase[f]+int32(i.b0)].int()
			s = tex.fontInfo[tex.heightBase[f]+(int32(hd)/16)].int()
			if s > h {
				h = s
			}
			s = tex.fontInfo[tex.depthBase[f]+(int32(hd)%16)].int()
			if s > d {
				d = s
			}
			p = tex.mem[p].hh().rh
		}
		if p != 0 {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 2, 13:
				x = x + tex.mem[int32(p)+1].int()
				if tex.mem[p].hh().b0() >= 2 {
					s = 0
				} else {
					s = tex.mem[int32(p)+4].int()
				}
				if tex.mem[int32(p)+3].int()-s > h {
					h = tex.mem[int32(p)+3].int() - s
				}
				if tex.mem[int32(p)+2].int()+s > d {
					d = tex.mem[int32(p)+2].int() + s
				}
			case 3, 4, 5:
				if tex.adjustTail != 0 {
					for tex.mem[q].hh().rh != p {
						q = tex.mem[q].hh().rh
					}
					if tex.mem[p].hh().b0() == 5 {
						tex.mem[tex.adjustTail].pHh().rh = uint16(tex.mem[int32(p)+1].int())
						for tex.mem[tex.adjustTail].hh().rh != 0 {
							tex.adjustTail = tex.mem[tex.adjustTail].hh().rh
						}
						p = tex.mem[p].hh().rh
						tex.freeNode(tex.mem[q].hh().rh, 2)
					} else {
						tex.mem[tex.adjustTail].pHh().rh = p
						tex.adjustTail = p
						p = tex.mem[p].hh().rh
					}
					tex.mem[q].pHh().rh = p
					p = q
				}
			case 8:
			case 10:
				g = tex.mem[int32(p)+1].hh().lh()
				x = x + tex.mem[int32(g)+1].int()
				o = tex.mem[g].hh().b0()
				tex.totalStretch[o] = tex.totalStretch[o] + tex.mem[int32(g)+2].int()
				o = tex.mem[g].hh().b1()
				tex.totalShrink[o] = tex.totalShrink[o] + tex.mem[int32(g)+3].int()
				if tex.mem[p].hh().b1() >= 100 {
					g = tex.mem[int32(p)+1].hh().rh
					if tex.mem[int32(g)+3].int() > h {
						h = tex.mem[int32(g)+3].int()
					}
					if tex.mem[int32(g)+2].int() > d {
						d = tex.mem[int32(g)+2].int()
					}
				}
			case 11, 9:
				x = x + tex.mem[int32(p)+1].int()
			case 6:
				tex.mem[29988] = tex.mem[int32(p)+1]
				tex.mem[29988].pHh().rh = tex.mem[p].hh().rh
				p = 29988
				goto label21
			default:
			}
			p = tex.mem[p].hh().rh
		}
	}
	if tex.adjustTail != 0 {
		tex.mem[tex.adjustTail].pHh().rh = 0
	}
	*tex.mem[int32(r)+3].pInt() = h
	*tex.mem[int32(r)+2].pInt() = d
	if m == 1 {
		w = x + w
	}
	*tex.mem[int32(r)+1].pInt() = w
	x = w - x
	if x == 0 {
		*tex.mem[int32(r)+5].pHh().pB0() = 0
		*tex.mem[int32(r)+5].pHh().pB1() = 0
		*tex.mem[int32(r)+6].pGr() = 0
		goto label10
	} else if x > 0 {
		if tex.totalStretch[3] != 0 {
			o = 3
		} else if tex.totalStretch[2] != 0 {
			o = 2
		} else if tex.totalStretch[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(r)+5].pHh().pB1() = o
		*tex.mem[int32(r)+5].pHh().pB0() = 1
		if tex.totalStretch[o] != 0 {
			*tex.mem[int32(r)+6].pGr() = (float32(x) / float32(tex.totalStretch[o]))
		} else {
			*tex.mem[int32(r)+5].pHh().pB0() = 0
			*tex.mem[int32(r)+6].pGr() = 0
		}
		if o == 0 {
			if tex.mem[int32(r)+5].hh().rh != 0 {
				tex.lastBadness = int32(tex.badness(x, tex.totalStretch[0]))
				if tex.lastBadness > tex.eqtb[5289-1].int() {
					tex.printLn()
					if tex.lastBadness > 100 {
						tex.printNl(844)
					} else {
						tex.printNl(845)
					}
					tex.print(846)
					tex.printInt(tex.lastBadness)
					goto label50
				}
			}
		}
		goto label10
	} else {
		if tex.totalShrink[3] != 0 {
			o = 3
		} else if tex.totalShrink[2] != 0 {
			o = 2
		} else if tex.totalShrink[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(r)+5].pHh().pB1() = o
		*tex.mem[int32(r)+5].pHh().pB0() = 2
		if tex.totalShrink[o] != 0 {
			*tex.mem[int32(r)+6].pGr() = (float32(-x) / float32(tex.totalShrink[o]))
		} else {
			*tex.mem[int32(r)+5].pHh().pB0() = 0
			*tex.mem[int32(r)+6].pGr() = 0
		}
		if (tex.totalShrink[o] < -x) && (o == 0) && (tex.mem[int32(r)+5].hh().rh != 0) {
			tex.lastBadness = 1000000
			*tex.mem[int32(r)+6].pGr() = 1
			if ((-x - tex.totalShrink[0]) > tex.eqtb[5838-1].int()) || (tex.eqtb[5289-1].int() < 100) {
				if (tex.eqtb[5846-1].int() > 0) && ((-x - tex.totalShrink[0]) > tex.eqtb[5838-1].int()) {
					for tex.mem[q].hh().rh != 0 {
						q = tex.mem[q].hh().rh
					}
					tex.mem[q].pHh().rh = tex.newRule()
					*tex.mem[int32(tex.mem[q].hh().rh)+1].pInt() = tex.eqtb[5846-1].int()
				}
				tex.printLn()
				tex.printNl(852)
				tex.printScaled(-x - tex.totalShrink[0])
				tex.print(853)
				goto label50
			}
		} else if o == 0 {
			if tex.mem[int32(r)+5].hh().rh != 0 {
				tex.lastBadness = int32(tex.badness(-x, tex.totalShrink[0]))
				if tex.lastBadness > tex.eqtb[5289-1].int() {
					tex.printLn()
					tex.printNl(854)
					tex.printInt(tex.lastBadness)
					goto label50
				}
			}
		}
		goto label10
	}
label50:
	if tex.outputActive {
		tex.print(847)
	} else {
		if tex.packBeginLine != 0 {
			if tex.packBeginLine > 0 {
				tex.print(848)
			} else {
				tex.print(849)
			}
			tex.printInt(iabs(tex.packBeginLine))
			tex.print(850)
		} else {
			tex.print(851)
		}
		tex.printInt(tex.line)
	}
	tex.printLn()
	tex.fontInShortDisplay = 0
	tex.shortDisplay(int32(tex.mem[int32(r)+5].hh().rh))
	tex.printLn()
	tex.beginDiagnostic()
	tex.showBox(r)
	tex.endDiagnostic(true)
label10:
	ret = r
	return ret
}

func (tex *Context) vpackage(p uint16, h int32, m byte, l int32) (ret uint16) {
	var r uint16      // 0..65535
	var w, d, x int32 // integer
	var s int32       // integer
	var g uint16      // 0..65535
	var o byte        // 0..3
	tex.lastBadness = 0
	r = tex.getNode(7)
	*tex.mem[r].pHh().pB0() = 1
	*tex.mem[r].pHh().pB1() = 0
	*tex.mem[int32(r)+4].pInt() = 0
	tex.mem[int32(r)+5].pHh().rh = p
	w = 0
	d = 0
	x = 0
	tex.totalStretch[0] = 0
	tex.totalShrink[0] = 0
	tex.totalStretch[1] = 0
	tex.totalShrink[1] = 0
	tex.totalStretch[2] = 0
	tex.totalShrink[2] = 0
	tex.totalStretch[3] = 0
	tex.totalShrink[3] = 0
	for p != 0 {
		if p >= tex.hiMemMin {
			tex.confusion(855)
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 2, 13:
				x = x + d + tex.mem[int32(p)+3].int()
				d = tex.mem[int32(p)+2].int()
				if tex.mem[p].hh().b0() >= 2 {
					s = 0
				} else {
					s = tex.mem[int32(p)+4].int()
				}
				if tex.mem[int32(p)+1].int()+s > w {
					w = tex.mem[int32(p)+1].int() + s
				}
			case 8:
			case 10:
				x = x + d
				d = 0
				g = tex.mem[int32(p)+1].hh().lh()
				x = x + tex.mem[int32(g)+1].int()
				o = tex.mem[g].hh().b0()
				tex.totalStretch[o] = tex.totalStretch[o] + tex.mem[int32(g)+2].int()
				o = tex.mem[g].hh().b1()
				tex.totalShrink[o] = tex.totalShrink[o] + tex.mem[int32(g)+3].int()
				if tex.mem[p].hh().b1() >= 100 {
					g = tex.mem[int32(p)+1].hh().rh
					if tex.mem[int32(g)+1].int() > w {
						w = tex.mem[int32(g)+1].int()
					}
				}
			case 11:
				x = x + d + tex.mem[int32(p)+1].int()
				d = 0
			default:
			}
		}
		p = tex.mem[p].hh().rh
	}
	*tex.mem[int32(r)+1].pInt() = w
	if d > l {
		x = x + d - l
		*tex.mem[int32(r)+2].pInt() = l
	} else {
		*tex.mem[int32(r)+2].pInt() = d
	}
	if m == 1 {
		h = x + h
	}
	*tex.mem[int32(r)+3].pInt() = h
	x = h - x
	if x == 0 {
		*tex.mem[int32(r)+5].pHh().pB0() = 0
		*tex.mem[int32(r)+5].pHh().pB1() = 0
		*tex.mem[int32(r)+6].pGr() = 0
		goto label10
	} else if x > 0 {
		if tex.totalStretch[3] != 0 {
			o = 3
		} else if tex.totalStretch[2] != 0 {
			o = 2
		} else if tex.totalStretch[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(r)+5].pHh().pB1() = o
		*tex.mem[int32(r)+5].pHh().pB0() = 1
		if tex.totalStretch[o] != 0 {
			*tex.mem[int32(r)+6].pGr() = (float32(x) / float32(tex.totalStretch[o]))
		} else {
			*tex.mem[int32(r)+5].pHh().pB0() = 0
			*tex.mem[int32(r)+6].pGr() = 0
		}
		if o == 0 {
			if tex.mem[int32(r)+5].hh().rh != 0 {
				tex.lastBadness = int32(tex.badness(x, tex.totalStretch[0]))
				if tex.lastBadness > tex.eqtb[5290-1].int() {
					tex.printLn()
					if tex.lastBadness > 100 {
						tex.printNl(844)
					} else {
						tex.printNl(845)
					}
					tex.print(856)
					tex.printInt(tex.lastBadness)
					goto label50
				}
			}
		}
		goto label10
	} else {
		if tex.totalShrink[3] != 0 {
			o = 3
		} else if tex.totalShrink[2] != 0 {
			o = 2
		} else if tex.totalShrink[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(r)+5].pHh().pB1() = o
		*tex.mem[int32(r)+5].pHh().pB0() = 2
		if tex.totalShrink[o] != 0 {
			*tex.mem[int32(r)+6].pGr() = (float32(-x) / float32(tex.totalShrink[o]))
		} else {
			*tex.mem[int32(r)+5].pHh().pB0() = 0
			*tex.mem[int32(r)+6].pGr() = 0
		}
		if (tex.totalShrink[o] < -x) && (o == 0) && (tex.mem[int32(r)+5].hh().rh != 0) {
			tex.lastBadness = 1000000
			*tex.mem[int32(r)+6].pGr() = 1
			if ((-x - tex.totalShrink[0]) > tex.eqtb[5839-1].int()) || (tex.eqtb[5290-1].int() < 100) {
				tex.printLn()
				tex.printNl(857)
				tex.printScaled(-x - tex.totalShrink[0])
				tex.print(858)
				goto label50
			}
		} else if o == 0 {
			if tex.mem[int32(r)+5].hh().rh != 0 {
				tex.lastBadness = int32(tex.badness(-x, tex.totalShrink[0]))
				if tex.lastBadness > tex.eqtb[5290-1].int() {
					tex.printLn()
					tex.printNl(859)
					tex.printInt(tex.lastBadness)
					goto label50
				}
			}
		}
		goto label10
	}
label50:
	if tex.outputActive {
		tex.print(847)
	} else {
		if tex.packBeginLine != 0 {
			tex.print(849)
			tex.printInt(iabs(tex.packBeginLine))
			tex.print(850)
		} else {
			tex.print(851)
		}
		tex.printInt(tex.line)
		tex.printLn()
	}
	tex.beginDiagnostic()
	tex.showBox(r)
	tex.endDiagnostic(true)
label10:
	ret = r
	return ret
}

func (tex *Context) appendToVlist(b uint16) {
	var d int32  // integer
	var p uint16 // 0..65535
	if tex.curList.auxField.int() > -65536000 {
		d = tex.mem[int32(tex.eqtb[2883-1].hh().rh)+1].int() - tex.curList.auxField.int() - tex.mem[int32(b)+3].int()
		if d < tex.eqtb[5832-1].int() {
			p = tex.newParamGlue(0)
		} else {
			p = tex.newSkipParam(1)
			*tex.mem[int32(tex.tempPtr)+1].pInt() = d
		}
		tex.mem[tex.curList.tailField].pHh().rh = p
		tex.curList.tailField = p
	}
	tex.mem[tex.curList.tailField].pHh().rh = b
	tex.curList.tailField = b
	*tex.curList.auxField.pInt() = tex.mem[int32(b)+2].int()
}

func (tex *Context) newNoad() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(4)
	*tex.mem[p].pHh().pB0() = 16
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pHh() = tex.emptyField
	*tex.mem[int32(p)+3].pHh() = tex.emptyField
	*tex.mem[int32(p)+2].pHh() = tex.emptyField
	ret = p
	return ret
}

func (tex *Context) newStyle(s byte) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(3)
	*tex.mem[p].pHh().pB0() = 14
	*tex.mem[p].pHh().pB1() = s
	*tex.mem[int32(p)+1].pInt() = 0
	*tex.mem[int32(p)+2].pInt() = 0
	ret = p
	return ret
}

func (tex *Context) newChoice() (ret uint16) {
	var p uint16 // 0..65535
	p = tex.getNode(3)
	*tex.mem[p].pHh().pB0() = 15
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pHh().pLh() = 0
	tex.mem[int32(p)+1].pHh().rh = 0
	*tex.mem[int32(p)+2].pHh().pLh() = 0
	tex.mem[int32(p)+2].pHh().rh = 0
	ret = p
	return ret
}

func (tex *Context) showInfo() {
	tex.showNodeList(int32(tex.mem[tex.tempPtr].hh().lh()))
}

func (tex *Context) fractionRule(t int32) (ret uint16) {
	var p uint16 // 0..65535
	p = tex.newRule()
	*tex.mem[int32(p)+3].pInt() = t
	*tex.mem[int32(p)+2].pInt() = 0
	ret = p
	return ret
}

func (tex *Context) overbar(b uint16, k, t int32) (ret uint16) {
	var p, q uint16 // 0..65535
	p = tex.newKern(k)
	tex.mem[p].pHh().rh = b
	q = tex.fractionRule(t)
	tex.mem[q].pHh().rh = p
	p = tex.newKern(t)
	tex.mem[p].pHh().rh = q
	ret = tex.vpackage(p, 0, 1, 1073741823)
	return ret
}

func (tex *Context) charBox(f byte, c byte) (ret uint16) {
	var q fourQuarters // record fourQuarters
	var hd byte        // 0..255
	var b, p uint16    // 0..65535
	q = tex.fontInfo[tex.charBase[f]+int32(c)].qqqq()
	hd = byte(int32(q.b1) - 0)
	b = tex.newNullBox()
	*tex.mem[int32(b)+1].pInt() = tex.fontInfo[tex.widthBase[f]+int32(q.b0)].int() + tex.fontInfo[tex.italicBase[f]+((int32(q.b2)-0)/4)].int()
	*tex.mem[int32(b)+3].pInt() = tex.fontInfo[tex.heightBase[f]+(int32(hd)/16)].int()
	*tex.mem[int32(b)+2].pInt() = tex.fontInfo[tex.depthBase[f]+(int32(hd)%16)].int()
	p = tex.getAvail()
	*tex.mem[p].pHh().pB1() = c
	*tex.mem[p].pHh().pB0() = f
	tex.mem[int32(b)+5].pHh().rh = p
	ret = b
	return ret
}

func (tex *Context) stackIntoBox(b uint16, f byte, c byte) {
	var p uint16 // 0..65535
	p = tex.charBox(f, c)
	tex.mem[p].pHh().rh = tex.mem[int32(b)+5].hh().rh
	tex.mem[int32(b)+5].pHh().rh = p
	*tex.mem[int32(b)+3].pInt() = tex.mem[int32(p)+3].int()
}

func (tex *Context) heightPlusDepth(f byte, c byte) (ret int32) {
	var q fourQuarters // record fourQuarters
	var hd byte        // 0..255
	q = tex.fontInfo[tex.charBase[f]+int32(c)].qqqq()
	hd = byte(int32(q.b1) - 0)
	ret = tex.fontInfo[tex.heightBase[f]+(int32(hd)/16)].int() + tex.fontInfo[tex.depthBase[f]+(int32(hd)%16)].int()
	return ret
}

func (tex *Context) varDelimiter(d uint16, s byte, v int32) (ret uint16) {
	var b uint16          // 0..65535
	var f, g byte         // 0..75
	var c, x, y byte      // 0..255
	var n int32           // integer
	var u int32           // integer
	var w int32           // integer
	var q fourQuarters    // record fourQuarters
	var hd byte           // 0..255
	var r fourQuarters    // record fourQuarters
	var z byte            // 0..63
	var largeAttempt bool // boolean
	f = 0
	w = 0
	largeAttempt = false
	z = tex.mem[d].qqqq().b0
	x = tex.mem[d].qqqq().b1
	for true {
		if (z != 0) || (x != 0) {
			z = byte(int32(z) + int32(s) + 16)
			for {
				z = byte(int32(z) - 16)
				g = byte(tex.eqtb[3935+int32(z)-1].hh().rh)
				if g != 0 {
					y = x
					if ((int32(y) - 0) >= int32(tex.fontBc[g])) && ((int32(y) - 0) <= int32(tex.fontEc[g])) {
					label22:
						q = tex.fontInfo[tex.charBase[g]+int32(y)].qqqq()
						if q.b0 > 0 {
							if ((int32(q.b2) - 0) % 4) == 3 {
								f = g
								c = y
								goto label40
							}
							hd = byte(int32(q.b1) - 0)
							u = tex.fontInfo[tex.heightBase[g]+(int32(hd)/16)].int() + tex.fontInfo[tex.depthBase[g]+(int32(hd)%16)].int()
							if u > w {
								f = g
								c = y
								w = u
								if u >= v {
									goto label40
								}
							}
							if ((int32(q.b2) - 0) % 4) == 2 {
								y = q.b3
								goto label22
							}
						}
					}
				}
				if z < 16 {
					break
				}
			}
		}
		if largeAttempt {
			goto label40
		}
		largeAttempt = true
		z = tex.mem[d].qqqq().b2
		x = tex.mem[d].qqqq().b3
	}
label40:
	if f != 0 {
		if ((int32(q.b2) - 0) % 4) == 3 {
			b = tex.newNullBox()
			*tex.mem[b].pHh().pB0() = 1
			r = tex.fontInfo[tex.extenBase[f]+int32(q.b3)].qqqq()
			c = r.b3
			u = tex.heightPlusDepth(f, c)
			w = 0
			q = tex.fontInfo[tex.charBase[f]+int32(c)].qqqq()
			*tex.mem[int32(b)+1].pInt() = tex.fontInfo[tex.widthBase[f]+int32(q.b0)].int() + tex.fontInfo[tex.italicBase[f]+((int32(q.b2)-0)/4)].int()
			c = r.b2
			if c != 0 {
				w = w + tex.heightPlusDepth(f, c)
			}
			c = r.b1
			if c != 0 {
				w = w + tex.heightPlusDepth(f, c)
			}
			c = r.b0
			if c != 0 {
				w = w + tex.heightPlusDepth(f, c)
			}
			n = 0
			if u > 0 {
				for w < v {
					w = w + u
					n = n + 1
					if r.b1 != 0 {
						w = w + u
					}
				}
			}
			c = r.b2
			if c != 0 {
				tex.stackIntoBox(b, f, c)
			}
			c = r.b3
			for _i := int64(1); _i <= int64(n); _i++ {
				tex.stackIntoBox(b, f, c)
			}
			c = r.b1
			if c != 0 {
				tex.stackIntoBox(b, f, c)
				c = r.b3
				for _i := int64(1); _i <= int64(n); _i++ {
					tex.stackIntoBox(b, f, c)
				}
			}
			c = r.b0
			if c != 0 {
				tex.stackIntoBox(b, f, c)
			}
			*tex.mem[int32(b)+2].pInt() = w - tex.mem[int32(b)+3].int()
		} else {
			b = tex.charBox(f, c)
		}
	} else {
		b = tex.newNullBox()
		*tex.mem[int32(b)+1].pInt() = tex.eqtb[5841-1].int()
	}
	*tex.mem[int32(b)+4].pInt() = tex.half(tex.mem[int32(b)+3].int()-tex.mem[int32(b)+2].int()) - tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(s)-1].hh().rh]].int()
	ret = b
	return ret
}

func (tex *Context) rebox(b uint16, w int32) (ret uint16) {
	var p uint16 // 0..65535
	var f byte   // 0..75
	var v int32  // integer
	if (tex.mem[int32(b)+1].int() != w) && (tex.mem[int32(b)+5].hh().rh != 0) {
		if tex.mem[b].hh().b0() == 1 {
			b = tex.hpack(b, 0, 1)
		}
		p = tex.mem[int32(b)+5].hh().rh
		if (p >= tex.hiMemMin) && (tex.mem[p].hh().rh == 0) {
			f = tex.mem[p].hh().b0()
			v = tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[p].hh().b1())].qqqq().b0)].int()
			if v != tex.mem[int32(b)+1].int() {
				tex.mem[p].pHh().rh = tex.newKern(tex.mem[int32(b)+1].int() - v)
			}
		}
		tex.freeNode(b, 7)
		b = tex.newGlue(12)
		tex.mem[b].pHh().rh = p
		for tex.mem[p].hh().rh != 0 {
			p = tex.mem[p].hh().rh
		}
		tex.mem[p].pHh().rh = tex.newGlue(12)
		ret = tex.hpack(b, w, 0)
	} else {
		*tex.mem[int32(b)+1].pInt() = w
		ret = b
	}
	return ret
}

func (tex *Context) mathGlue(g uint16, m int32) (ret uint16) {
	var p uint16 // 0..65535
	var n int32  // integer
	var f int32  // integer
	n = tex.xOverN(m, 65536)
	f = tex.remainder
	if f < 0 {
		n = n - 1
		f = f + 65536
	}
	p = tex.getNode(4)
	*tex.mem[int32(p)+1].pInt() = tex.multAndAdd(n, tex.mem[int32(g)+1].int(), tex.xnOverD(tex.mem[int32(g)+1].int(), f, 65536), 1073741823)
	*tex.mem[p].pHh().pB0() = tex.mem[g].hh().b0()
	if tex.mem[p].hh().b0() == 0 {
		*tex.mem[int32(p)+2].pInt() = tex.multAndAdd(n, tex.mem[int32(g)+2].int(), tex.xnOverD(tex.mem[int32(g)+2].int(), f, 65536), 1073741823)
	} else {
		*tex.mem[int32(p)+2].pInt() = tex.mem[int32(g)+2].int()
	}
	*tex.mem[p].pHh().pB1() = tex.mem[g].hh().b1()
	if tex.mem[p].hh().b1() == 0 {
		*tex.mem[int32(p)+3].pInt() = tex.multAndAdd(n, tex.mem[int32(g)+3].int(), tex.xnOverD(tex.mem[int32(g)+3].int(), f, 65536), 1073741823)
	} else {
		*tex.mem[int32(p)+3].pInt() = tex.mem[int32(g)+3].int()
	}
	ret = p
	return ret
}

func (tex *Context) mathKern(p uint16, m int32) {
	var n int32 // integer
	var f int32 // integer
	if tex.mem[p].hh().b1() == 99 {
		n = tex.xOverN(m, 65536)
		f = tex.remainder
		if f < 0 {
			n = n - 1
			f = f + 65536
		}
		*tex.mem[int32(p)+1].pInt() = tex.multAndAdd(n, tex.mem[int32(p)+1].int(), tex.xnOverD(tex.mem[int32(p)+1].int(), f, 65536), 1073741823)
		*tex.mem[p].pHh().pB1() = 1
	}
}

func (tex *Context) flushMath() {
	tex.flushNodeList(tex.mem[tex.curList.headField].hh().rh)
	tex.flushNodeList(uint16(tex.curList.auxField.int()))
	tex.mem[tex.curList.headField].pHh().rh = 0
	tex.curList.tailField = tex.curList.headField
	*tex.curList.auxField.pInt() = 0
}

func (tex *Context) cleanBox(p uint16, s byte) (ret uint16) {
	var q uint16       // 0..65535
	var saveStyle byte // 0..63
	var x uint16       // 0..65535
	var r uint16       // 0..65535
	switch tex.mem[p].hh().rh {
	case 1:
		tex.curMlist = tex.newNoad()
		tex.mem[int32(tex.curMlist)+1] = tex.mem[p]
	case 2:
		q = tex.mem[p].hh().lh()
		goto label40
	case 3:
		tex.curMlist = tex.mem[p].hh().lh()
	default:
		q = tex.newNullBox()
		goto label40
	}
	saveStyle = tex.curStyle
	tex.curStyle = s
	tex.mlistPenalties = false
	tex.mlistToHlist()
	q = tex.mem[29997].hh().rh
	tex.curStyle = saveStyle
	if tex.curStyle < 4 {
		tex.curSize = 0
	} else {
		tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
	}
	tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
label40:
	if (q >= tex.hiMemMin) || (q == 0) {
		x = tex.hpack(q, 0, 1)
	} else if (tex.mem[q].hh().rh == 0) && (tex.mem[q].hh().b0() <= 1) && (tex.mem[int32(q)+4].int() == 0) {
		x = q
	} else {
		x = tex.hpack(q, 0, 1)
	}
	q = tex.mem[int32(x)+5].hh().rh
	if q >= tex.hiMemMin {
		r = tex.mem[q].hh().rh
		if r != 0 {
			if tex.mem[r].hh().rh == 0 {
				if !(r >= tex.hiMemMin) {
					if tex.mem[r].hh().b0() == 11 {
						tex.freeNode(r, 2)
						tex.mem[q].pHh().rh = 0
					}
				}
			}
		}
	}
	ret = x
	return ret
}

func (tex *Context) fetch(a uint16) {
	tex.curC = tex.mem[a].hh().b1()
	tex.curF = byte(tex.eqtb[3935+int32(tex.mem[a].hh().b0())+int32(tex.curSize)-1].hh().rh)
	if tex.curF == 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(338)
		tex.printSize(int32(tex.curSize))
		tex.printChar(32)
		tex.printInt(int32(tex.mem[a].hh().b0()))
		tex.print(884)
		tex.print(int32(tex.curC) - 0)
		tex.printChar(41)
		tex.helpPtr = 4
		tex.helpLine[3] = 885
		tex.helpLine[2] = 886
		tex.helpLine[1] = 887
		tex.helpLine[0] = 888
		tex.error1()
		tex.curI = tex.nullCharacter
		tex.mem[a].pHh().rh = 0
	} else {
		if ((int32(tex.curC) - 0) >= int32(tex.fontBc[tex.curF])) && ((int32(tex.curC) - 0) <= int32(tex.fontEc[tex.curF])) {
			tex.curI = tex.fontInfo[tex.charBase[tex.curF]+int32(tex.curC)].qqqq()
		} else {
			tex.curI = tex.nullCharacter
		}
		if !(tex.curI.b0 > 0) {
			tex.charWarning(tex.curF, byte(int32(tex.curC)-0))
			tex.mem[a].pHh().rh = 0
			tex.curI = tex.nullCharacter
		}
	}
}

func (tex *Context) makeOver(q uint16) {
	*tex.mem[int32(q)+1].pHh().pLh() = tex.overbar(tex.cleanBox(uint16(int32(q)+1), byte((2*(int32(tex.curStyle)/2))+1)), (3 * tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()), tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
	tex.mem[int32(q)+1].pHh().rh = 2
}

func (tex *Context) makeUnder(q uint16) {
	var p, x, y uint16 // 0..65535
	var delta int32    // integer
	x = tex.cleanBox(uint16(int32(q)+1), tex.curStyle)
	p = tex.newKern((3 * tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()))
	tex.mem[x].pHh().rh = p
	tex.mem[p].pHh().rh = tex.fractionRule(tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
	y = tex.vpackage(x, 0, 1, 1073741823)
	delta = tex.mem[int32(y)+3].int() + tex.mem[int32(y)+2].int() + tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()
	*tex.mem[int32(y)+3].pInt() = tex.mem[int32(x)+3].int()
	*tex.mem[int32(y)+2].pInt() = delta - tex.mem[int32(y)+3].int()
	*tex.mem[int32(q)+1].pHh().pLh() = y
	tex.mem[int32(q)+1].pHh().rh = 2
}

func (tex *Context) makeVcenter(q uint16) {
	var v uint16    // 0..65535
	var delta int32 // integer
	v = tex.mem[int32(q)+1].hh().lh()
	if tex.mem[v].hh().b0() != 1 {
		tex.confusion(539)
	}
	delta = tex.mem[int32(v)+3].int() + tex.mem[int32(v)+2].int()
	*tex.mem[int32(v)+3].pInt() = tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() + tex.half(delta)
	*tex.mem[int32(v)+2].pInt() = delta - tex.mem[int32(v)+3].int()
}

func (tex *Context) makeRadical(q uint16) {
	var x, y uint16      // 0..65535
	var delta, clr int32 // integer
	x = tex.cleanBox(uint16(int32(q)+1), byte((2*(int32(tex.curStyle)/2))+1))
	if tex.curStyle < 2 {
		clr = tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() + (iabs(tex.fontInfo[5+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()) / 4)
	} else {
		clr = tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()
		clr = clr + (iabs(clr) / 4)
	}
	y = tex.varDelimiter(uint16(int32(q)+4), tex.curSize, tex.mem[int32(x)+3].int()+tex.mem[int32(x)+2].int()+clr+tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
	delta = tex.mem[int32(y)+2].int() - (tex.mem[int32(x)+3].int() + tex.mem[int32(x)+2].int() + clr)
	if delta > 0 {
		clr = clr + tex.half(delta)
	}
	*tex.mem[int32(y)+4].pInt() = -(tex.mem[int32(x)+3].int() + clr)
	tex.mem[y].pHh().rh = tex.overbar(x, clr, tex.mem[int32(y)+3].int())
	*tex.mem[int32(q)+1].pHh().pLh() = tex.hpack(y, 0, 1)
	tex.mem[int32(q)+1].pHh().rh = 2
}

func (tex *Context) makeMathAccent(q uint16) {
	var p, x, y uint16 // 0..65535
	var a int32        // integer
	var c byte         // 0..255
	var f byte         // 0..75
	var i fourQuarters // record fourQuarters
	var s int32        // integer
	var h int32        // integer
	var delta int32    // integer
	var w int32        // integer
	tex.fetch(uint16(int32(q) + 4))
	if tex.curI.b0 > 0 {
		i = tex.curI
		c = tex.curC
		f = tex.curF
		s = 0
		if tex.mem[int32(q)+1].hh().rh == 1 {
			tex.fetch(uint16(int32(q) + 1))
			if ((int32(tex.curI.b2) - 0) % 4) == 1 {
				a = tex.ligKernBase[tex.curF] + int32(tex.curI.b3)
				tex.curI = tex.fontInfo[a].qqqq()
				if tex.curI.b0 > 128 {
					a = tex.ligKernBase[tex.curF] + (256 * int32(tex.curI.b2)) + int32(tex.curI.b3) + 32768 - (256 * 128)
					tex.curI = tex.fontInfo[a].qqqq()
				}
				for true {
					if int32(tex.curI.b1)-0 == tex.skewChar[tex.curF] {
						if tex.curI.b2 >= 128 {
							if tex.curI.b0 <= 128 {
								s = tex.fontInfo[tex.kernBase[tex.curF]+(256*int32(tex.curI.b2))+int32(tex.curI.b3)].int()
							}
						}
						goto label31
					}
					if tex.curI.b0 >= 128 {
						goto label31
					}
					a = a + int32(tex.curI.b0) + 1
					tex.curI = tex.fontInfo[a].qqqq()
				}
			}
		}
	label31:
		x = tex.cleanBox(uint16(int32(q)+1), byte((2*(int32(tex.curStyle)/2))+1))
		w = tex.mem[int32(x)+1].int()
		h = tex.mem[int32(x)+3].int()
		for true {
			if ((int32(i.b2) - 0) % 4) != 2 {
				goto label30
			}
			y = uint16(i.b3)
			i = tex.fontInfo[tex.charBase[f]+int32(y)].qqqq()
			if !(i.b0 > 0) {
				goto label30
			}
			if tex.fontInfo[tex.widthBase[f]+int32(i.b0)].int() > w {
				goto label30
			}
			c = byte(y)
		}
	label30:
		if h < tex.fontInfo[5+tex.paramBase[f]].int() {
			delta = h
		} else {
			delta = tex.fontInfo[5+tex.paramBase[f]].int()
		}
		if (tex.mem[int32(q)+2].hh().rh != 0) || (tex.mem[int32(q)+3].hh().rh != 0) {
			if tex.mem[int32(q)+1].hh().rh == 1 {
				tex.flushNodeList(x)
				x = tex.newNoad()
				tex.mem[int32(x)+1] = tex.mem[int32(q)+1]
				tex.mem[int32(x)+2] = tex.mem[int32(q)+2]
				tex.mem[int32(x)+3] = tex.mem[int32(q)+3]
				*tex.mem[int32(q)+2].pHh() = tex.emptyField
				*tex.mem[int32(q)+3].pHh() = tex.emptyField
				tex.mem[int32(q)+1].pHh().rh = 3
				*tex.mem[int32(q)+1].pHh().pLh() = x
				x = tex.cleanBox(uint16(int32(q)+1), tex.curStyle)
				delta = delta + tex.mem[int32(x)+3].int() - h
				h = tex.mem[int32(x)+3].int()
			}
		}
		y = tex.charBox(f, c)
		*tex.mem[int32(y)+4].pInt() = s + tex.half(w-tex.mem[int32(y)+1].int())
		*tex.mem[int32(y)+1].pInt() = 0
		p = tex.newKern(-delta)
		tex.mem[p].pHh().rh = x
		tex.mem[y].pHh().rh = p
		y = tex.vpackage(y, 0, 1, 1073741823)
		*tex.mem[int32(y)+1].pInt() = tex.mem[int32(x)+1].int()
		if tex.mem[int32(y)+3].int() < h {
			p = tex.newKern(h - tex.mem[int32(y)+3].int())
			tex.mem[p].pHh().rh = tex.mem[int32(y)+5].hh().rh
			tex.mem[int32(y)+5].pHh().rh = p
			*tex.mem[int32(y)+3].pInt() = h
		}
		*tex.mem[int32(q)+1].pHh().pLh() = y
		tex.mem[int32(q)+1].pHh().rh = 2
	}
}

func (tex *Context) makeFraction(q uint16) {
	var p, v, x, y, z uint16                                 // 0..65535
	var delta, delta1, delta2, shiftUp, shiftDown, clr int32 // integer
	if tex.mem[int32(q)+1].int() == 1073741824 {
		*tex.mem[int32(q)+1].pInt() = tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()
	}
	x = tex.cleanBox(uint16(int32(q)+2), byte(int32(tex.curStyle)+2-(2*(int32(tex.curStyle)/6))))
	z = tex.cleanBox(uint16(int32(q)+3), byte((2*(int32(tex.curStyle)/2))+3-(2*(int32(tex.curStyle)/6))))
	if tex.mem[int32(x)+1].int() < tex.mem[int32(z)+1].int() {
		x = tex.rebox(x, tex.mem[int32(z)+1].int())
	} else {
		z = tex.rebox(z, tex.mem[int32(x)+1].int())
	}
	if tex.curStyle < 2 {
		shiftUp = tex.fontInfo[8+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		shiftDown = tex.fontInfo[11+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
	} else {
		shiftDown = tex.fontInfo[12+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		if tex.mem[int32(q)+1].int() != 0 {
			shiftUp = tex.fontInfo[9+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		} else {
			shiftUp = tex.fontInfo[10+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		}
	}
	if tex.mem[int32(q)+1].int() == 0 {
		if tex.curStyle < 2 {
			clr = (7 * tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
		} else {
			clr = (3 * tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
		}
		delta = tex.half(clr - ((shiftUp - tex.mem[int32(x)+2].int()) - (tex.mem[int32(z)+3].int() - shiftDown)))
		if delta > 0 {
			shiftUp = shiftUp + delta
			shiftDown = shiftDown + delta
		}
	} else {
		if tex.curStyle < 2 {
			clr = (3 * tex.mem[int32(q)+1].int())
		} else {
			clr = tex.mem[int32(q)+1].int()
		}
		delta = tex.half(tex.mem[int32(q)+1].int())
		delta1 = clr - ((shiftUp - tex.mem[int32(x)+2].int()) - (tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() + delta))
		delta2 = clr - ((tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() - delta) - (tex.mem[int32(z)+3].int() - shiftDown))
		if delta1 > 0 {
			shiftUp = shiftUp + delta1
		}
		if delta2 > 0 {
			shiftDown = shiftDown + delta2
		}
	}
	v = tex.newNullBox()
	*tex.mem[v].pHh().pB0() = 1
	*tex.mem[int32(v)+3].pInt() = shiftUp + tex.mem[int32(x)+3].int()
	*tex.mem[int32(v)+2].pInt() = tex.mem[int32(z)+2].int() + shiftDown
	*tex.mem[int32(v)+1].pInt() = tex.mem[int32(x)+1].int()
	if tex.mem[int32(q)+1].int() == 0 {
		p = tex.newKern((shiftUp - tex.mem[int32(x)+2].int()) - (tex.mem[int32(z)+3].int() - shiftDown))
		tex.mem[p].pHh().rh = z
	} else {
		y = tex.fractionRule(tex.mem[int32(q)+1].int())
		p = tex.newKern((tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() - delta) - (tex.mem[int32(z)+3].int() - shiftDown))
		tex.mem[y].pHh().rh = p
		tex.mem[p].pHh().rh = z
		p = tex.newKern((shiftUp - tex.mem[int32(x)+2].int()) - (tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() + delta))
		tex.mem[p].pHh().rh = y
	}
	tex.mem[x].pHh().rh = p
	tex.mem[int32(v)+5].pHh().rh = x
	if tex.curStyle < 2 {
		delta = tex.fontInfo[20+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
	} else {
		delta = tex.fontInfo[21+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
	}
	x = tex.varDelimiter(uint16(int32(q)+4), tex.curSize, delta)
	tex.mem[x].pHh().rh = v
	z = tex.varDelimiter(uint16(int32(q)+5), tex.curSize, delta)
	tex.mem[v].pHh().rh = z
	*tex.mem[int32(q)+1].pInt() = int32(tex.hpack(x, 0, 1))
}

func (tex *Context) makeOp(q uint16) (ret int32) {
	var delta int32              // integer
	var p, v, x, y, z uint16     // 0..65535
	var c byte                   // 0..255
	var i fourQuarters           // record fourQuarters
	var shiftUp, shiftDown int32 // integer
	if (tex.mem[q].hh().b1() == 0) && (tex.curStyle < 2) {
		*tex.mem[q].pHh().pB1() = 1
	}
	if tex.mem[int32(q)+1].hh().rh == 1 {
		tex.fetch(uint16(int32(q) + 1))
		if (tex.curStyle < 2) && (((int32(tex.curI.b2) - 0) % 4) == 2) {
			c = tex.curI.b3
			i = tex.fontInfo[tex.charBase[tex.curF]+int32(c)].qqqq()
			if i.b0 > 0 {
				tex.curC = c
				tex.curI = i
				*tex.mem[int32(q)+1].pHh().pB1() = c
			}
		}
		delta = tex.fontInfo[tex.italicBase[tex.curF]+((int32(tex.curI.b2)-0)/4)].int()
		x = tex.cleanBox(uint16(int32(q)+1), tex.curStyle)
		if (tex.mem[int32(q)+3].hh().rh != 0) && (tex.mem[q].hh().b1() != 1) {
			*tex.mem[int32(x)+1].pInt() = tex.mem[int32(x)+1].int() - delta
		}
		*tex.mem[int32(x)+4].pInt() = tex.half(tex.mem[int32(x)+3].int()-tex.mem[int32(x)+2].int()) - tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		tex.mem[int32(q)+1].pHh().rh = 2
		*tex.mem[int32(q)+1].pHh().pLh() = x
	} else {
		delta = 0
	}
	if tex.mem[q].hh().b1() == 1 {
		x = tex.cleanBox(uint16(int32(q)+2), byte((2*(int32(tex.curStyle)/4))+4+(int32(tex.curStyle)%2)))
		y = tex.cleanBox(uint16(int32(q)+1), tex.curStyle)
		z = tex.cleanBox(uint16(int32(q)+3), byte((2*(int32(tex.curStyle)/4))+5))
		v = tex.newNullBox()
		*tex.mem[v].pHh().pB0() = 1
		*tex.mem[int32(v)+1].pInt() = tex.mem[int32(y)+1].int()
		if tex.mem[int32(x)+1].int() > tex.mem[int32(v)+1].int() {
			*tex.mem[int32(v)+1].pInt() = tex.mem[int32(x)+1].int()
		}
		if tex.mem[int32(z)+1].int() > tex.mem[int32(v)+1].int() {
			*tex.mem[int32(v)+1].pInt() = tex.mem[int32(z)+1].int()
		}
		x = tex.rebox(x, tex.mem[int32(v)+1].int())
		y = tex.rebox(y, tex.mem[int32(v)+1].int())
		z = tex.rebox(z, tex.mem[int32(v)+1].int())
		*tex.mem[int32(x)+4].pInt() = tex.half(delta)
		*tex.mem[int32(z)+4].pInt() = -tex.mem[int32(x)+4].int()
		*tex.mem[int32(v)+3].pInt() = tex.mem[int32(y)+3].int()
		*tex.mem[int32(v)+2].pInt() = tex.mem[int32(y)+2].int()
		if tex.mem[int32(q)+2].hh().rh == 0 {
			tex.freeNode(x, 7)
			tex.mem[int32(v)+5].pHh().rh = y
		} else {
			shiftUp = tex.fontInfo[11+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() - tex.mem[int32(x)+2].int()
			if shiftUp < tex.fontInfo[9+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() {
				shiftUp = tex.fontInfo[9+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()
			}
			p = tex.newKern(shiftUp)
			tex.mem[p].pHh().rh = y
			tex.mem[x].pHh().rh = p
			p = tex.newKern(tex.fontInfo[13+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
			tex.mem[p].pHh().rh = x
			tex.mem[int32(v)+5].pHh().rh = p
			*tex.mem[int32(v)+3].pInt() = tex.mem[int32(v)+3].int() + tex.fontInfo[13+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() + tex.mem[int32(x)+3].int() + tex.mem[int32(x)+2].int() + shiftUp
		}
		if tex.mem[int32(q)+3].hh().rh == 0 {
			tex.freeNode(z, 7)
		} else {
			shiftDown = tex.fontInfo[12+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() - tex.mem[int32(z)+3].int()
			if shiftDown < tex.fontInfo[10+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() {
				shiftDown = tex.fontInfo[10+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()
			}
			p = tex.newKern(shiftDown)
			tex.mem[y].pHh().rh = p
			tex.mem[p].pHh().rh = z
			p = tex.newKern(tex.fontInfo[13+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int())
			tex.mem[z].pHh().rh = p
			*tex.mem[int32(v)+2].pInt() = tex.mem[int32(v)+2].int() + tex.fontInfo[13+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int() + tex.mem[int32(z)+3].int() + tex.mem[int32(z)+2].int() + shiftDown
		}
		*tex.mem[int32(q)+1].pInt() = int32(v)
	}
	ret = delta
	return ret
}

func (tex *Context) makeOrd(q uint16) {
	var a int32     // integer
	var p, r uint16 // 0..65535
label20:
	if tex.mem[int32(q)+3].hh().rh == 0 {
		if tex.mem[int32(q)+2].hh().rh == 0 {
			if tex.mem[int32(q)+1].hh().rh == 1 {
				p = tex.mem[q].hh().rh
				if p != 0 {
					if (tex.mem[p].hh().b0() >= 16) && (tex.mem[p].hh().b0() <= 22) {
						if tex.mem[int32(p)+1].hh().rh == 1 {
							if tex.mem[int32(p)+1].hh().b0() == tex.mem[int32(q)+1].hh().b0() {
								tex.mem[int32(q)+1].pHh().rh = 4
								tex.fetch(uint16(int32(q) + 1))
								if ((int32(tex.curI.b2) - 0) % 4) == 1 {
									a = tex.ligKernBase[tex.curF] + int32(tex.curI.b3)
									tex.curC = tex.mem[int32(p)+1].hh().b1()
									tex.curI = tex.fontInfo[a].qqqq()
									if tex.curI.b0 > 128 {
										a = tex.ligKernBase[tex.curF] + (256 * int32(tex.curI.b2)) + int32(tex.curI.b3) + 32768 - (256 * 128)
										tex.curI = tex.fontInfo[a].qqqq()
									}
									for true {
										if tex.curI.b1 == tex.curC {
											if tex.curI.b0 <= 128 {
												if tex.curI.b2 >= 128 {
													p = tex.newKern(tex.fontInfo[tex.kernBase[tex.curF]+(256*int32(tex.curI.b2))+int32(tex.curI.b3)].int())
													tex.mem[p].pHh().rh = tex.mem[q].hh().rh
													tex.mem[q].pHh().rh = p
													goto label10
												} else {
													if tex.interrupt != 0 {
														tex.pauseForInstructions()
													}
													switch tex.curI.b2 {
													case 1, 5:
														*tex.mem[int32(q)+1].pHh().pB1() = tex.curI.b3
													case 2, 6:
														*tex.mem[int32(p)+1].pHh().pB1() = tex.curI.b3
													case 3, 7, 11:
														r = tex.newNoad()
														*tex.mem[int32(r)+1].pHh().pB1() = tex.curI.b3
														*tex.mem[int32(r)+1].pHh().pB0() = tex.mem[int32(q)+1].hh().b0()
														tex.mem[q].pHh().rh = r
														tex.mem[r].pHh().rh = p
														if tex.curI.b2 < 11 {
															tex.mem[int32(r)+1].pHh().rh = 1
														} else {
															tex.mem[int32(r)+1].pHh().rh = 4
														}
													default:
														tex.mem[q].pHh().rh = tex.mem[p].hh().rh
														*tex.mem[int32(q)+1].pHh().pB1() = tex.curI.b3
														tex.mem[int32(q)+3] = tex.mem[int32(p)+3]
														tex.mem[int32(q)+2] = tex.mem[int32(p)+2]
														tex.freeNode(p, 4)
													}
													if tex.curI.b2 > 3 {
														goto label10
													}
													tex.mem[int32(q)+1].pHh().rh = 1
													goto label20
												}
											}
										}
										if tex.curI.b0 >= 128 {
											goto label10
										}
										a = a + int32(tex.curI.b0) + 1
										tex.curI = tex.fontInfo[a].qqqq()
									}
								}
							}
						}
					}
				}
			}
		}
	}
label10:
}

func (tex *Context) makeScripts(q uint16, delta int32) {
	var p, x, y, z uint16             // 0..65535
	var shiftUp, shiftDown, clr int32 // integer
	var t byte                        // 0..63
	p = uint16(tex.mem[int32(q)+1].int())
	if p >= tex.hiMemMin {
		shiftUp = 0
		shiftDown = 0
	} else {
		z = tex.hpack(p, 0, 1)
		if tex.curStyle < 4 {
			t = 16
		} else {
			t = 32
		}
		shiftUp = tex.mem[int32(z)+3].int() - tex.fontInfo[18+tex.paramBase[tex.eqtb[3937+int32(t)-1].hh().rh]].int()
		shiftDown = tex.mem[int32(z)+2].int() + tex.fontInfo[19+tex.paramBase[tex.eqtb[3937+int32(t)-1].hh().rh]].int()
		tex.freeNode(z, 7)
	}
	if tex.mem[int32(q)+2].hh().rh == 0 {
		x = tex.cleanBox(uint16(int32(q)+3), byte((2*(int32(tex.curStyle)/4))+5))
		*tex.mem[int32(x)+1].pInt() = tex.mem[int32(x)+1].int() + tex.eqtb[5842-1].int()
		if shiftDown < tex.fontInfo[16+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() {
			shiftDown = tex.fontInfo[16+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		}
		clr = tex.mem[int32(x)+3].int() - (iabs((tex.fontInfo[5+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() * 4)) / 5)
		if shiftDown < clr {
			shiftDown = clr
		}
		*tex.mem[int32(x)+4].pInt() = shiftDown
	} else {
		x = tex.cleanBox(uint16(int32(q)+2), byte((2*(int32(tex.curStyle)/4))+4+(int32(tex.curStyle)%2)))
		*tex.mem[int32(x)+1].pInt() = tex.mem[int32(x)+1].int() + tex.eqtb[5842-1].int()
		if odd(int32(tex.curStyle)) {
			clr = tex.fontInfo[15+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		} else if tex.curStyle < 2 {
			clr = tex.fontInfo[13+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		} else {
			clr = tex.fontInfo[14+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
		}
		if shiftUp < clr {
			shiftUp = clr
		}
		clr = tex.mem[int32(x)+2].int() + (iabs(tex.fontInfo[5+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()) / 4)
		if shiftUp < clr {
			shiftUp = clr
		}
		if tex.mem[int32(q)+3].hh().rh == 0 {
			*tex.mem[int32(x)+4].pInt() = -shiftUp
		} else {
			y = tex.cleanBox(uint16(int32(q)+3), byte((2*(int32(tex.curStyle)/4))+5))
			*tex.mem[int32(y)+1].pInt() = tex.mem[int32(y)+1].int() + tex.eqtb[5842-1].int()
			if shiftDown < tex.fontInfo[17+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() {
				shiftDown = tex.fontInfo[17+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
			}
			clr = (4 * tex.fontInfo[8+tex.paramBase[tex.eqtb[3938+int32(tex.curSize)-1].hh().rh]].int()) - ((shiftUp - tex.mem[int32(x)+2].int()) - (tex.mem[int32(y)+3].int() - shiftDown))
			if clr > 0 {
				shiftDown = shiftDown + clr
				clr = (iabs((tex.fontInfo[5+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int() * 4)) / 5) - (shiftUp - tex.mem[int32(x)+2].int())
				if clr > 0 {
					shiftUp = shiftUp + clr
					shiftDown = shiftDown - clr
				}
			}
			*tex.mem[int32(x)+4].pInt() = delta
			p = tex.newKern((shiftUp - tex.mem[int32(x)+2].int()) - (tex.mem[int32(y)+3].int() - shiftDown))
			tex.mem[x].pHh().rh = p
			tex.mem[p].pHh().rh = y
			x = tex.vpackage(x, 0, 1, 1073741823)
			*tex.mem[int32(x)+4].pInt() = shiftDown
		}
	}
	if tex.mem[int32(q)+1].int() == 0 {
		*tex.mem[int32(q)+1].pInt() = int32(x)
	} else {
		p = uint16(tex.mem[int32(q)+1].int())
		for tex.mem[p].hh().rh != 0 {
			p = tex.mem[p].hh().rh
		}
		tex.mem[p].pHh().rh = x
	}
}

func (tex *Context) makeLeftRight(q uint16, style byte, maxD, maxH int32) (ret byte) {
	var delta, delta1, delta2 int32 // integer
	if style < 4 {
		tex.curSize = 0
	} else {
		tex.curSize = byte((16 * ((int32(style) - 2) / 2)))
	}
	delta2 = maxD + tex.fontInfo[22+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int()
	delta1 = maxH + maxD - delta2
	if delta2 > delta1 {
		delta1 = delta2
	}
	delta = ((delta1 / 500) * tex.eqtb[5281-1].int())
	delta2 = delta1 + delta1 - tex.eqtb[5840-1].int()
	if delta < delta2 {
		delta = delta2
	}
	*tex.mem[int32(q)+1].pInt() = int32(tex.varDelimiter(uint16(int32(q)+1), tex.curSize, delta))
	ret = byte(int32(tex.mem[q].hh().b0()) - 10)
	return ret
}

func (tex *Context) mlistToHlist() {
	var mlist uint16      // 0..65535
	var penalties bool    // boolean
	var style byte        // 0..63
	var saveStyle byte    // 0..63
	var q uint16          // 0..65535
	var r uint16          // 0..65535
	var rType byte        // 0..63
	var t byte            // 0..63
	var p, x, y, z uint16 // 0..65535
	var pen int32         // integer
	var s byte            // 0..63
	var maxH, maxD int32  // integer
	var delta int32       // integer
	mlist = tex.curMlist
	penalties = tex.mlistPenalties
	style = tex.curStyle
	q = mlist
	r = 0
	rType = 17
	maxH = 0
	maxD = 0
	if tex.curStyle < 4 {
		tex.curSize = 0
	} else {
		tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
	}
	tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
	for q != 0 {
	label21:
		delta = 0
		switch tex.mem[q].hh().b0() {
		case 18:
			switch rType {
			case 18, 17, 19, 20, 22, 30:
				*tex.mem[q].pHh().pB0() = 16
				goto label21
			default:
			}
		case 19, 21, 22, 31:
			if rType == 18 {
				*tex.mem[r].pHh().pB0() = 16
			}
			if tex.mem[q].hh().b0() == 31 {
				goto label80
			}
		case 30:
			goto label80
		case 25:
			tex.makeFraction(q)
			goto label82
		case 17:
			delta = tex.makeOp(q)
			if tex.mem[q].hh().b1() == 1 {
				goto label82
			}
		case 16:
			tex.makeOrd(q)
		case 20, 23:
		case 24:
			tex.makeRadical(q)
		case 27:
			tex.makeOver(q)
		case 26:
			tex.makeUnder(q)
		case 28:
			tex.makeMathAccent(q)
		case 29:
			tex.makeVcenter(q)
		case 14:
			tex.curStyle = tex.mem[q].hh().b1()
			if tex.curStyle < 4 {
				tex.curSize = 0
			} else {
				tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
			}
			tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
			goto label81
		case 15:
			switch int32(tex.curStyle) / 2 {
			case 0:
				p = tex.mem[int32(q)+1].hh().lh()
				*tex.mem[int32(q)+1].pHh().pLh() = 0
			case 1:
				p = tex.mem[int32(q)+1].hh().rh
				tex.mem[int32(q)+1].pHh().rh = 0
			case 2:
				p = tex.mem[int32(q)+2].hh().lh()
				*tex.mem[int32(q)+2].pHh().pLh() = 0
			case 3:
				p = tex.mem[int32(q)+2].hh().rh
				tex.mem[int32(q)+2].pHh().rh = 0
			}
			tex.flushNodeList(tex.mem[int32(q)+1].hh().lh())
			tex.flushNodeList(tex.mem[int32(q)+1].hh().rh)
			tex.flushNodeList(tex.mem[int32(q)+2].hh().lh())
			tex.flushNodeList(tex.mem[int32(q)+2].hh().rh)
			*tex.mem[q].pHh().pB0() = 14
			*tex.mem[q].pHh().pB1() = tex.curStyle
			*tex.mem[int32(q)+1].pInt() = 0
			*tex.mem[int32(q)+2].pInt() = 0
			if p != 0 {
				z = tex.mem[q].hh().rh
				tex.mem[q].pHh().rh = p
				for tex.mem[p].hh().rh != 0 {
					p = tex.mem[p].hh().rh
				}
				tex.mem[p].pHh().rh = z
			}
			goto label81
		case 3, 4, 5, 8, 12, 7:
			goto label81
		case 2:
			if tex.mem[int32(q)+3].int() > maxH {
				maxH = tex.mem[int32(q)+3].int()
			}
			if tex.mem[int32(q)+2].int() > maxD {
				maxD = tex.mem[int32(q)+2].int()
			}
			goto label81
		case 10:
			if tex.mem[q].hh().b1() == 99 {
				x = tex.mem[int32(q)+1].hh().lh()
				y = tex.mathGlue(x, tex.curMu)
				tex.deleteGlueRef(x)
				*tex.mem[int32(q)+1].pHh().pLh() = y
				*tex.mem[q].pHh().pB1() = 0
			} else if (tex.curSize != 0) && (tex.mem[q].hh().b1() == 98) {
				p = tex.mem[q].hh().rh
				if p != 0 {
					if (tex.mem[p].hh().b0() == 10) || (tex.mem[p].hh().b0() == 11) {
						tex.mem[q].pHh().rh = tex.mem[p].hh().rh
						tex.mem[p].pHh().rh = 0
						tex.flushNodeList(p)
					}
				}
			}
			goto label81
		case 11:
			tex.mathKern(q, tex.curMu)
			goto label81
		default:
			tex.confusion(889)
		}
		switch tex.mem[int32(q)+1].hh().rh {
		case 1, 4:
			tex.fetch(uint16(int32(q) + 1))
			if tex.curI.b0 > 0 {
				delta = tex.fontInfo[tex.italicBase[tex.curF]+((int32(tex.curI.b2)-0)/4)].int()
				p = tex.newCharacter(tex.curF, byte(int32(tex.curC)-0))
				if (tex.mem[int32(q)+1].hh().rh == 4) && (tex.fontInfo[2+tex.paramBase[tex.curF]].int() != 0) {
					delta = 0
				}
				if (tex.mem[int32(q)+3].hh().rh == 0) && (delta != 0) {
					tex.mem[p].pHh().rh = tex.newKern(delta)
					delta = 0
				}
			} else {
				p = 0
			}
		case 0:
			p = 0
		case 2:
			p = tex.mem[int32(q)+1].hh().lh()
		case 3:
			tex.curMlist = tex.mem[int32(q)+1].hh().lh()
			saveStyle = tex.curStyle
			tex.mlistPenalties = false
			tex.mlistToHlist()
			tex.curStyle = saveStyle
			if tex.curStyle < 4 {
				tex.curSize = 0
			} else {
				tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
			}
			tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
			p = tex.hpack(tex.mem[29997].hh().rh, 0, 1)
		default:
			tex.confusion(890)
		}
		*tex.mem[int32(q)+1].pInt() = int32(p)
		if (tex.mem[int32(q)+3].hh().rh == 0) && (tex.mem[int32(q)+2].hh().rh == 0) {
			goto label82
		}
		tex.makeScripts(q, delta)
	label82:
		z = tex.hpack(uint16(tex.mem[int32(q)+1].int()), 0, 1)
		if tex.mem[int32(z)+3].int() > maxH {
			maxH = tex.mem[int32(z)+3].int()
		}
		if tex.mem[int32(z)+2].int() > maxD {
			maxD = tex.mem[int32(z)+2].int()
		}
		tex.freeNode(z, 7)
	label80:
		r = q
		rType = tex.mem[r].hh().b0()
	label81:
		q = tex.mem[q].hh().rh
	}
	if rType == 18 {
		*tex.mem[r].pHh().pB0() = 16
	}
	p = 29997
	tex.mem[p].pHh().rh = 0
	q = mlist
	rType = 0
	tex.curStyle = style
	if tex.curStyle < 4 {
		tex.curSize = 0
	} else {
		tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
	}
	tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
	for q != 0 {
		t = 16
		s = 4
		pen = 10000
		switch tex.mem[q].hh().b0() {
		case 17, 20, 21, 22, 23:
			t = tex.mem[q].hh().b0()
		case 18:
			t = 18
			pen = tex.eqtb[5272-1].int()
		case 19:
			t = 19
			pen = tex.eqtb[5273-1].int()
		case 16, 29, 27, 26:
		case 24:
			s = 5
		case 28:
			s = 5
		case 25:
			s = 6
		case 30, 31:
			t = tex.makeLeftRight(q, style, maxD, maxH)
		case 14:
			tex.curStyle = tex.mem[q].hh().b1()
			s = 3
			if tex.curStyle < 4 {
				tex.curSize = 0
			} else {
				tex.curSize = byte((16 * ((int32(tex.curStyle) - 2) / 2)))
			}
			tex.curMu = tex.xOverN(tex.fontInfo[6+tex.paramBase[tex.eqtb[3937+int32(tex.curSize)-1].hh().rh]].int(), 18)
			goto label83
		case 8, 12, 2, 7, 5, 3, 4, 10, 11:
			tex.mem[p].pHh().rh = q
			p = q
			q = tex.mem[q].hh().rh
			tex.mem[p].pHh().rh = 0
			goto label30
		default:
			tex.confusion(891)
		}
		if rType > 0 {
			switch tex.strPool[(int32(rType)*8)+int32(t)+tex.magicOffset] {
			case 48:
				x = 0
			case 49:
				if tex.curStyle < 4 {
					x = 15
				} else {
					x = 0
				}
			case 50:
				x = 15
			case 51:
				if tex.curStyle < 4 {
					x = 16
				} else {
					x = 0
				}
			case 52:
				if tex.curStyle < 4 {
					x = 17
				} else {
					x = 0
				}
			default:
				tex.confusion(893)
			}
			if x != 0 {
				y = tex.mathGlue(tex.eqtb[2882+int32(x)-1].hh().rh, tex.curMu)
				z = tex.newGlue(y)
				tex.mem[y].pHh().rh = 0
				tex.mem[p].pHh().rh = z
				p = z
				*tex.mem[z].pHh().pB1() = byte(int32(x) + 1)
			}
		}
		if tex.mem[int32(q)+1].int() != 0 {
			tex.mem[p].pHh().rh = uint16(tex.mem[int32(q)+1].int())
			for {
				p = tex.mem[p].hh().rh
				if tex.mem[p].hh().rh == 0 {
					break
				}
			}
		}
		if penalties {
			if tex.mem[q].hh().rh != 0 {
				if pen < 10000 {
					rType = tex.mem[tex.mem[q].hh().rh].hh().b0()
					if rType != 12 {
						if rType != 19 {
							z = tex.newPenalty(pen)
							tex.mem[p].pHh().rh = z
							p = z
						}
					}
				}
			}
		}
		rType = t
	label83:
		r = q
		q = tex.mem[q].hh().rh
		tex.freeNode(r, uint16(s))
	label30:
	}
}

func (tex *Context) pushAlignment() {
	var p uint16 // 0..65535
	p = tex.getNode(5)
	tex.mem[p].pHh().rh = tex.alignPtr
	*tex.mem[p].pHh().pLh() = tex.curAlign
	*tex.mem[int32(p)+1].pHh().pLh() = tex.mem[29992].hh().rh
	tex.mem[int32(p)+1].pHh().rh = tex.curSpan
	*tex.mem[int32(p)+2].pInt() = int32(tex.curLoop)
	*tex.mem[int32(p)+3].pInt() = tex.alignState
	*tex.mem[int32(p)+4].pHh().pLh() = tex.curHead
	tex.mem[int32(p)+4].pHh().rh = tex.curTail
	tex.alignPtr = p
	tex.curHead = tex.getAvail()
}

func (tex *Context) popAlignment() {
	var p uint16 // 0..65535
	tex.mem[tex.curHead].pHh().rh = tex.avail
	tex.avail = tex.curHead
	p = tex.alignPtr
	tex.curTail = tex.mem[int32(p)+4].hh().rh
	tex.curHead = tex.mem[int32(p)+4].hh().lh()
	tex.alignState = tex.mem[int32(p)+3].int()
	tex.curLoop = uint16(tex.mem[int32(p)+2].int())
	tex.curSpan = tex.mem[int32(p)+1].hh().rh
	tex.mem[29992].pHh().rh = tex.mem[int32(p)+1].hh().lh()
	tex.curAlign = tex.mem[p].hh().lh()
	tex.alignPtr = tex.mem[p].hh().rh
	tex.freeNode(p, 5)
}

func (tex *Context) getPreambleToken() {
label20:
	tex.getToken()
	for (tex.curChr == 256) && (tex.curCmd == 4) {
		tex.getToken()
		if tex.curCmd > 100 {
			tex.expand()
			tex.getToken()
		}
	}
	if tex.curCmd == 9 {
		tex.fatalError(595)
	}
	if (tex.curCmd == 75) && (tex.curChr == 2893) {
		tex.scanOptionalEquals()
		tex.scanGlue(2)
		if tex.eqtb[5306-1].int() > 0 {
			tex.geqDefine(2893, 117, uint16(tex.curVal))
		} else {
			tex.eqDefine(2893, 117, uint16(tex.curVal))
		}
		goto label20
	}
}

func (tex *Context) initAlign() {
	var saveCsPtr uint16 // 0..65535
	var p uint16         // 0..65535
	saveCsPtr = tex.curCs
	tex.pushAlignment()
	tex.alignState = -1000000
	if (tex.curList.modeField == 203) && ((tex.curList.tailField != tex.curList.headField) || (tex.curList.auxField.int() != 0)) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(680)
		tex.printEsc(520)
		tex.print(894)
		tex.helpPtr = 3
		tex.helpLine[2] = 895
		tex.helpLine[1] = 896
		tex.helpLine[0] = 897
		tex.error1()
		tex.flushMath()
	}
	tex.pushNest()
	if tex.curList.modeField == 203 {
		tex.curList.modeField = -1
		*tex.curList.auxField.pInt() = tex.nest[int32(tex.nestPtr)-2].auxField.int()
	} else if tex.curList.modeField > 0 {
		tex.curList.modeField = -tex.curList.modeField
	}
	tex.scanSpec(6, false)
	tex.mem[29992].pHh().rh = 0
	tex.curAlign = 29992
	tex.curLoop = 0
	tex.scannerStatus = 4
	tex.warningIndex = saveCsPtr
	tex.alignState = -1000000
	for true {
		tex.mem[tex.curAlign].pHh().rh = tex.newParamGlue(11)
		tex.curAlign = tex.mem[tex.curAlign].hh().rh
		if tex.curCmd == 5 {
			goto label30
		}
		p = 29996
		tex.mem[p].pHh().rh = 0
		for true {
			tex.getPreambleToken()
			if tex.curCmd == 6 {
				goto label31
			}
			if (tex.curCmd <= 5) && (tex.curCmd >= 4) && (tex.alignState == -1000000) {
				if (p == 29996) && (tex.curLoop == 0) && (tex.curCmd == 4) {
					tex.curLoop = tex.curAlign
				} else {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(903)
					tex.helpPtr = 3
					tex.helpLine[2] = 904
					tex.helpLine[1] = 905
					tex.helpLine[0] = 906
					tex.backError()
					goto label31
				}
			} else if (tex.curCmd != 10) || (p != 29996) {
				tex.mem[p].pHh().rh = tex.getAvail()
				p = tex.mem[p].hh().rh
				*tex.mem[p].pHh().pLh() = tex.curTok
			}
		}
	label31:
		tex.mem[tex.curAlign].pHh().rh = tex.newNullBox()
		tex.curAlign = tex.mem[tex.curAlign].hh().rh
		*tex.mem[tex.curAlign].pHh().pLh() = 29991
		*tex.mem[int32(tex.curAlign)+1].pInt() = -1073741824
		*tex.mem[int32(tex.curAlign)+3].pInt() = int32(tex.mem[29996].hh().rh)
		p = 29996
		tex.mem[p].pHh().rh = 0
		for true {
		label22:
			tex.getPreambleToken()
			if (tex.curCmd <= 5) && (tex.curCmd >= 4) && (tex.alignState == -1000000) {
				goto label32
			}
			if tex.curCmd == 6 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(907)
				tex.helpPtr = 3
				tex.helpLine[2] = 904
				tex.helpLine[1] = 905
				tex.helpLine[0] = 908
				tex.error1()
				goto label22
			}
			tex.mem[p].pHh().rh = tex.getAvail()
			p = tex.mem[p].hh().rh
			*tex.mem[p].pHh().pLh() = tex.curTok
		}
	label32:
		tex.mem[p].pHh().rh = tex.getAvail()
		p = tex.mem[p].hh().rh
		*tex.mem[p].pHh().pLh() = 6714
		*tex.mem[int32(tex.curAlign)+2].pInt() = int32(tex.mem[29996].hh().rh)
	}
label30:
	tex.scannerStatus = 0
	tex.newSaveLevel(6)
	if tex.eqtb[3420-1].hh().rh != 0 {
		tex.beginTokenList(tex.eqtb[3420-1].hh().rh, 13)
	}
	tex.alignPeek()
}

func (tex *Context) initSpan(p uint16) {
	tex.pushNest()
	if tex.curList.modeField == -102 {
		*tex.curList.auxField.pHh().pLh() = 1000
	} else {
		*tex.curList.auxField.pInt() = -65536000
		tex.normalParagraph()
	}
	tex.curSpan = p
}

func (tex *Context) initRow() {
	tex.pushNest()
	tex.curList.modeField = int16(-103 - int32(tex.curList.modeField))
	if tex.curList.modeField == -102 {
		*tex.curList.auxField.pHh().pLh() = 0
	} else {
		*tex.curList.auxField.pInt() = 0
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.newGlue(tex.mem[int32(tex.mem[29992].hh().rh)+1].hh().lh())
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	*tex.mem[tex.curList.tailField].pHh().pB1() = 12
	tex.curAlign = tex.mem[tex.mem[29992].hh().rh].hh().rh
	tex.curTail = tex.curHead
	tex.initSpan(tex.curAlign)
}

func (tex *Context) initCol() {
	*tex.mem[int32(tex.curAlign)+5].pHh().pLh() = uint16(tex.curCmd)
	if tex.curCmd == 63 {
		tex.alignState = 0
	} else {
		tex.backInput()
		tex.beginTokenList(uint16(tex.mem[int32(tex.curAlign)+3].int()), 1)
	}
}

func (tex *Context) finCol() (ret bool) {
	var p uint16    // 0..65535
	var q, r uint16 // 0..65535
	var s uint16    // 0..65535
	var u uint16    // 0..65535
	var w int32     // integer
	var o byte      // 0..3
	var n uint16    // 0..65535
	if tex.curAlign == 0 {
		tex.confusion(909)
	}
	q = tex.mem[tex.curAlign].hh().rh
	if q == 0 {
		tex.confusion(909)
	}
	if tex.alignState < 500000 {
		tex.fatalError(595)
	}
	p = tex.mem[q].hh().rh
	if (p == 0) && (tex.mem[int32(tex.curAlign)+5].hh().lh() < 257) {
		if tex.curLoop != 0 {
			tex.mem[q].pHh().rh = tex.newNullBox()
			p = tex.mem[q].hh().rh
			*tex.mem[p].pHh().pLh() = 29991
			*tex.mem[int32(p)+1].pInt() = -1073741824
			tex.curLoop = tex.mem[tex.curLoop].hh().rh
			q = 29996
			r = uint16(tex.mem[int32(tex.curLoop)+3].int())
			for r != 0 {
				tex.mem[q].pHh().rh = tex.getAvail()
				q = tex.mem[q].hh().rh
				*tex.mem[q].pHh().pLh() = tex.mem[r].hh().lh()
				r = tex.mem[r].hh().rh
			}
			tex.mem[q].pHh().rh = 0
			*tex.mem[int32(p)+3].pInt() = int32(tex.mem[29996].hh().rh)
			q = 29996
			r = uint16(tex.mem[int32(tex.curLoop)+2].int())
			for r != 0 {
				tex.mem[q].pHh().rh = tex.getAvail()
				q = tex.mem[q].hh().rh
				*tex.mem[q].pHh().pLh() = tex.mem[r].hh().lh()
				r = tex.mem[r].hh().rh
			}
			tex.mem[q].pHh().rh = 0
			*tex.mem[int32(p)+2].pInt() = int32(tex.mem[29996].hh().rh)
			tex.curLoop = tex.mem[tex.curLoop].hh().rh
			tex.mem[p].pHh().rh = tex.newGlue(tex.mem[int32(tex.curLoop)+1].hh().lh())
			*tex.mem[tex.mem[p].hh().rh].pHh().pB1() = 12
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(910)
			tex.printEsc(899)
			tex.helpPtr = 3
			tex.helpLine[2] = 911
			tex.helpLine[1] = 912
			tex.helpLine[0] = 913
			*tex.mem[int32(tex.curAlign)+5].pHh().pLh() = 257
			tex.error1()
		}
	}
	if tex.mem[int32(tex.curAlign)+5].hh().lh() != 256 {
		tex.unsave()
		tex.newSaveLevel(6)
		if tex.curList.modeField == -102 {
			tex.adjustTail = tex.curTail
			u = tex.hpack(tex.mem[tex.curList.headField].hh().rh, 0, 1)
			w = tex.mem[int32(u)+1].int()
			tex.curTail = tex.adjustTail
			tex.adjustTail = 0
		} else {
			u = tex.vpackage(tex.mem[tex.curList.headField].hh().rh, 0, 1, 0)
			w = tex.mem[int32(u)+3].int()
		}
		n = 0
		if tex.curSpan != tex.curAlign {
			q = tex.curSpan
			for {
				n = uint16(int32(n) + 1)
				q = tex.mem[tex.mem[q].hh().rh].hh().rh
				if q == tex.curAlign {
					break
				}
			}
			if n > 255 {
				tex.confusion(914)
			}
			q = tex.curSpan
			for tex.mem[tex.mem[q].hh().lh()].hh().rh < n {
				q = tex.mem[q].hh().lh()
			}
			if tex.mem[tex.mem[q].hh().lh()].hh().rh > n {
				s = tex.getNode(2)
				*tex.mem[s].pHh().pLh() = tex.mem[q].hh().lh()
				tex.mem[s].pHh().rh = n
				*tex.mem[q].pHh().pLh() = s
				*tex.mem[int32(s)+1].pInt() = w
			} else if tex.mem[int32(tex.mem[q].hh().lh())+1].int() < w {
				*tex.mem[int32(tex.mem[q].hh().lh())+1].pInt() = w
			}
		} else if w > tex.mem[int32(tex.curAlign)+1].int() {
			*tex.mem[int32(tex.curAlign)+1].pInt() = w
		}
		*tex.mem[u].pHh().pB0() = 13
		*tex.mem[u].pHh().pB1() = byte(n)
		if tex.totalStretch[3] != 0 {
			o = 3
		} else if tex.totalStretch[2] != 0 {
			o = 2
		} else if tex.totalStretch[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(u)+5].pHh().pB1() = o
		*tex.mem[int32(u)+6].pInt() = tex.totalStretch[o]
		if tex.totalShrink[3] != 0 {
			o = 3
		} else if tex.totalShrink[2] != 0 {
			o = 2
		} else if tex.totalShrink[1] != 0 {
			o = 1
		} else {
			o = 0
		}
		*tex.mem[int32(u)+5].pHh().pB0() = o
		*tex.mem[int32(u)+4].pInt() = tex.totalShrink[o]
		tex.popNest()
		tex.mem[tex.curList.tailField].pHh().rh = u
		tex.curList.tailField = u
		tex.mem[tex.curList.tailField].pHh().rh = tex.newGlue(tex.mem[int32(tex.mem[tex.curAlign].hh().rh)+1].hh().lh())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[tex.curList.tailField].pHh().pB1() = 12
		if tex.mem[int32(tex.curAlign)+5].hh().lh() >= 257 {
			ret = true
			goto label10
		}
		tex.initSpan(p)
	}
	tex.alignState = 1000000
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	tex.curAlign = p
	tex.initCol()
	ret = false
label10:
	return ret
}

func (tex *Context) finRow() {
	var p uint16 // 0..65535
	if tex.curList.modeField == -102 {
		p = tex.hpack(tex.mem[tex.curList.headField].hh().rh, 0, 1)
		tex.popNest()
		tex.appendToVlist(p)
		if tex.curHead != tex.curTail {
			tex.mem[tex.curList.tailField].pHh().rh = tex.mem[tex.curHead].hh().rh
			tex.curList.tailField = tex.curTail
		}
	} else {
		p = tex.vpackage(tex.mem[tex.curList.headField].hh().rh, 0, 1, 1073741823)
		tex.popNest()
		tex.mem[tex.curList.tailField].pHh().rh = p
		tex.curList.tailField = p
		*tex.curList.auxField.pHh().pLh() = 1000
	}
	*tex.mem[p].pHh().pB0() = 13
	*tex.mem[int32(p)+6].pInt() = 0
	if tex.eqtb[3420-1].hh().rh != 0 {
		tex.beginTokenList(tex.eqtb[3420-1].hh().rh, 13)
	}
	tex.alignPeek()
}

func (tex *Context) finAlign() {
	var p, q, r, s, u, v uint16 // 0..65535
	var t, w int32              // integer
	var o int32                 // integer
	var n uint16                // 0..65535
	var ruleSave int32          // integer
	var auxSave memoryWord      // record memoryWord
	if tex.curGroup != 6 {
		tex.confusion(915)
	}
	tex.unsave()
	if tex.curGroup != 6 {
		tex.confusion(916)
	}
	tex.unsave()
	if tex.nest[int32(tex.nestPtr)-1].modeField == 203 {
		o = tex.eqtb[5845-1].int()
	} else {
		o = 0
	}
	q = tex.mem[tex.mem[29992].hh().rh].hh().rh
	for {
		tex.flushList(uint16(tex.mem[int32(q)+3].int()))
		tex.flushList(uint16(tex.mem[int32(q)+2].int()))
		p = tex.mem[tex.mem[q].hh().rh].hh().rh
		if tex.mem[int32(q)+1].int() == -1073741824 {
			*tex.mem[int32(q)+1].pInt() = 0
			r = tex.mem[q].hh().rh
			s = tex.mem[int32(r)+1].hh().lh()
			if s != 0 {
				tex.mem[0].pHh().rh = uint16(int32(tex.mem[0].hh().rh) + 1)
				tex.deleteGlueRef(s)
				*tex.mem[int32(r)+1].pHh().pLh() = 0
			}
		}
		if tex.mem[q].hh().lh() != 29991 {
			t = tex.mem[int32(q)+1].int() + tex.mem[int32(tex.mem[int32(tex.mem[q].hh().rh)+1].hh().lh())+1].int()
			r = tex.mem[q].hh().lh()
			s = 29991
			*tex.mem[s].pHh().pLh() = p
			n = 1
			for {
				*tex.mem[int32(r)+1].pInt() = tex.mem[int32(r)+1].int() - t
				u = tex.mem[r].hh().lh()
				for tex.mem[r].hh().rh > n {
					s = tex.mem[s].hh().lh()
					n = uint16(int32(tex.mem[tex.mem[s].hh().lh()].hh().rh) + 1)
				}
				if tex.mem[r].hh().rh < n {
					*tex.mem[r].pHh().pLh() = tex.mem[s].hh().lh()
					*tex.mem[s].pHh().pLh() = r
					tex.mem[r].pHh().rh = uint16(int32(tex.mem[r].hh().rh) - 1)
					s = r
				} else {
					if tex.mem[int32(r)+1].int() > tex.mem[int32(tex.mem[s].hh().lh())+1].int() {
						*tex.mem[int32(tex.mem[s].hh().lh())+1].pInt() = tex.mem[int32(r)+1].int()
					}
					tex.freeNode(r, 2)
				}
				r = u
				if r == 29991 {
					break
				}
			}
		}
		*tex.mem[q].pHh().pB0() = 13
		*tex.mem[q].pHh().pB1() = 0
		*tex.mem[int32(q)+3].pInt() = 0
		*tex.mem[int32(q)+2].pInt() = 0
		*tex.mem[int32(q)+5].pHh().pB1() = 0
		*tex.mem[int32(q)+5].pHh().pB0() = 0
		*tex.mem[int32(q)+6].pInt() = 0
		*tex.mem[int32(q)+4].pInt() = 0
		q = p
		if q == 0 {
			break
		}
	}
	tex.savePtr = uint16(int32(tex.savePtr) - 2)
	tex.packBeginLine = -tex.curList.mlField
	if tex.curList.modeField == -1 {
		ruleSave = tex.eqtb[5846-1].int()
		*tex.eqtb[5846-1].pInt() = 0
		p = tex.hpack(tex.mem[29992].hh().rh, tex.saveStack[int32(tex.savePtr)+1].int(), byte(tex.saveStack[int32(tex.savePtr)+0].int()))
		*tex.eqtb[5846-1].pInt() = ruleSave
	} else {
		q = tex.mem[tex.mem[29992].hh().rh].hh().rh
		for {
			*tex.mem[int32(q)+3].pInt() = tex.mem[int32(q)+1].int()
			*tex.mem[int32(q)+1].pInt() = 0
			q = tex.mem[tex.mem[q].hh().rh].hh().rh
			if q == 0 {
				break
			}
		}
		p = tex.vpackage(tex.mem[29992].hh().rh, tex.saveStack[int32(tex.savePtr)+1].int(), byte(tex.saveStack[int32(tex.savePtr)+0].int()), 1073741823)
		q = tex.mem[tex.mem[29992].hh().rh].hh().rh
		for {
			*tex.mem[int32(q)+1].pInt() = tex.mem[int32(q)+3].int()
			*tex.mem[int32(q)+3].pInt() = 0
			q = tex.mem[tex.mem[q].hh().rh].hh().rh
			if q == 0 {
				break
			}
		}
	}
	tex.packBeginLine = 0
	q = tex.mem[tex.curList.headField].hh().rh
	s = tex.curList.headField
	for q != 0 {
		if !(q >= tex.hiMemMin) {
			if tex.mem[q].hh().b0() == 13 {
				if tex.curList.modeField == -1 {
					*tex.mem[q].pHh().pB0() = 0
					*tex.mem[int32(q)+1].pInt() = tex.mem[int32(p)+1].int()
				} else {
					*tex.mem[q].pHh().pB0() = 1
					*tex.mem[int32(q)+3].pInt() = tex.mem[int32(p)+3].int()
				}
				*tex.mem[int32(q)+5].pHh().pB1() = tex.mem[int32(p)+5].hh().b1()
				*tex.mem[int32(q)+5].pHh().pB0() = tex.mem[int32(p)+5].hh().b0()
				*tex.mem[int32(q)+6].pGr() = tex.mem[int32(p)+6].gr()
				*tex.mem[int32(q)+4].pInt() = o
				r = tex.mem[tex.mem[int32(q)+5].hh().rh].hh().rh
				s = tex.mem[tex.mem[int32(p)+5].hh().rh].hh().rh
				for {
					n = uint16(tex.mem[r].hh().b1())
					t = tex.mem[int32(s)+1].int()
					w = t
					u = 29996
					for n > 0 {
						n = uint16(int32(n) - 1)
						s = tex.mem[s].hh().rh
						v = tex.mem[int32(s)+1].hh().lh()
						tex.mem[u].pHh().rh = tex.newGlue(v)
						u = tex.mem[u].hh().rh
						*tex.mem[u].pHh().pB1() = 12
						t = t + tex.mem[int32(v)+1].int()
						if tex.mem[int32(p)+5].hh().b0() == 1 {
							if tex.mem[v].hh().b0() == tex.mem[int32(p)+5].hh().b1() {
								t = t + round((tex.mem[int32(p)+6].gr() * float32(tex.mem[int32(v)+2].int())))
							}
						} else if tex.mem[int32(p)+5].hh().b0() == 2 {
							if tex.mem[v].hh().b1() == tex.mem[int32(p)+5].hh().b1() {
								t = t - round((tex.mem[int32(p)+6].gr() * float32(tex.mem[int32(v)+3].int())))
							}
						}
						s = tex.mem[s].hh().rh
						tex.mem[u].pHh().rh = tex.newNullBox()
						u = tex.mem[u].hh().rh
						t = t + tex.mem[int32(s)+1].int()
						if tex.curList.modeField == -1 {
							*tex.mem[int32(u)+1].pInt() = tex.mem[int32(s)+1].int()
						} else {
							*tex.mem[u].pHh().pB0() = 1
							*tex.mem[int32(u)+3].pInt() = tex.mem[int32(s)+1].int()
						}
					}
					if tex.curList.modeField == -1 {
						*tex.mem[int32(r)+3].pInt() = tex.mem[int32(q)+3].int()
						*tex.mem[int32(r)+2].pInt() = tex.mem[int32(q)+2].int()
						if t == tex.mem[int32(r)+1].int() {
							*tex.mem[int32(r)+5].pHh().pB0() = 0
							*tex.mem[int32(r)+5].pHh().pB1() = 0
							*tex.mem[int32(r)+6].pGr() = 0
						} else if t > tex.mem[int32(r)+1].int() {
							*tex.mem[int32(r)+5].pHh().pB0() = 1
							if tex.mem[int32(r)+6].int() == 0 {
								*tex.mem[int32(r)+6].pGr() = 0
							} else {
								*tex.mem[int32(r)+6].pGr() = (float32((t - tex.mem[int32(r)+1].int())) / float32(tex.mem[int32(r)+6].int()))
							}
						} else {
							*tex.mem[int32(r)+5].pHh().pB1() = tex.mem[int32(r)+5].hh().b0()
							*tex.mem[int32(r)+5].pHh().pB0() = 2
							if tex.mem[int32(r)+4].int() == 0 {
								*tex.mem[int32(r)+6].pGr() = 0
							} else if (tex.mem[int32(r)+5].hh().b1() == 0) && ((tex.mem[int32(r)+1].int() - t) > tex.mem[int32(r)+4].int()) {
								*tex.mem[int32(r)+6].pGr() = 1
							} else {
								*tex.mem[int32(r)+6].pGr() = (float32((tex.mem[int32(r)+1].int() - t)) / float32(tex.mem[int32(r)+4].int()))
							}
						}
						*tex.mem[int32(r)+1].pInt() = w
						*tex.mem[r].pHh().pB0() = 0
					} else {
						*tex.mem[int32(r)+1].pInt() = tex.mem[int32(q)+1].int()
						if t == tex.mem[int32(r)+3].int() {
							*tex.mem[int32(r)+5].pHh().pB0() = 0
							*tex.mem[int32(r)+5].pHh().pB1() = 0
							*tex.mem[int32(r)+6].pGr() = 0
						} else if t > tex.mem[int32(r)+3].int() {
							*tex.mem[int32(r)+5].pHh().pB0() = 1
							if tex.mem[int32(r)+6].int() == 0 {
								*tex.mem[int32(r)+6].pGr() = 0
							} else {
								*tex.mem[int32(r)+6].pGr() = (float32((t - tex.mem[int32(r)+3].int())) / float32(tex.mem[int32(r)+6].int()))
							}
						} else {
							*tex.mem[int32(r)+5].pHh().pB1() = tex.mem[int32(r)+5].hh().b0()
							*tex.mem[int32(r)+5].pHh().pB0() = 2
							if tex.mem[int32(r)+4].int() == 0 {
								*tex.mem[int32(r)+6].pGr() = 0
							} else if (tex.mem[int32(r)+5].hh().b1() == 0) && ((tex.mem[int32(r)+3].int() - t) > tex.mem[int32(r)+4].int()) {
								*tex.mem[int32(r)+6].pGr() = 1
							} else {
								*tex.mem[int32(r)+6].pGr() = (float32((tex.mem[int32(r)+3].int() - t)) / float32(tex.mem[int32(r)+4].int()))
							}
						}
						*tex.mem[int32(r)+3].pInt() = w
						*tex.mem[r].pHh().pB0() = 1
					}
					*tex.mem[int32(r)+4].pInt() = 0
					if u != 29996 {
						tex.mem[u].pHh().rh = tex.mem[r].hh().rh
						tex.mem[r].pHh().rh = tex.mem[29996].hh().rh
						r = u
					}
					r = tex.mem[tex.mem[r].hh().rh].hh().rh
					s = tex.mem[tex.mem[s].hh().rh].hh().rh
					if r == 0 {
						break
					}
				}
			} else if tex.mem[q].hh().b0() == 2 {
				if tex.mem[int32(q)+1].int() == -1073741824 {
					*tex.mem[int32(q)+1].pInt() = tex.mem[int32(p)+1].int()
				}
				if tex.mem[int32(q)+3].int() == -1073741824 {
					*tex.mem[int32(q)+3].pInt() = tex.mem[int32(p)+3].int()
				}
				if tex.mem[int32(q)+2].int() == -1073741824 {
					*tex.mem[int32(q)+2].pInt() = tex.mem[int32(p)+2].int()
				}
				if o != 0 {
					r = tex.mem[q].hh().rh
					tex.mem[q].pHh().rh = 0
					q = tex.hpack(q, 0, 1)
					*tex.mem[int32(q)+4].pInt() = o
					tex.mem[q].pHh().rh = r
					tex.mem[s].pHh().rh = q
				}
			}
		}
		s = q
		q = tex.mem[q].hh().rh
	}
	tex.flushNodeList(p)
	tex.popAlignment()
	auxSave = tex.curList.auxField
	p = tex.mem[tex.curList.headField].hh().rh
	q = tex.curList.tailField
	tex.popNest()
	if tex.curList.modeField == 203 {
		tex.doAssignments()
		if tex.curCmd != 3 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1170)
			tex.helpPtr = 2
			tex.helpLine[1] = 895
			tex.helpLine[0] = 896
			tex.backError()
		} else {
			tex.getXToken()
			if tex.curCmd != 3 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1166)
				tex.helpPtr = 2
				tex.helpLine[1] = 1167
				tex.helpLine[0] = 1168
				tex.backError()
			}
		}
		tex.popNest()
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(tex.eqtb[5274-1].int())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(3)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.mem[tex.curList.tailField].pHh().rh = p
		if p != 0 {
			tex.curList.tailField = q
		}
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(tex.eqtb[5275-1].int())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(4)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.curList.auxField.pInt() = auxSave.int()
		tex.resumeAfterDisplay()
	} else {
		tex.curList.auxField = auxSave
		tex.mem[tex.curList.tailField].pHh().rh = p
		if p != 0 {
			tex.curList.tailField = q
		}
		if tex.curList.modeField == 1 {
			tex.buildPage()
		}
	}
}

func (tex *Context) alignPeek() {
label20:
	tex.alignState = 1000000
	for {
		tex.getXToken()
		if tex.curCmd != 10 {
			break
		}
	}
	if tex.curCmd == 34 {
		tex.scanLeftBrace()
		tex.newSaveLevel(7)
		if tex.curList.modeField == -1 {
			tex.normalParagraph()
		}
	} else if tex.curCmd == 2 {
		tex.finAlign()
	} else if (tex.curCmd == 5) && (tex.curChr == 258) {
		goto label20
	} else {
		tex.initRow()
		tex.initCol()
	}
}

func (tex *Context) finiteShrink(p uint16) (ret uint16) {
	var q uint16 // 0..65535
	if tex.noShrinkErrorYet {
		tex.noShrinkErrorYet = false
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(917)
		tex.helpPtr = 5
		tex.helpLine[4] = 918
		tex.helpLine[3] = 919
		tex.helpLine[2] = 920
		tex.helpLine[1] = 921
		tex.helpLine[0] = 922
		tex.error1()
	}
	q = tex.newSpec(p)
	*tex.mem[q].pHh().pB1() = 0
	tex.deleteGlueRef(p)
	ret = q
	return ret
}

func (tex *Context) tryBreak(pi int32, breakType byte) {
	var r uint16                // 0..65535
	var prevR uint16            // 0..65535
	var oldL uint16             // 0..65535
	var noBreakYet bool         // boolean
	var prevPrevR uint16        // 0..65535
	var s uint16                // 0..65535
	var q uint16                // 0..65535
	var v uint16                // 0..65535
	var t int32                 // integer
	var f byte                  // 0..75
	var l uint16                // 0..65535
	var nodeRStaysActive bool   // boolean
	var lineWidth int32         // integer
	var fitClass byte           // 0..3
	var b uint16                // 0..65535
	var d int32                 // integer
	var artificialDemerits bool // boolean
	var shortfall int32         // integer
	if iabs(pi) >= 10000 {
		if pi > 0 {
			goto label10
		} else {
			pi = -10000
		}
	}
	noBreakYet = true
	prevR = 29993
	oldL = 0
	tex.curActiveWidth[1-1] = tex.activeWidth[1-1]
	tex.curActiveWidth[2-1] = tex.activeWidth[2-1]
	tex.curActiveWidth[3-1] = tex.activeWidth[3-1]
	tex.curActiveWidth[4-1] = tex.activeWidth[4-1]
	tex.curActiveWidth[5-1] = tex.activeWidth[5-1]
	tex.curActiveWidth[6-1] = tex.activeWidth[6-1]
	for true {
	label22:
		r = tex.mem[prevR].hh().rh
		if tex.mem[r].hh().b0() == 2 {
			tex.curActiveWidth[1-1] = tex.curActiveWidth[1-1] + tex.mem[int32(r)+1].int()
			tex.curActiveWidth[2-1] = tex.curActiveWidth[2-1] + tex.mem[int32(r)+2].int()
			tex.curActiveWidth[3-1] = tex.curActiveWidth[3-1] + tex.mem[int32(r)+3].int()
			tex.curActiveWidth[4-1] = tex.curActiveWidth[4-1] + tex.mem[int32(r)+4].int()
			tex.curActiveWidth[5-1] = tex.curActiveWidth[5-1] + tex.mem[int32(r)+5].int()
			tex.curActiveWidth[6-1] = tex.curActiveWidth[6-1] + tex.mem[int32(r)+6].int()
			prevPrevR = prevR
			prevR = r
			goto label22
		}
		l = tex.mem[int32(r)+1].hh().lh()
		if l > oldL {
			if (tex.minimumDemerits < 1073741823) && ((oldL != tex.easyLine) || (r == 29993)) {
				if noBreakYet {
					noBreakYet = false
					tex.breakWidth[1-1] = tex.background[1-1]
					tex.breakWidth[2-1] = tex.background[2-1]
					tex.breakWidth[3-1] = tex.background[3-1]
					tex.breakWidth[4-1] = tex.background[4-1]
					tex.breakWidth[5-1] = tex.background[5-1]
					tex.breakWidth[6-1] = tex.background[6-1]
					s = tex.curP
					if breakType > 0 {
						if tex.curP != 0 {
							t = int32(tex.mem[tex.curP].hh().b1())
							v = tex.curP
							s = tex.mem[int32(tex.curP)+1].hh().rh
							for t > 0 {
								t = t - 1
								v = tex.mem[v].hh().rh
								if v >= tex.hiMemMin {
									f = tex.mem[v].hh().b0()
									tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[v].hh().b1())].qqqq().b0)].int()
								} else {
									switch tex.mem[v].hh().b0() {
									case 6:
										f = tex.mem[int32(v)+1].hh().b0()
										tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[int32(v)+1].hh().b1())].qqqq().b0)].int()
									case 0, 1, 2, 11:
										tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.mem[int32(v)+1].int()
									default:
										tex.confusion(923)
									}
								}
							}
							for s != 0 {
								if s >= tex.hiMemMin {
									f = tex.mem[s].hh().b0()
									tex.breakWidth[1-1] = tex.breakWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[s].hh().b1())].qqqq().b0)].int()
								} else {
									switch tex.mem[s].hh().b0() {
									case 6:
										f = tex.mem[int32(s)+1].hh().b0()
										tex.breakWidth[1-1] = tex.breakWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[int32(s)+1].hh().b1())].qqqq().b0)].int()
									case 0, 1, 2, 11:
										tex.breakWidth[1-1] = tex.breakWidth[1-1] + tex.mem[int32(s)+1].int()
									default:
										tex.confusion(924)
									}
								}
								s = tex.mem[s].hh().rh
							}
							tex.breakWidth[1-1] = tex.breakWidth[1-1] + tex.discWidth
							if tex.mem[int32(tex.curP)+1].hh().rh == 0 {
								s = tex.mem[v].hh().rh
							}
						}
					}
					for s != 0 {
						if s >= tex.hiMemMin {
							goto label30
						}
						switch tex.mem[s].hh().b0() {
						case 10:
							v = tex.mem[int32(s)+1].hh().lh()
							tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.mem[int32(v)+1].int()
							tex.breakWidth[2+int32(tex.mem[v].hh().b0())-1] = tex.breakWidth[2+int32(tex.mem[v].hh().b0())-1] - tex.mem[int32(v)+2].int()
							tex.breakWidth[6-1] = tex.breakWidth[6-1] - tex.mem[int32(v)+3].int()
						case 12:
						case 9:
							tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.mem[int32(s)+1].int()
						case 11:
							if tex.mem[s].hh().b1() != 1 {
								goto label30
							} else {
								tex.breakWidth[1-1] = tex.breakWidth[1-1] - tex.mem[int32(s)+1].int()
							}
						default:
							goto label30
						}
						s = tex.mem[s].hh().rh
					}
				label30:
				}
				if tex.mem[prevR].hh().b0() == 2 {
					*tex.mem[int32(prevR)+1].pInt() = tex.mem[int32(prevR)+1].int() - tex.curActiveWidth[1-1] + tex.breakWidth[1-1]
					*tex.mem[int32(prevR)+2].pInt() = tex.mem[int32(prevR)+2].int() - tex.curActiveWidth[2-1] + tex.breakWidth[2-1]
					*tex.mem[int32(prevR)+3].pInt() = tex.mem[int32(prevR)+3].int() - tex.curActiveWidth[3-1] + tex.breakWidth[3-1]
					*tex.mem[int32(prevR)+4].pInt() = tex.mem[int32(prevR)+4].int() - tex.curActiveWidth[4-1] + tex.breakWidth[4-1]
					*tex.mem[int32(prevR)+5].pInt() = tex.mem[int32(prevR)+5].int() - tex.curActiveWidth[5-1] + tex.breakWidth[5-1]
					*tex.mem[int32(prevR)+6].pInt() = tex.mem[int32(prevR)+6].int() - tex.curActiveWidth[6-1] + tex.breakWidth[6-1]
				} else if prevR == 29993 {
					tex.activeWidth[1-1] = tex.breakWidth[1-1]
					tex.activeWidth[2-1] = tex.breakWidth[2-1]
					tex.activeWidth[3-1] = tex.breakWidth[3-1]
					tex.activeWidth[4-1] = tex.breakWidth[4-1]
					tex.activeWidth[5-1] = tex.breakWidth[5-1]
					tex.activeWidth[6-1] = tex.breakWidth[6-1]
				} else {
					q = tex.getNode(7)
					tex.mem[q].pHh().rh = r
					*tex.mem[q].pHh().pB0() = 2
					*tex.mem[q].pHh().pB1() = 0
					*tex.mem[int32(q)+1].pInt() = tex.breakWidth[1-1] - tex.curActiveWidth[1-1]
					*tex.mem[int32(q)+2].pInt() = tex.breakWidth[2-1] - tex.curActiveWidth[2-1]
					*tex.mem[int32(q)+3].pInt() = tex.breakWidth[3-1] - tex.curActiveWidth[3-1]
					*tex.mem[int32(q)+4].pInt() = tex.breakWidth[4-1] - tex.curActiveWidth[4-1]
					*tex.mem[int32(q)+5].pInt() = tex.breakWidth[5-1] - tex.curActiveWidth[5-1]
					*tex.mem[int32(q)+6].pInt() = tex.breakWidth[6-1] - tex.curActiveWidth[6-1]
					tex.mem[prevR].pHh().rh = q
					prevPrevR = prevR
					prevR = q
				}
				if iabs(tex.eqtb[5279-1].int()) >= 1073741823-tex.minimumDemerits {
					tex.minimumDemerits = 1073741822
				} else {
					tex.minimumDemerits = tex.minimumDemerits + iabs(tex.eqtb[5279-1].int())
				}
				for _i := int64(0); _i <= int64(3); _i++ {
					fitClass = byte(_i)
					if tex.minimalDemerits[fitClass] <= tex.minimumDemerits {
						q = tex.getNode(2)
						tex.mem[q].pHh().rh = tex.passive
						tex.passive = q
						tex.mem[int32(q)+1].pHh().rh = tex.curP
						*tex.mem[int32(q)+1].pHh().pLh() = tex.bestPlace[fitClass]
						q = tex.getNode(3)
						tex.mem[int32(q)+1].pHh().rh = tex.passive
						*tex.mem[int32(q)+1].pHh().pLh() = uint16(int32(tex.bestPlLine[fitClass]) + 1)
						*tex.mem[q].pHh().pB1() = fitClass
						*tex.mem[q].pHh().pB0() = breakType
						*tex.mem[int32(q)+2].pInt() = tex.minimalDemerits[fitClass]
						tex.mem[q].pHh().rh = r
						tex.mem[prevR].pHh().rh = q
						prevR = q
					}
					tex.minimalDemerits[fitClass] = 1073741823
				}
				tex.minimumDemerits = 1073741823
				if r != 29993 {
					q = tex.getNode(7)
					tex.mem[q].pHh().rh = r
					*tex.mem[q].pHh().pB0() = 2
					*tex.mem[q].pHh().pB1() = 0
					*tex.mem[int32(q)+1].pInt() = tex.curActiveWidth[1-1] - tex.breakWidth[1-1]
					*tex.mem[int32(q)+2].pInt() = tex.curActiveWidth[2-1] - tex.breakWidth[2-1]
					*tex.mem[int32(q)+3].pInt() = tex.curActiveWidth[3-1] - tex.breakWidth[3-1]
					*tex.mem[int32(q)+4].pInt() = tex.curActiveWidth[4-1] - tex.breakWidth[4-1]
					*tex.mem[int32(q)+5].pInt() = tex.curActiveWidth[5-1] - tex.breakWidth[5-1]
					*tex.mem[int32(q)+6].pInt() = tex.curActiveWidth[6-1] - tex.breakWidth[6-1]
					tex.mem[prevR].pHh().rh = q
					prevPrevR = prevR
					prevR = q
				}
			}
			if r == 29993 {
				goto label10
			}
			if l > tex.easyLine {
				lineWidth = tex.secondWidth
				oldL = 65534
			} else {
				oldL = l
				if l > tex.lastSpecialLine {
					lineWidth = tex.secondWidth
				} else if tex.eqtb[3412-1].hh().rh == 0 {
					lineWidth = tex.firstWidth
				} else {
					lineWidth = tex.mem[int32(tex.eqtb[3412-1].hh().rh)+(2*int32(l))].int()
				}
			}
		}
		artificialDemerits = false
		shortfall = lineWidth - tex.curActiveWidth[1-1]
		if shortfall > 0 {
			if (tex.curActiveWidth[3-1] != 0) || (tex.curActiveWidth[4-1] != 0) || (tex.curActiveWidth[5-1] != 0) {
				b = 0
				fitClass = 2
			} else {
				if shortfall > 7230584 {
					if tex.curActiveWidth[2-1] < 1663497 {
						b = 10000
						fitClass = 0
						goto label31
					}
				}
				b = tex.badness(shortfall, tex.curActiveWidth[2-1])
				if b > 12 {
					if b > 99 {
						fitClass = 0
					} else {
						fitClass = 1
					}
				} else {
					fitClass = 2
				}
			label31:
			}
		} else {
			if -shortfall > tex.curActiveWidth[6-1] {
				b = 10001
			} else {
				b = tex.badness(-shortfall, tex.curActiveWidth[6-1])
			}
			if b > 12 {
				fitClass = 3
			} else {
				fitClass = 2
			}
		}
		if (b > 10000) || (pi == -10000) {
			if tex.finalPass && (tex.minimumDemerits == 1073741823) && (tex.mem[r].hh().rh == 29993) && (prevR == 29993) {
				artificialDemerits = true
			} else if int32(b) > tex.threshold {
				goto label60
			}
			nodeRStaysActive = false
		} else {
			prevR = r
			if int32(b) > tex.threshold {
				goto label22
			}
			nodeRStaysActive = true
		}
		if artificialDemerits {
			d = 0
		} else {
			d = tex.eqtb[5265-1].int() + int32(b)
			if iabs(d) >= 10000 {
				d = 100000000
			} else {
				d = (d * d)
			}
			if pi != 0 {
				if pi > 0 {
					d = d + (pi * pi)
				} else if pi > -10000 {
					d = d - (pi * pi)
				}
			}
			if (breakType == 1) && (tex.mem[r].hh().b0() == 1) {
				if tex.curP != 0 {
					d = d + tex.eqtb[5277-1].int()
				} else {
					d = d + tex.eqtb[5278-1].int()
				}
			}
			if iabs(int32(fitClass)-int32(tex.mem[r].hh().b1())) > 1 {
				d = d + tex.eqtb[5279-1].int()
			}
		}
		d = d + tex.mem[int32(r)+2].int()
		if d <= tex.minimalDemerits[fitClass] {
			tex.minimalDemerits[fitClass] = d
			tex.bestPlace[fitClass] = tex.mem[int32(r)+1].hh().rh
			tex.bestPlLine[fitClass] = l
			if d < tex.minimumDemerits {
				tex.minimumDemerits = d
			}
		}
		if nodeRStaysActive {
			goto label22
		}
	label60:
		tex.mem[prevR].pHh().rh = tex.mem[r].hh().rh
		tex.freeNode(r, 3)
		if prevR == 29993 {
			r = tex.mem[29993].hh().rh
			if tex.mem[r].hh().b0() == 2 {
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(r)+1].int()
				tex.activeWidth[2-1] = tex.activeWidth[2-1] + tex.mem[int32(r)+2].int()
				tex.activeWidth[3-1] = tex.activeWidth[3-1] + tex.mem[int32(r)+3].int()
				tex.activeWidth[4-1] = tex.activeWidth[4-1] + tex.mem[int32(r)+4].int()
				tex.activeWidth[5-1] = tex.activeWidth[5-1] + tex.mem[int32(r)+5].int()
				tex.activeWidth[6-1] = tex.activeWidth[6-1] + tex.mem[int32(r)+6].int()
				tex.curActiveWidth[1-1] = tex.activeWidth[1-1]
				tex.curActiveWidth[2-1] = tex.activeWidth[2-1]
				tex.curActiveWidth[3-1] = tex.activeWidth[3-1]
				tex.curActiveWidth[4-1] = tex.activeWidth[4-1]
				tex.curActiveWidth[5-1] = tex.activeWidth[5-1]
				tex.curActiveWidth[6-1] = tex.activeWidth[6-1]
				tex.mem[29993].pHh().rh = tex.mem[r].hh().rh
				tex.freeNode(r, 7)
			}
		} else if tex.mem[prevR].hh().b0() == 2 {
			r = tex.mem[prevR].hh().rh
			if r == 29993 {
				tex.curActiveWidth[1-1] = tex.curActiveWidth[1-1] - tex.mem[int32(prevR)+1].int()
				tex.curActiveWidth[2-1] = tex.curActiveWidth[2-1] - tex.mem[int32(prevR)+2].int()
				tex.curActiveWidth[3-1] = tex.curActiveWidth[3-1] - tex.mem[int32(prevR)+3].int()
				tex.curActiveWidth[4-1] = tex.curActiveWidth[4-1] - tex.mem[int32(prevR)+4].int()
				tex.curActiveWidth[5-1] = tex.curActiveWidth[5-1] - tex.mem[int32(prevR)+5].int()
				tex.curActiveWidth[6-1] = tex.curActiveWidth[6-1] - tex.mem[int32(prevR)+6].int()
				tex.mem[prevPrevR].pHh().rh = 29993
				tex.freeNode(prevR, 7)
				prevR = prevPrevR
			} else if tex.mem[r].hh().b0() == 2 {
				tex.curActiveWidth[1-1] = tex.curActiveWidth[1-1] + tex.mem[int32(r)+1].int()
				tex.curActiveWidth[2-1] = tex.curActiveWidth[2-1] + tex.mem[int32(r)+2].int()
				tex.curActiveWidth[3-1] = tex.curActiveWidth[3-1] + tex.mem[int32(r)+3].int()
				tex.curActiveWidth[4-1] = tex.curActiveWidth[4-1] + tex.mem[int32(r)+4].int()
				tex.curActiveWidth[5-1] = tex.curActiveWidth[5-1] + tex.mem[int32(r)+5].int()
				tex.curActiveWidth[6-1] = tex.curActiveWidth[6-1] + tex.mem[int32(r)+6].int()
				*tex.mem[int32(prevR)+1].pInt() = tex.mem[int32(prevR)+1].int() + tex.mem[int32(r)+1].int()
				*tex.mem[int32(prevR)+2].pInt() = tex.mem[int32(prevR)+2].int() + tex.mem[int32(r)+2].int()
				*tex.mem[int32(prevR)+3].pInt() = tex.mem[int32(prevR)+3].int() + tex.mem[int32(r)+3].int()
				*tex.mem[int32(prevR)+4].pInt() = tex.mem[int32(prevR)+4].int() + tex.mem[int32(r)+4].int()
				*tex.mem[int32(prevR)+5].pInt() = tex.mem[int32(prevR)+5].int() + tex.mem[int32(r)+5].int()
				*tex.mem[int32(prevR)+6].pInt() = tex.mem[int32(prevR)+6].int() + tex.mem[int32(r)+6].int()
				tex.mem[prevR].pHh().rh = tex.mem[r].hh().rh
				tex.freeNode(r, 7)
			}
		}
	}
label10:
}

func (tex *Context) postLineBreak(finalWidowPenalty int32) {
	var q, r, s uint16     // 0..65535
	var discBreak bool     // boolean
	var postDiscBreak bool // boolean
	var curWidth int32     // integer
	var curIndent int32    // integer
	var t byte             // 0..255
	var pen int32          // integer
	var curLine uint16     // 0..65535
	q = tex.mem[int32(tex.bestBet)+1].hh().rh
	tex.curP = 0
	for {
		r = q
		q = tex.mem[int32(q)+1].hh().lh()
		*tex.mem[int32(r)+1].pHh().pLh() = tex.curP
		tex.curP = r
		if q == 0 {
			break
		}
	}
	curLine = uint16(tex.curList.pgField + 1)
	for {
		q = tex.mem[int32(tex.curP)+1].hh().rh
		discBreak = false
		postDiscBreak = false
		if q != 0 {
			if tex.mem[q].hh().b0() == 10 {
				tex.deleteGlueRef(tex.mem[int32(q)+1].hh().lh())
				*tex.mem[int32(q)+1].pHh().pLh() = tex.eqtb[2890-1].hh().rh
				*tex.mem[q].pHh().pB1() = 9
				tex.mem[tex.eqtb[2890-1].hh().rh].pHh().rh = uint16(int32(tex.mem[tex.eqtb[2890-1].hh().rh].hh().rh) + 1)
				goto label30
			} else {
				if tex.mem[q].hh().b0() == 7 {
					t = tex.mem[q].hh().b1()
					if t == 0 {
						r = tex.mem[q].hh().rh
					} else {
						r = q
						for t > 1 {
							r = tex.mem[r].hh().rh
							t = byte(int32(t) - 1)
						}
						s = tex.mem[r].hh().rh
						r = tex.mem[s].hh().rh
						tex.mem[s].pHh().rh = 0
						tex.flushNodeList(tex.mem[q].hh().rh)
						*tex.mem[q].pHh().pB1() = 0
					}
					if tex.mem[int32(q)+1].hh().rh != 0 {
						s = tex.mem[int32(q)+1].hh().rh
						for tex.mem[s].hh().rh != 0 {
							s = tex.mem[s].hh().rh
						}
						tex.mem[s].pHh().rh = r
						r = tex.mem[int32(q)+1].hh().rh
						tex.mem[int32(q)+1].pHh().rh = 0
						postDiscBreak = true
					}
					if tex.mem[int32(q)+1].hh().lh() != 0 {
						s = tex.mem[int32(q)+1].hh().lh()
						tex.mem[q].pHh().rh = s
						for tex.mem[s].hh().rh != 0 {
							s = tex.mem[s].hh().rh
						}
						*tex.mem[int32(q)+1].pHh().pLh() = 0
						q = s
					}
					tex.mem[q].pHh().rh = r
					discBreak = true
				} else if (tex.mem[q].hh().b0() == 9) || (tex.mem[q].hh().b0() == 11) {
					*tex.mem[int32(q)+1].pInt() = 0
				}
			}
		} else {
			q = 29997
			for tex.mem[q].hh().rh != 0 {
				q = tex.mem[q].hh().rh
			}
		}
		r = tex.newParamGlue(8)
		tex.mem[r].pHh().rh = tex.mem[q].hh().rh
		tex.mem[q].pHh().rh = r
		q = r
	label30:
		r = tex.mem[q].hh().rh
		tex.mem[q].pHh().rh = 0
		q = tex.mem[29997].hh().rh
		tex.mem[29997].pHh().rh = r
		if tex.eqtb[2889-1].hh().rh != 0 {
			r = tex.newParamGlue(7)
			tex.mem[r].pHh().rh = q
			q = r
		}
		if curLine > tex.lastSpecialLine {
			curWidth = tex.secondWidth
			curIndent = tex.secondIndent
		} else if tex.eqtb[3412-1].hh().rh == 0 {
			curWidth = tex.firstWidth
			curIndent = tex.firstIndent
		} else {
			curWidth = tex.mem[int32(tex.eqtb[3412-1].hh().rh)+(2*int32(curLine))].int()
			curIndent = tex.mem[int32(tex.eqtb[3412-1].hh().rh)+(2*int32(curLine))-1].int()
		}
		tex.adjustTail = 29995
		tex.justBox = tex.hpack(q, curWidth, 0)
		*tex.mem[int32(tex.justBox)+4].pInt() = curIndent
		tex.appendToVlist(tex.justBox)
		if 29995 != int32(tex.adjustTail) {
			tex.mem[tex.curList.tailField].pHh().rh = tex.mem[29995].hh().rh
			tex.curList.tailField = tex.adjustTail
		}
		tex.adjustTail = 0
		if int32(curLine)+1 != int32(tex.bestLine) {
			pen = tex.eqtb[5276-1].int()
			if int32(curLine) == tex.curList.pgField+1 {
				pen = pen + tex.eqtb[5268-1].int()
			}
			if int32(curLine)+2 == int32(tex.bestLine) {
				pen = pen + finalWidowPenalty
			}
			if discBreak {
				pen = pen + tex.eqtb[5271-1].int()
			}
			if pen != 0 {
				r = tex.newPenalty(pen)
				tex.mem[tex.curList.tailField].pHh().rh = r
				tex.curList.tailField = r
			}
		}
		curLine = uint16(int32(curLine) + 1)
		tex.curP = tex.mem[int32(tex.curP)+1].hh().lh()
		if tex.curP != 0 {
			if !postDiscBreak {
				r = 29997
				for true {
					q = tex.mem[r].hh().rh
					if q == tex.mem[int32(tex.curP)+1].hh().rh {
						goto label31
					}
					if q >= tex.hiMemMin {
						goto label31
					}
					if tex.mem[q].hh().b0() < 9 {
						goto label31
					}
					if tex.mem[q].hh().b0() == 11 {
						if tex.mem[q].hh().b1() != 1 {
							goto label31
						}
					}
					r = q
				}
			label31:
				if r != 29997 {
					tex.mem[r].pHh().rh = 0
					tex.flushNodeList(tex.mem[29997].hh().rh)
					tex.mem[29997].pHh().rh = q
				}
			}
		}
		if tex.curP == 0 {
			break
		}
	}
	if (curLine != tex.bestLine) || (tex.mem[29997].hh().rh != 0) {
		tex.confusion(939)
	}
	tex.curList.pgField = int32(tex.bestLine) - 1
}

func (tex *Context) reconstitute(j, n byte, bchar, hchar uint16) (ret byte) {
	var p uint16        // 0..65535
	var t uint16        // 0..65535
	var q fourQuarters  // record fourQuarters
	var curRh uint16    // 0..65535
	var testChar uint16 // 0..65535
	var w int32         // integer
	var k uint16        // 0..20000
	tex.hyphenPassed = 0
	t = 29996
	w = 0
	tex.mem[29996].pHh().rh = 0
	tex.curL = uint16(int32(tex.hu[j]) + 0)
	tex.curQ = t
	if j == 0 {
		tex.ligaturePresent = tex.initLig
		p = tex.initList
		if tex.ligaturePresent {
			tex.lftHit = tex.initLft
		}
		for p > 0 {
			tex.mem[t].pHh().rh = tex.getAvail()
			t = tex.mem[t].hh().rh
			*tex.mem[t].pHh().pB0() = tex.hf
			*tex.mem[t].pHh().pB1() = tex.mem[p].hh().b1()
			p = tex.mem[p].hh().rh
		}
	} else if tex.curL < 256 {
		tex.mem[t].pHh().rh = tex.getAvail()
		t = tex.mem[t].hh().rh
		*tex.mem[t].pHh().pB0() = tex.hf
		*tex.mem[t].pHh().pB1() = byte(tex.curL)
	}
	tex.ligStack = 0
	if j < n {
		tex.curR = uint16(int32(tex.hu[int32(j)+1]) + 0)
	} else {
		tex.curR = bchar
	}
	if odd(int32(tex.hyf[j])) {
		curRh = hchar
	} else {
		curRh = 256
	}
label22:
	if tex.curL == 256 {
		k = tex.bcharLabel[tex.hf]
		if k == 0 {
			goto label30
		} else {
			q = tex.fontInfo[k].qqqq()
		}
	} else {
		q = tex.fontInfo[tex.charBase[tex.hf]+int32(tex.curL)].qqqq()
		if ((int32(q.b2) - 0) % 4) != 1 {
			goto label30
		}
		k = uint16(tex.ligKernBase[tex.hf] + int32(q.b3))
		q = tex.fontInfo[k].qqqq()
		if q.b0 > 128 {
			k = uint16(tex.ligKernBase[tex.hf] + (256 * int32(q.b2)) + int32(q.b3) + 32768 - (256 * 128))
			q = tex.fontInfo[k].qqqq()
		}
	}
	if curRh < 256 {
		testChar = curRh
	} else {
		testChar = tex.curR
	}
	for true {
		if uint16(q.b1) == testChar {
			if q.b0 <= 128 {
				if curRh < 256 {
					tex.hyphenPassed = j
					hchar = 256
					curRh = 256
					goto label22
				} else {
					if hchar < 256 {
						if odd(int32(tex.hyf[j])) {
							tex.hyphenPassed = j
							hchar = 256
						}
					}
					if q.b2 < 128 {
						if tex.curL == 256 {
							tex.lftHit = true
						}
						if j == n {
							if tex.ligStack == 0 {
								tex.rtHit = true
							}
						}
						if tex.interrupt != 0 {
							tex.pauseForInstructions()
						}
						switch q.b2 {
						case 1, 5:
							tex.curL = uint16(q.b3)
							tex.ligaturePresent = true
						case 2, 6:
							tex.curR = uint16(q.b3)
							if tex.ligStack > 0 {
								*tex.mem[tex.ligStack].pHh().pB1() = byte(tex.curR)
							} else {
								tex.ligStack = tex.newLigItem(byte(tex.curR))
								if j == n {
									bchar = 256
								} else {
									p = tex.getAvail()
									tex.mem[int32(tex.ligStack)+1].pHh().rh = p
									*tex.mem[p].pHh().pB1() = byte(int32(tex.hu[int32(j)+1]) + 0)
									*tex.mem[p].pHh().pB0() = tex.hf
								}
							}
						case 3:
							tex.curR = uint16(q.b3)
							p = tex.ligStack
							tex.ligStack = tex.newLigItem(byte(tex.curR))
							tex.mem[tex.ligStack].pHh().rh = p
						case 7, 11:
							if tex.ligaturePresent {
								p = tex.newLigature(tex.hf, byte(tex.curL), tex.mem[tex.curQ].hh().rh)
								if tex.lftHit {
									*tex.mem[p].pHh().pB1() = 2
									tex.lftHit = false
								}
								if false {
									if tex.ligStack == 0 {
										*tex.mem[p].pHh().pB1() = byte(int32(tex.mem[p].hh().b1()) + 1)
										tex.rtHit = false
									}
								}
								tex.mem[tex.curQ].pHh().rh = p
								t = p
								tex.ligaturePresent = false
							}
							tex.curQ = t
							tex.curL = uint16(q.b3)
							tex.ligaturePresent = true
						default:
							tex.curL = uint16(q.b3)
							tex.ligaturePresent = true
							if tex.ligStack > 0 {
								if tex.mem[int32(tex.ligStack)+1].hh().rh > 0 {
									tex.mem[t].pHh().rh = tex.mem[int32(tex.ligStack)+1].hh().rh
									t = tex.mem[t].hh().rh
									j = byte(int32(j) + 1)
								}
								p = tex.ligStack
								tex.ligStack = tex.mem[p].hh().rh
								tex.freeNode(p, 2)
								if tex.ligStack == 0 {
									if j < n {
										tex.curR = uint16(int32(tex.hu[int32(j)+1]) + 0)
									} else {
										tex.curR = bchar
									}
									if odd(int32(tex.hyf[j])) {
										curRh = hchar
									} else {
										curRh = 256
									}
								} else {
									tex.curR = uint16(tex.mem[tex.ligStack].hh().b1())
								}
							} else if j == n {
								goto label30
							} else {
								tex.mem[t].pHh().rh = tex.getAvail()
								t = tex.mem[t].hh().rh
								*tex.mem[t].pHh().pB0() = tex.hf
								*tex.mem[t].pHh().pB1() = byte(tex.curR)
								j = byte(int32(j) + 1)
								if j < n {
									tex.curR = uint16(int32(tex.hu[int32(j)+1]) + 0)
								} else {
									tex.curR = bchar
								}
								if odd(int32(tex.hyf[j])) {
									curRh = hchar
								} else {
									curRh = 256
								}
							}
						}
						if q.b2 > 4 {
							if q.b2 != 7 {
								goto label30
							}
						}
						goto label22
					}
					w = tex.fontInfo[tex.kernBase[tex.hf]+(256*int32(q.b2))+int32(q.b3)].int()
					goto label30
				}
			}
		}
		if q.b0 >= 128 {
			if curRh == 256 {
				goto label30
			} else {
				curRh = 256
				goto label22
			}
		}
		k = uint16(int32(k) + int32(q.b0) + 1)
		q = tex.fontInfo[k].qqqq()
	}
label30:
	if tex.ligaturePresent {
		p = tex.newLigature(tex.hf, byte(tex.curL), tex.mem[tex.curQ].hh().rh)
		if tex.lftHit {
			*tex.mem[p].pHh().pB1() = 2
			tex.lftHit = false
		}
		if tex.rtHit {
			if tex.ligStack == 0 {
				*tex.mem[p].pHh().pB1() = byte(int32(tex.mem[p].hh().b1()) + 1)
				tex.rtHit = false
			}
		}
		tex.mem[tex.curQ].pHh().rh = p
		t = p
		tex.ligaturePresent = false
	}
	if w != 0 {
		tex.mem[t].pHh().rh = tex.newKern(w)
		t = tex.mem[t].hh().rh
		w = 0
	}
	if tex.ligStack > 0 {
		tex.curQ = t
		tex.curL = uint16(tex.mem[tex.ligStack].hh().b1())
		tex.ligaturePresent = true
		if tex.mem[int32(tex.ligStack)+1].hh().rh > 0 {
			tex.mem[t].pHh().rh = tex.mem[int32(tex.ligStack)+1].hh().rh
			t = tex.mem[t].hh().rh
			j = byte(int32(j) + 1)
		}
		p = tex.ligStack
		tex.ligStack = tex.mem[p].hh().rh
		tex.freeNode(p, 2)
		if tex.ligStack == 0 {
			if j < n {
				tex.curR = uint16(int32(tex.hu[int32(j)+1]) + 0)
			} else {
				tex.curR = bchar
			}
			if odd(int32(tex.hyf[j])) {
				curRh = hchar
			} else {
				curRh = 256
			}
		} else {
			tex.curR = uint16(tex.mem[tex.ligStack].hh().b1())
		}
		goto label22
	}
	ret = j
	return ret
}

func (tex *Context) hyphenate() {
	var i, j, l byte                // 0..65
	var q, r, s uint16              // 0..65535
	var bchar uint16                // 0..65535
	var majorTail, minorTail uint16 // 0..65535
	var c byte                      // 0..255
	var cLoc byte                   // 0..63
	var rCount int32                // integer
	var hyfNode uint16              // 0..65535
	var z uint16                    // 0..8000
	var v int32                     // integer
	var h uint16                    // 0..307
	var k uint16                    // 0..3000
	var u uint16                    // 0..32000
	for _i := int64(0); _i <= int64(tex.hn); _i++ {
		j = byte(_i)
		tex.hyf[j] = 0
	}
	h = tex.hc[1]
	tex.hn = byte(int32(tex.hn) + 1)
	tex.hc[tex.hn] = uint16(tex.curLang)
	for _i := int64(2); _i <= int64(tex.hn); _i++ {
		j = byte(_i)
		h = uint16(((int32(h) + int32(h) + int32(tex.hc[j])) % 307))
	}
	for true {
		k = tex.hyphWord[h]
		if k == 0 {
			goto label45
		}
		if (int32(tex.strStart[int32(k)+1]) - int32(tex.strStart[k])) < int32(tex.hn) {
			goto label45
		}
		if (int32(tex.strStart[int32(k)+1]) - int32(tex.strStart[k])) == int32(tex.hn) {
			j = 1
			u = tex.strStart[k]
			for {
				if uint16(tex.strPool[u]) < tex.hc[j] {
					goto label45
				}
				if uint16(tex.strPool[u]) > tex.hc[j] {
					goto label30
				}
				j = byte(int32(j) + 1)
				u = uint16(int32(u) + 1)
				if j > tex.hn {
					break
				}
			}
			s = tex.hyphList[h]
			for s != 0 {
				tex.hyf[tex.mem[s].hh().lh()] = 1
				s = tex.mem[s].hh().rh
			}
			tex.hn = byte(int32(tex.hn) - 1)
			goto label40
		}
	label30:
		if h > 0 {
			h = uint16(int32(h) - 1)
		} else {
			h = 307
		}
	}
label45:
	tex.hn = byte(int32(tex.hn) - 1)
	if int32(tex.trie[int32(tex.curLang)+1].b1()) != int32(tex.curLang)+0 {
		goto label10
	}
	tex.hc[0] = 0
	tex.hc[int32(tex.hn)+1] = 0
	tex.hc[int32(tex.hn)+2] = 256
	for _i := int64(0); _i <= int64(int32(tex.hn)-tex.rHyf+1); _i++ {
		j = byte(_i)
		z = uint16(int32(tex.trie[int32(tex.curLang)+1].rh) + int32(tex.hc[j]))
		l = j
		for int32(tex.hc[l]) == int32(tex.trie[z].b1())-0 {
			if tex.trie[z].b0() != 0 {
				v = int32(tex.trie[z].b0())
				for {
					v = v + int32(tex.opStart[tex.curLang])
					i = byte(int32(l) - int32(tex.hyfDistance[v-1]))
					if tex.hyfNum[v-1] > tex.hyf[i] {
						tex.hyf[i] = tex.hyfNum[v-1]
					}
					v = int32(tex.hyfNext[v-1])
					if v == 0 {
						break
					}
				}
			}
			l = byte(int32(l) + 1)
			z = uint16(int32(tex.trie[z].rh) + int32(tex.hc[l]))
		}
	}
label40:
	for _i := int64(0); _i <= int64(tex.lHyf-1); _i++ {
		j = byte(_i)
		tex.hyf[j] = 0
	}
	for _i := int64(0); _i <= int64(tex.rHyf-1); _i++ {
		j = byte(_i)
		tex.hyf[int32(tex.hn)-int32(j)] = 0
	}
	for _i := int64(tex.lHyf); _i <= int64(int32(tex.hn)-tex.rHyf); _i++ {
		j = byte(_i)
		if odd(int32(tex.hyf[j])) {
			goto label41
		}
	}
	goto label10
label41:
	q = tex.mem[tex.hb].hh().rh
	tex.mem[tex.hb].pHh().rh = 0
	r = tex.mem[tex.ha].hh().rh
	tex.mem[tex.ha].pHh().rh = 0
	bchar = tex.hyfBchar
	if tex.ha >= tex.hiMemMin {
		if tex.mem[tex.ha].hh().b0() != tex.hf {
			goto label42
		} else {
			tex.initList = tex.ha
			tex.initLig = false
			tex.hu[0] = uint16(int32(tex.mem[tex.ha].hh().b1()) - 0)
		}
	} else if tex.mem[tex.ha].hh().b0() == 6 {
		if tex.mem[int32(tex.ha)+1].hh().b0() != tex.hf {
			goto label42
		} else {
			tex.initList = tex.mem[int32(tex.ha)+1].hh().rh
			tex.initLig = true
			tex.initLft = (tex.mem[tex.ha].hh().b1() > 1)
			tex.hu[0] = uint16(int32(tex.mem[int32(tex.ha)+1].hh().b1()) - 0)
			if tex.initList == 0 {
				if tex.initLft {
					tex.hu[0] = 256
					tex.initLig = false
				}
			}
			tex.freeNode(tex.ha, 2)
		}
	} else {
		if !(r >= tex.hiMemMin) {
			if tex.mem[r].hh().b0() == 6 {
				if tex.mem[r].hh().b1() > 1 {
					goto label42
				}
			}
		}
		j = 1
		s = tex.ha
		tex.initList = 0
		goto label50
	}
	s = tex.curP
	for tex.mem[s].hh().rh != tex.ha {
		s = tex.mem[s].hh().rh
	}
	j = 0
	goto label50
label42:
	s = tex.ha
	j = 0
	tex.hu[0] = 256
	tex.initLig = false
	tex.initList = 0
label50:
	tex.flushNodeList(r)
	for {
		l = j
		j = byte(int32(tex.reconstitute(j, tex.hn, bchar, uint16(tex.hyfChar+0))) + 1)
		if tex.hyphenPassed == 0 {
			tex.mem[s].pHh().rh = tex.mem[29996].hh().rh
			for tex.mem[s].hh().rh > 0 {
				s = tex.mem[s].hh().rh
			}
			if odd(int32(tex.hyf[int32(j)-1])) {
				l = j
				tex.hyphenPassed = byte(int32(j) - 1)
				tex.mem[29996].pHh().rh = 0
			}
		}
		if tex.hyphenPassed > 0 {
			for {
				r = tex.getNode(2)
				tex.mem[r].pHh().rh = tex.mem[29996].hh().rh
				*tex.mem[r].pHh().pB0() = 7
				majorTail = r
				rCount = 0
				for tex.mem[majorTail].hh().rh > 0 {
					majorTail = tex.mem[majorTail].hh().rh
					rCount = rCount + 1
				}
				i = tex.hyphenPassed
				tex.hyf[i] = 0
				minorTail = 0
				*tex.mem[int32(r)+1].pHh().pLh() = 0
				hyfNode = tex.newCharacter(tex.hf, byte(tex.hyfChar))
				if hyfNode != 0 {
					i = byte(int32(i) + 1)
					c = byte(tex.hu[i])
					tex.hu[i] = uint16(tex.hyfChar)
					tex.mem[hyfNode].pHh().rh = tex.avail
					tex.avail = hyfNode
				}
				for l <= i {
					l = byte(int32(tex.reconstitute(l, i, tex.fontBchar[tex.hf], 256)) + 1)
					if tex.mem[29996].hh().rh > 0 {
						if minorTail == 0 {
							*tex.mem[int32(r)+1].pHh().pLh() = tex.mem[29996].hh().rh
						} else {
							tex.mem[minorTail].pHh().rh = tex.mem[29996].hh().rh
						}
						minorTail = tex.mem[29996].hh().rh
						for tex.mem[minorTail].hh().rh > 0 {
							minorTail = tex.mem[minorTail].hh().rh
						}
					}
				}
				if hyfNode != 0 {
					tex.hu[i] = uint16(c)
					l = i
					i = byte(int32(i) - 1)
				}
				minorTail = 0
				tex.mem[int32(r)+1].pHh().rh = 0
				cLoc = 0
				if tex.bcharLabel[tex.hf] != 0 {
					l = byte(int32(l) - 1)
					c = byte(tex.hu[l])
					cLoc = l
					tex.hu[l] = 256
				}
				for l < j {
					for {
						l = byte(int32(tex.reconstitute(l, tex.hn, bchar, 256)) + 1)
						if cLoc > 0 {
							tex.hu[cLoc] = uint16(c)
							cLoc = 0
						}
						if tex.mem[29996].hh().rh > 0 {
							if minorTail == 0 {
								tex.mem[int32(r)+1].pHh().rh = tex.mem[29996].hh().rh
							} else {
								tex.mem[minorTail].pHh().rh = tex.mem[29996].hh().rh
							}
							minorTail = tex.mem[29996].hh().rh
							for tex.mem[minorTail].hh().rh > 0 {
								minorTail = tex.mem[minorTail].hh().rh
							}
						}
						if l >= j {
							break
						}
					}
					for l > j {
						j = byte(int32(tex.reconstitute(j, tex.hn, bchar, 256)) + 1)
						tex.mem[majorTail].pHh().rh = tex.mem[29996].hh().rh
						for tex.mem[majorTail].hh().rh > 0 {
							majorTail = tex.mem[majorTail].hh().rh
							rCount = rCount + 1
						}
					}
				}
				if rCount > 127 {
					tex.mem[s].pHh().rh = tex.mem[r].hh().rh
					tex.mem[r].pHh().rh = 0
					tex.flushNodeList(r)
				} else {
					tex.mem[s].pHh().rh = r
					*tex.mem[r].pHh().pB1() = byte(rCount)
				}
				s = majorTail
				tex.hyphenPassed = byte(int32(j) - 1)
				tex.mem[29996].pHh().rh = 0
				if !odd(int32(tex.hyf[int32(j)-1])) {
					break
				}
			}
		}
		if j > tex.hn {
			break
		}
	}
	tex.mem[s].pHh().rh = q
	tex.flushList(tex.initList)
label10:
}

func (tex *Context) newTrieOp(d, n byte, v byte) (ret byte) {
	var h int16  // -500..500
	var u byte   // 0..255
	var l uint16 // 0..500
	h = int16((iabs(int32(n)+(313*int32(d))+(361*int32(v))+(1009*int32(tex.curLang))) % (trieOpSize + trieOpSize)) - trieOpSize)
	for true {
		l = tex.trieOpHash[h+500]
		if l == 0 {
			if tex.trieOpPtr == trieOpSize {
				tex.overflow(949, trieOpSize)
			}
			u = tex.trieUsed[tex.curLang]
			if u == 255 {
				tex.overflow(950, 255)
			}
			tex.trieOpPtr = uint16(int32(tex.trieOpPtr) + 1)
			u = byte(int32(u) + 1)
			tex.trieUsed[tex.curLang] = u
			tex.hyfDistance[tex.trieOpPtr-1] = d
			tex.hyfNum[tex.trieOpPtr-1] = n
			tex.hyfNext[tex.trieOpPtr-1] = v
			tex.trieOpLang[tex.trieOpPtr-1] = tex.curLang
			tex.trieOpHash[h+500] = tex.trieOpPtr
			tex.trieOpVal[tex.trieOpPtr-1] = u
			ret = u
			goto label10
		}
		if (tex.hyfDistance[l-1] == d) && (tex.hyfNum[l-1] == n) && (tex.hyfNext[l-1] == v) && (tex.trieOpLang[l-1] == tex.curLang) {
			ret = tex.trieOpVal[l-1]
			goto label10
		}
		if h > -trieOpSize {
			h = int16(int32(h) - 1)
		} else {
			h = trieOpSize
		}
	}
label10:
	return ret
}

func (tex *Context) trieNode(p uint16) (ret uint16) {
	var h uint16 // 0..8000
	var q uint16 // 0..8000
	h = uint16((iabs(int32(tex.trieC[p])+(1009*int32(tex.trieO[p]))+(2718*int32(tex.trieL[p]))+(3142*int32(tex.trieR[p]))) % trieSize))
	for true {
		q = tex.trieHash[h]
		if q == 0 {
			tex.trieHash[h] = p
			ret = p
			goto label10
		}
		if (tex.trieC[q] == tex.trieC[p]) && (tex.trieO[q] == tex.trieO[p]) && (tex.trieL[q] == tex.trieL[p]) && (tex.trieR[q] == tex.trieR[p]) {
			ret = q
			goto label10
		}
		if h > 0 {
			h = uint16(int32(h) - 1)
		} else {
			h = trieSize
		}
	}
label10:
	return ret
}

func (tex *Context) compressTrie(p uint16) (ret uint16) {
	if p == 0 {
		ret = 0
	} else {
		tex.trieL[p] = tex.compressTrie(tex.trieL[p])
		tex.trieR[p] = tex.compressTrie(tex.trieR[p])
		ret = tex.trieNode(p)
	}
	return ret
}

func (tex *Context) firstFit(p uint16) {
	var h uint16    // 0..8000
	var z uint16    // 0..8000
	var q uint16    // 0..8000
	var c byte      // 0..255
	var l, r uint16 // 0..8000
	var ll uint16   // 1..256
	c = tex.trieC[p]
	z = tex.trieMin[c]
	for true {
		h = uint16(int32(z) - int32(c))
		if int32(tex.trieMax) < int32(h)+256 {
			if trieSize <= int32(h)+256 {
				tex.overflow(951, trieSize)
			}
			for {
				tex.trieMax = uint16(int32(tex.trieMax) + 1)
				tex.trieTaken[tex.trieMax-1] = false
				tex.trie[tex.trieMax].rh = uint16(int32(tex.trieMax) + 1)
				*tex.trie[tex.trieMax].pLh() = uint16(int32(tex.trieMax) - 1)
				if int32(tex.trieMax) == int32(h)+256 {
					break
				}
			}
		}
		if tex.trieTaken[h-1] {
			goto label45
		}
		q = tex.trieR[p]
		for q > 0 {
			if tex.trie[int32(h)+int32(tex.trieC[q])].rh == 0 {
				goto label45
			}
			q = tex.trieR[q]
		}
		goto label40
	label45:
		z = tex.trie[z].rh
	}
label40:
	tex.trieTaken[h-1] = true
	tex.trieHash[p] = h
	q = p
	for {
		z = uint16(int32(h) + int32(tex.trieC[q]))
		l = tex.trie[z].lh()
		r = tex.trie[z].rh
		*tex.trie[r].pLh() = l
		tex.trie[l].rh = r
		tex.trie[z].rh = 0
		if l < 256 {
			if z < 256 {
				ll = z
			} else {
				ll = 256
			}
			for {
				tex.trieMin[l] = r
				l = uint16(int32(l) + 1)
				if l == ll {
					break
				}
			}
		}
		q = tex.trieR[q]
		if q == 0 {
			break
		}
	}
}

func (tex *Context) triePack(p uint16) {
	var q uint16 // 0..8000
	for {
		q = tex.trieL[p]
		if (q > 0) && (tex.trieHash[q] == 0) {
			tex.firstFit(q)
			tex.triePack(q)
		}
		p = tex.trieR[p]
		if p == 0 {
			break
		}
	}
}

func (tex *Context) trieFix(p uint16) {
	var q uint16 // 0..8000
	var c byte   // 0..255
	var z uint16 // 0..8000
	z = tex.trieHash[p]
	for {
		q = tex.trieL[p]
		c = tex.trieC[p]
		tex.trie[int32(z)+int32(c)].rh = tex.trieHash[q]
		*tex.trie[int32(z)+int32(c)].pB1() = byte(int32(c) + 0)
		*tex.trie[int32(z)+int32(c)].pB0() = tex.trieO[p]
		if q > 0 {
			tex.trieFix(q)
		}
		p = tex.trieR[p]
		if p == 0 {
			break
		}
	}
}

func (tex *Context) newPatterns() {
	var k, l byte        // 0..64
	var digitSensed bool // boolean
	var v byte           // 0..255
	var p, q uint16      // 0..8000
	var firstChild bool  // boolean
	var c byte           // 0..255
	if tex.trieNotReady {
		if tex.eqtb[5313-1].int() <= 0 {
			tex.curLang = 0
		} else if tex.eqtb[5313-1].int() > 255 {
			tex.curLang = 0
		} else {
			tex.curLang = byte(tex.eqtb[5313-1].int())
		}
		tex.scanLeftBrace()
		k = 0
		tex.hyf[0] = 0
		digitSensed = false
		for true {
			tex.getXToken()
			switch tex.curCmd {
			case 11, 12:
				if digitSensed || (tex.curChr < 48) || (tex.curChr > 57) {
					if tex.curChr == 46 {
						tex.curChr = 0
					} else {
						tex.curChr = tex.eqtb[4239+int32(tex.curChr)-1].hh().rh
						if tex.curChr == 0 {
							if tex.interaction == 3 {
							}
							tex.printNl(262)
							tex.print(957)
							tex.helpPtr = 1
							tex.helpLine[0] = 956
							tex.error1()
						}
					}
					if k < 63 {
						k = byte(int32(k) + 1)
						tex.hc[k] = tex.curChr
						tex.hyf[k] = 0
						digitSensed = false
					}
				} else if k < 63 {
					tex.hyf[k] = byte(int32(tex.curChr) - 48)
					digitSensed = true
				}
			case 10, 2:
				if k > 0 {
					if tex.hc[1] == 0 {
						tex.hyf[0] = 0
					}
					if tex.hc[k] == 0 {
						tex.hyf[k] = 0
					}
					l = k
					v = 0
					for true {
						if tex.hyf[l] != 0 {
							v = tex.newTrieOp(byte(int32(k)-int32(l)), tex.hyf[l], v)
						}
						if l > 0 {
							l = byte(int32(l) - 1)
						} else {
							goto label31
						}
					}
				label31:
					q = 0
					tex.hc[0] = uint16(tex.curLang)
					for l <= k {
						c = byte(tex.hc[l])
						l = byte(int32(l) + 1)
						p = tex.trieL[q]
						firstChild = true
						for (p > 0) && (c > tex.trieC[p]) {
							q = p
							p = tex.trieR[q]
							firstChild = false
						}
						if (p == 0) || (c < tex.trieC[p]) {
							if tex.triePtr == trieSize {
								tex.overflow(951, trieSize)
							}
							tex.triePtr = uint16(int32(tex.triePtr) + 1)
							tex.trieR[tex.triePtr] = p
							p = tex.triePtr
							tex.trieL[p] = 0
							if firstChild {
								tex.trieL[q] = p
							} else {
								tex.trieR[q] = p
							}
							tex.trieC[p] = c
							tex.trieO[p] = 0
						}
						q = p
					}
					if tex.trieO[q] != 0 {
						if tex.interaction == 3 {
						}
						tex.printNl(262)
						tex.print(958)
						tex.helpPtr = 1
						tex.helpLine[0] = 956
						tex.error1()
					}
					tex.trieO[q] = v
				}
				if tex.curCmd == 2 {
					goto label30
				}
				k = 0
				tex.hyf[0] = 0
				digitSensed = false
			default:
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(955)
				tex.printEsc(953)
				tex.helpPtr = 1
				tex.helpLine[0] = 956
				tex.error1()
			}
		}
	label30:
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(952)
		tex.printEsc(953)
		tex.helpPtr = 1
		tex.helpLine[0] = 954
		tex.error1()
		tex.mem[29988].pHh().rh = tex.scanToks(false, false)
		tex.flushList(tex.defRef)
	}
}

func (tex *Context) initTrie() {
	var p uint16      // 0..8000
	var j, k, t int32 // integer
	var r, s uint16   // 0..8000
	var h twoHalves   // record twoHalves
	tex.opStart[0] = -0
	for _i := int64(1); _i <= int64(255); _i++ {
		j = int32(_i)
		tex.opStart[j] = uint16(int32(tex.opStart[j-1]) + int32(tex.trieUsed[j-1]) - 0)
	}
	for _i := int64(1); _i <= int64(tex.trieOpPtr); _i++ {
		j = int32(_i)
		tex.trieOpHash[j+500] = uint16(int32(tex.opStart[tex.trieOpLang[j-1]]) + int32(tex.trieOpVal[j-1]))
	}
	for _i := int64(1); _i <= int64(tex.trieOpPtr); _i++ {
		j = int32(_i)
		for int32(tex.trieOpHash[j+500]) > j {
			k = int32(tex.trieOpHash[j+500])
			t = int32(tex.hyfDistance[k-1])
			tex.hyfDistance[k-1] = tex.hyfDistance[j-1]
			tex.hyfDistance[j-1] = byte(t)
			t = int32(tex.hyfNum[k-1])
			tex.hyfNum[k-1] = tex.hyfNum[j-1]
			tex.hyfNum[j-1] = byte(t)
			t = int32(tex.hyfNext[k-1])
			tex.hyfNext[k-1] = tex.hyfNext[j-1]
			tex.hyfNext[j-1] = byte(t)
			tex.trieOpHash[j+500] = tex.trieOpHash[k+500]
			tex.trieOpHash[k+500] = uint16(k)
		}
	}
	for _i := int64(0); _i <= int64(trieSize); _i++ {
		p = uint16(_i)
		tex.trieHash[p] = 0
	}
	tex.trieL[0] = tex.compressTrie(tex.trieL[0])
	for _i := int64(0); _i <= int64(tex.triePtr); _i++ {
		p = uint16(_i)
		tex.trieHash[p] = 0
	}
	for _i := int64(0); _i <= int64(255); _i++ {
		p = uint16(_i)
		tex.trieMin[p] = uint16(int32(p) + 1)
	}
	tex.trie[0].rh = 1
	tex.trieMax = 0
	if tex.trieL[0] != 0 {
		tex.firstFit(tex.trieL[0])
		tex.triePack(tex.trieL[0])
	}
	h.rh = 0
	*h.pB0() = 0
	*h.pB1() = 0
	if tex.trieL[0] == 0 {
		for _i := int64(0); _i <= int64(256); _i++ {
			r = uint16(_i)
			tex.trie[r] = h
		}
		tex.trieMax = 256
	} else {
		tex.trieFix(tex.trieL[0])
		r = 0
		for {
			s = tex.trie[r].rh
			tex.trie[r] = h
			r = s
			if r > tex.trieMax {
				break
			}
		}
	}
	*tex.trie[0].pB1() = 63
	tex.trieNotReady = false
}

func (tex *Context) lineBreak(finalWidowPenalty int32) {
	var autoBreaking bool     // boolean
	var prevP uint16          // 0..65535
	var q, r, s, prevS uint16 // 0..65535
	var f byte                // 0..75
	var j byte                // 0..63
	var c byte                // 0..255
	tex.packBeginLine = tex.curList.mlField
	tex.mem[29997].pHh().rh = tex.mem[tex.curList.headField].hh().rh
	if tex.curList.tailField >= tex.hiMemMin {
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(10000)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	} else if tex.mem[tex.curList.tailField].hh().b0() != 10 {
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(10000)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	} else {
		*tex.mem[tex.curList.tailField].pHh().pB0() = 12
		tex.deleteGlueRef(tex.mem[int32(tex.curList.tailField)+1].hh().lh())
		tex.flushNodeList(tex.mem[int32(tex.curList.tailField)+1].hh().rh)
		*tex.mem[int32(tex.curList.tailField)+1].pInt() = 10000
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(14)
	tex.initCurLang = byte((tex.curList.pgField % 65536))
	tex.initLHyf = (tex.curList.pgField / 4194304)
	tex.initRHyf = ((tex.curList.pgField / 65536) % 64)
	tex.popNest()
	tex.noShrinkErrorYet = true
	if (tex.mem[tex.eqtb[2889-1].hh().rh].hh().b1() != 0) && (tex.mem[int32(tex.eqtb[2889-1].hh().rh)+3].int() != 0) {
		tex.eqtb[2889-1].pHh().rh = tex.finiteShrink(tex.eqtb[2889-1].hh().rh)
	}
	if (tex.mem[tex.eqtb[2890-1].hh().rh].hh().b1() != 0) && (tex.mem[int32(tex.eqtb[2890-1].hh().rh)+3].int() != 0) {
		tex.eqtb[2890-1].pHh().rh = tex.finiteShrink(tex.eqtb[2890-1].hh().rh)
	}
	q = tex.eqtb[2889-1].hh().rh
	r = tex.eqtb[2890-1].hh().rh
	tex.background[1-1] = tex.mem[int32(q)+1].int() + tex.mem[int32(r)+1].int()
	tex.background[2-1] = 0
	tex.background[3-1] = 0
	tex.background[4-1] = 0
	tex.background[5-1] = 0
	tex.background[2+int32(tex.mem[q].hh().b0())-1] = tex.mem[int32(q)+2].int()
	tex.background[2+int32(tex.mem[r].hh().b0())-1] = tex.background[2+int32(tex.mem[r].hh().b0())-1] + tex.mem[int32(r)+2].int()
	tex.background[6-1] = tex.mem[int32(q)+3].int() + tex.mem[int32(r)+3].int()
	tex.minimumDemerits = 1073741823
	tex.minimalDemerits[3] = 1073741823
	tex.minimalDemerits[2] = 1073741823
	tex.minimalDemerits[1] = 1073741823
	tex.minimalDemerits[0] = 1073741823
	if tex.eqtb[3412-1].hh().rh == 0 {
		if tex.eqtb[5847-1].int() == 0 {
			tex.lastSpecialLine = 0
			tex.secondWidth = tex.eqtb[5833-1].int()
			tex.secondIndent = 0
		} else {
			tex.lastSpecialLine = uint16(iabs(tex.eqtb[5304-1].int()))
			if tex.eqtb[5304-1].int() < 0 {
				tex.firstWidth = tex.eqtb[5833-1].int() - iabs(tex.eqtb[5847-1].int())
				if tex.eqtb[5847-1].int() >= 0 {
					tex.firstIndent = tex.eqtb[5847-1].int()
				} else {
					tex.firstIndent = 0
				}
				tex.secondWidth = tex.eqtb[5833-1].int()
				tex.secondIndent = 0
			} else {
				tex.firstWidth = tex.eqtb[5833-1].int()
				tex.firstIndent = 0
				tex.secondWidth = tex.eqtb[5833-1].int() - iabs(tex.eqtb[5847-1].int())
				if tex.eqtb[5847-1].int() >= 0 {
					tex.secondIndent = tex.eqtb[5847-1].int()
				} else {
					tex.secondIndent = 0
				}
			}
		}
	} else {
		tex.lastSpecialLine = uint16(int32(tex.mem[tex.eqtb[3412-1].hh().rh].hh().lh()) - 1)
		tex.secondWidth = tex.mem[int32(tex.eqtb[3412-1].hh().rh)+(2*(int32(tex.lastSpecialLine)+1))].int()
		tex.secondIndent = tex.mem[int32(tex.eqtb[3412-1].hh().rh)+(2*int32(tex.lastSpecialLine))+1].int()
	}
	if tex.eqtb[5282-1].int() == 0 {
		tex.easyLine = tex.lastSpecialLine
	} else {
		tex.easyLine = 65535
	}
	tex.threshold = tex.eqtb[5263-1].int()
	if tex.threshold >= 0 {
		tex.secondPass = false
		tex.finalPass = false
	} else {
		tex.threshold = tex.eqtb[5264-1].int()
		tex.secondPass = true
		tex.finalPass = (tex.eqtb[5850-1].int() <= 0)
	}
	for true {
		if tex.threshold > 10000 {
			tex.threshold = 10000
		}
		if tex.secondPass {
			if tex.trieNotReady {
				tex.initTrie()
			}
			tex.curLang = tex.initCurLang
			tex.lHyf = tex.initLHyf
			tex.rHyf = tex.initRHyf
		}
		q = tex.getNode(3)
		*tex.mem[q].pHh().pB0() = 0
		*tex.mem[q].pHh().pB1() = 2
		tex.mem[q].pHh().rh = 29993
		tex.mem[int32(q)+1].pHh().rh = 0
		*tex.mem[int32(q)+1].pHh().pLh() = uint16(tex.curList.pgField + 1)
		*tex.mem[int32(q)+2].pInt() = 0
		tex.mem[29993].pHh().rh = q
		tex.activeWidth[1-1] = tex.background[1-1]
		tex.activeWidth[2-1] = tex.background[2-1]
		tex.activeWidth[3-1] = tex.background[3-1]
		tex.activeWidth[4-1] = tex.background[4-1]
		tex.activeWidth[5-1] = tex.background[5-1]
		tex.activeWidth[6-1] = tex.background[6-1]
		tex.passive = 0
		tex.printedNode = 29997
		tex.passNumber = 0
		tex.fontInShortDisplay = 0
		tex.curP = tex.mem[29997].hh().rh
		autoBreaking = true
		prevP = tex.curP
		for (tex.curP != 0) && (tex.mem[29993].hh().rh != 29993) {
			if tex.curP >= tex.hiMemMin {
				prevP = tex.curP
				for {
					f = tex.mem[tex.curP].hh().b0()
					tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[tex.curP].hh().b1())].qqqq().b0)].int()
					tex.curP = tex.mem[tex.curP].hh().rh
					if !(tex.curP >= tex.hiMemMin) {
						break
					}
				}
			}
			switch tex.mem[tex.curP].hh().b0() {
			case 0, 1, 2:
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(tex.curP)+1].int()
			case 8:
				if tex.mem[tex.curP].hh().b1() == 4 {
					tex.curLang = byte(tex.mem[int32(tex.curP)+1].hh().rh)
					tex.lHyf = int32(tex.mem[int32(tex.curP)+1].hh().b0())
					tex.rHyf = int32(tex.mem[int32(tex.curP)+1].hh().b1())
				}
			case 10:
				if autoBreaking {
					if prevP >= tex.hiMemMin {
						tex.tryBreak(0, 0)
					} else if tex.mem[prevP].hh().b0() < 9 {
						tex.tryBreak(0, 0)
					} else if (tex.mem[prevP].hh().b0() == 11) && (tex.mem[prevP].hh().b1() != 1) {
						tex.tryBreak(0, 0)
					}
				}
				if (tex.mem[tex.mem[int32(tex.curP)+1].hh().lh()].hh().b1() != 0) && (tex.mem[int32(tex.mem[int32(tex.curP)+1].hh().lh())+3].int() != 0) {
					*tex.mem[int32(tex.curP)+1].pHh().pLh() = tex.finiteShrink(tex.mem[int32(tex.curP)+1].hh().lh())
				}
				q = tex.mem[int32(tex.curP)+1].hh().lh()
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(q)+1].int()
				tex.activeWidth[2+int32(tex.mem[q].hh().b0())-1] = tex.activeWidth[2+int32(tex.mem[q].hh().b0())-1] + tex.mem[int32(q)+2].int()
				tex.activeWidth[6-1] = tex.activeWidth[6-1] + tex.mem[int32(q)+3].int()
				if tex.secondPass && autoBreaking {
					prevS = tex.curP
					s = tex.mem[prevS].hh().rh
					if s != 0 {
						for true {
							if s >= tex.hiMemMin {
								c = byte(int32(tex.mem[s].hh().b1()) - 0)
								tex.hf = tex.mem[s].hh().b0()
							} else if tex.mem[s].hh().b0() == 6 {
								if tex.mem[int32(s)+1].hh().rh == 0 {
									goto label22
								} else {
									q = tex.mem[int32(s)+1].hh().rh
									c = byte(int32(tex.mem[q].hh().b1()) - 0)
									tex.hf = tex.mem[q].hh().b0()
								}
							} else if (tex.mem[s].hh().b0() == 11) && (tex.mem[s].hh().b1() == 0) {
								goto label22
							} else if tex.mem[s].hh().b0() == 8 {
								if tex.mem[s].hh().b1() == 4 {
									tex.curLang = byte(tex.mem[int32(s)+1].hh().rh)
									tex.lHyf = int32(tex.mem[int32(s)+1].hh().b0())
									tex.rHyf = int32(tex.mem[int32(s)+1].hh().b1())
								}
								goto label22
							} else {
								goto label31
							}
							if tex.eqtb[4239+int32(c)-1].hh().rh != 0 {
								if (tex.eqtb[4239+int32(c)-1].hh().rh == uint16(c)) || (tex.eqtb[5301-1].int() > 0) {
									goto label32
								} else {
									goto label31
								}
							}
						label22:
							prevS = s
							s = tex.mem[prevS].hh().rh
						}
					label32:
						tex.hyfChar = tex.hyphenChar[tex.hf]
						if tex.hyfChar < 0 {
							goto label31
						}
						if tex.hyfChar > 255 {
							goto label31
						}
						tex.ha = prevS
						if tex.lHyf+tex.rHyf > 63 {
							goto label31
						}
						tex.hn = 0
						for true {
							if s >= tex.hiMemMin {
								if tex.mem[s].hh().b0() != tex.hf {
									goto label33
								}
								tex.hyfBchar = uint16(tex.mem[s].hh().b1())
								c = byte(int32(tex.hyfBchar) - 0)
								if tex.eqtb[4239+int32(c)-1].hh().rh == 0 {
									goto label33
								}
								if tex.hn == 63 {
									goto label33
								}
								tex.hb = s
								tex.hn = byte(int32(tex.hn) + 1)
								tex.hu[tex.hn] = uint16(c)
								tex.hc[tex.hn] = tex.eqtb[4239+int32(c)-1].hh().rh
								tex.hyfBchar = 256
							} else if tex.mem[s].hh().b0() == 6 {
								if tex.mem[int32(s)+1].hh().b0() != tex.hf {
									goto label33
								}
								j = tex.hn
								q = tex.mem[int32(s)+1].hh().rh
								if q > 0 {
									tex.hyfBchar = uint16(tex.mem[q].hh().b1())
								}
								for q > 0 {
									c = byte(int32(tex.mem[q].hh().b1()) - 0)
									if tex.eqtb[4239+int32(c)-1].hh().rh == 0 {
										goto label33
									}
									if j == 63 {
										goto label33
									}
									j = byte(int32(j) + 1)
									tex.hu[j] = uint16(c)
									tex.hc[j] = tex.eqtb[4239+int32(c)-1].hh().rh
									q = tex.mem[q].hh().rh
								}
								tex.hb = s
								tex.hn = j
								if odd(int32(tex.mem[s].hh().b1())) {
									tex.hyfBchar = tex.fontBchar[tex.hf]
								} else {
									tex.hyfBchar = 256
								}
							} else if (tex.mem[s].hh().b0() == 11) && (tex.mem[s].hh().b1() == 0) {
								tex.hb = s
								tex.hyfBchar = tex.fontBchar[tex.hf]
							} else {
								goto label33
							}
							s = tex.mem[s].hh().rh
						}
					label33:
						if int32(tex.hn) < tex.lHyf+tex.rHyf {
							goto label31
						}
						for true {
							if !(s >= tex.hiMemMin) {
								switch tex.mem[s].hh().b0() {
								case 6:
								case 11:
									if tex.mem[s].hh().b1() != 0 {
										goto label34
									}
								case 8, 10, 12, 3, 5, 4:
									goto label34
								default:
									goto label31
								}
							}
							s = tex.mem[s].hh().rh
						}
					label34:
						tex.hyphenate()
					}
				label31:
				}
			case 11:
				if tex.mem[tex.curP].hh().b1() == 1 {
					if !(tex.mem[tex.curP].hh().rh >= tex.hiMemMin) && autoBreaking {
						if tex.mem[tex.mem[tex.curP].hh().rh].hh().b0() == 10 {
							tex.tryBreak(0, 0)
						}
					}
					tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(tex.curP)+1].int()
				} else {
					tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(tex.curP)+1].int()
				}
			case 6:
				f = tex.mem[int32(tex.curP)+1].hh().b0()
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[int32(tex.curP)+1].hh().b1())].qqqq().b0)].int()
			case 7:
				s = tex.mem[int32(tex.curP)+1].hh().lh()
				tex.discWidth = 0
				if s == 0 {
					tex.tryBreak(tex.eqtb[5267-1].int(), 1)
				} else {
					for {
						if s >= tex.hiMemMin {
							f = tex.mem[s].hh().b0()
							tex.discWidth = tex.discWidth + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[s].hh().b1())].qqqq().b0)].int()
						} else {
							switch tex.mem[s].hh().b0() {
							case 6:
								f = tex.mem[int32(s)+1].hh().b0()
								tex.discWidth = tex.discWidth + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[int32(s)+1].hh().b1())].qqqq().b0)].int()
							case 0, 1, 2, 11:
								tex.discWidth = tex.discWidth + tex.mem[int32(s)+1].int()
							default:
								tex.confusion(937)
							}
						}
						s = tex.mem[s].hh().rh
						if s == 0 {
							break
						}
					}
					tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.discWidth
					tex.tryBreak(tex.eqtb[5266-1].int(), 1)
					tex.activeWidth[1-1] = tex.activeWidth[1-1] - tex.discWidth
				}
				r = uint16(tex.mem[tex.curP].hh().b1())
				s = tex.mem[tex.curP].hh().rh
				for r > 0 {
					if s >= tex.hiMemMin {
						f = tex.mem[s].hh().b0()
						tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[s].hh().b1())].qqqq().b0)].int()
					} else {
						switch tex.mem[s].hh().b0() {
						case 6:
							f = tex.mem[int32(s)+1].hh().b0()
							tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[int32(s)+1].hh().b1())].qqqq().b0)].int()
						case 0, 1, 2, 11:
							tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(s)+1].int()
						default:
							tex.confusion(938)
						}
					}
					r = uint16(int32(r) - 1)
					s = tex.mem[s].hh().rh
				}
				prevP = tex.curP
				tex.curP = s
				goto label35
			case 9:
				autoBreaking = (tex.mem[tex.curP].hh().b1() == 1)
				if !(tex.mem[tex.curP].hh().rh >= tex.hiMemMin) && autoBreaking {
					if tex.mem[tex.mem[tex.curP].hh().rh].hh().b0() == 10 {
						tex.tryBreak(0, 0)
					}
				}
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + tex.mem[int32(tex.curP)+1].int()
			case 12:
				tex.tryBreak(tex.mem[int32(tex.curP)+1].int(), 0)
			case 4, 3, 5:
			default:
				tex.confusion(936)
			}
			prevP = tex.curP
			tex.curP = tex.mem[tex.curP].hh().rh
		label35:
		}
		if tex.curP == 0 {
			tex.tryBreak(-10000, 1)
			if tex.mem[29993].hh().rh != 29993 {
				r = tex.mem[29993].hh().rh
				tex.fewestDemerits = 1073741823
				for {
					if tex.mem[r].hh().b0() != 2 {
						if tex.mem[int32(r)+2].int() < tex.fewestDemerits {
							tex.fewestDemerits = tex.mem[int32(r)+2].int()
							tex.bestBet = r
						}
					}
					r = tex.mem[r].hh().rh
					if r == 29993 {
						break
					}
				}
				tex.bestLine = tex.mem[int32(tex.bestBet)+1].hh().lh()
				if tex.eqtb[5282-1].int() == 0 {
					goto label30
				}
				r = tex.mem[29993].hh().rh
				tex.actualLooseness = 0
				for {
					if tex.mem[r].hh().b0() != 2 {
						tex.lineDiff = int32(tex.mem[int32(r)+1].hh().lh()) - int32(tex.bestLine)
						if ((tex.lineDiff < tex.actualLooseness) && (tex.eqtb[5282-1].int() <= tex.lineDiff)) || ((tex.lineDiff > tex.actualLooseness) && (tex.eqtb[5282-1].int() >= tex.lineDiff)) {
							tex.bestBet = r
							tex.actualLooseness = tex.lineDiff
							tex.fewestDemerits = tex.mem[int32(r)+2].int()
						} else if (tex.lineDiff == tex.actualLooseness) && (tex.mem[int32(r)+2].int() < tex.fewestDemerits) {
							tex.bestBet = r
							tex.fewestDemerits = tex.mem[int32(r)+2].int()
						}
					}
					r = tex.mem[r].hh().rh
					if r == 29993 {
						break
					}
				}
				tex.bestLine = tex.mem[int32(tex.bestBet)+1].hh().lh()
				if (tex.actualLooseness == tex.eqtb[5282-1].int()) || tex.finalPass {
					goto label30
				}
			}
		}
		q = tex.mem[29993].hh().rh
		for q != 29993 {
			tex.curP = tex.mem[q].hh().rh
			if tex.mem[q].hh().b0() == 2 {
				tex.freeNode(q, 7)
			} else {
				tex.freeNode(q, 3)
			}
			q = tex.curP
		}
		q = tex.passive
		for q != 0 {
			tex.curP = tex.mem[q].hh().rh
			tex.freeNode(q, 2)
			q = tex.curP
		}
		if !tex.secondPass {
			tex.threshold = tex.eqtb[5264-1].int()
			tex.secondPass = true
			tex.finalPass = (tex.eqtb[5850-1].int() <= 0)
		} else {
			tex.background[2-1] = tex.background[2-1] + tex.eqtb[5850-1].int()
			tex.finalPass = true
		}
	}
label30:
	tex.postLineBreak(finalWidowPenalty)
	q = tex.mem[29993].hh().rh
	for q != 29993 {
		tex.curP = tex.mem[q].hh().rh
		if tex.mem[q].hh().b0() == 2 {
			tex.freeNode(q, 7)
		} else {
			tex.freeNode(q, 3)
		}
		q = tex.curP
	}
	q = tex.passive
	for q != 0 {
		tex.curP = tex.mem[q].hh().rh
		tex.freeNode(q, 2)
		q = tex.curP
	}
	tex.packBeginLine = 0
}

func (tex *Context) newHyphExceptions() {
	var n byte      // 0..64
	var j byte      // 0..64
	var h uint16    // 0..307
	var k uint16    // 0..3000
	var p uint16    // 0..65535
	var q uint16    // 0..65535
	var s, t uint16 // 0..3000
	var u, v uint16 // 0..32000
	tex.scanLeftBrace()
	if tex.eqtb[5313-1].int() <= 0 {
		tex.curLang = 0
	} else if tex.eqtb[5313-1].int() > 255 {
		tex.curLang = 0
	} else {
		tex.curLang = byte(tex.eqtb[5313-1].int())
	}
	n = 0
	p = 0
	for true {
		tex.getXToken()
	label21:
		switch tex.curCmd {
		case 11, 12, 68:
			if tex.curChr == 45 {
				if n < 63 {
					q = tex.getAvail()
					tex.mem[q].pHh().rh = p
					*tex.mem[q].pHh().pLh() = uint16(n)
					p = q
				}
			} else {
				if tex.eqtb[4239+int32(tex.curChr)-1].hh().rh == 0 {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(945)
					tex.helpPtr = 2
					tex.helpLine[1] = 946
					tex.helpLine[0] = 947
					tex.error1()
				} else if n < 63 {
					n = byte(int32(n) + 1)
					tex.hc[n] = tex.eqtb[4239+int32(tex.curChr)-1].hh().rh
				}
			}
		case 16:
			tex.scanCharNum()
			tex.curChr = uint16(tex.curVal)
			tex.curCmd = 68
			goto label21
		case 10, 2:
			if n > 1 {
				n = byte(int32(n) + 1)
				tex.hc[n] = uint16(tex.curLang)
				if int32(tex.poolPtr)+int32(n) > poolSize {
					tex.overflow(257, poolSize-int32(tex.initPoolPtr))
				}
				h = 0
				for _i := int64(1); _i <= int64(n); _i++ {
					j = byte(_i)
					h = uint16(((int32(h) + int32(h) + int32(tex.hc[j])) % 307))
					tex.strPool[tex.poolPtr] = byte(tex.hc[j])
					tex.poolPtr = uint16(int32(tex.poolPtr) + 1)
				}
				s = tex.makeString()
				if tex.hyphCount == 307 {
					tex.overflow(948, 307)
				}
				tex.hyphCount = uint16(int32(tex.hyphCount) + 1)
				for tex.hyphWord[h] != 0 {
					k = tex.hyphWord[h]
					if (int32(tex.strStart[int32(k)+1]) - int32(tex.strStart[k])) < (int32(tex.strStart[int32(s)+1]) - int32(tex.strStart[s])) {
						goto label40
					}
					if (int32(tex.strStart[int32(k)+1]) - int32(tex.strStart[k])) > (int32(tex.strStart[int32(s)+1]) - int32(tex.strStart[s])) {
						goto label45
					}
					u = tex.strStart[k]
					v = tex.strStart[s]
					for {
						if tex.strPool[u] < tex.strPool[v] {
							goto label40
						}
						if tex.strPool[u] > tex.strPool[v] {
							goto label45
						}
						u = uint16(int32(u) + 1)
						v = uint16(int32(v) + 1)
						if u == tex.strStart[int32(k)+1] {
							break
						}
					}
				label40:
					q = tex.hyphList[h]
					tex.hyphList[h] = p
					p = q
					t = tex.hyphWord[h]
					tex.hyphWord[h] = s
					s = t
				label45:
					if h > 0 {
						h = uint16(int32(h) - 1)
					} else {
						h = 307
					}
				}
				tex.hyphWord[h] = s
				tex.hyphList[h] = p
			}
			if tex.curCmd == 2 {
				goto label10
			}
			n = 0
			p = 0
		default:
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(680)
			tex.printEsc(941)
			tex.print(942)
			tex.helpPtr = 2
			tex.helpLine[1] = 943
			tex.helpLine[0] = 944
			tex.error1()
		}
	}
label10:
}

func (tex *Context) prunePageTop(p uint16) (ret uint16) {
	var prevP uint16 // 0..65535
	var q uint16     // 0..65535
	prevP = 29997
	tex.mem[29997].pHh().rh = p
	for p != 0 {
		switch tex.mem[p].hh().b0() {
		case 0, 1, 2:
			q = tex.newSkipParam(10)
			tex.mem[prevP].pHh().rh = q
			tex.mem[q].pHh().rh = p
			if tex.mem[int32(tex.tempPtr)+1].int() > tex.mem[int32(p)+3].int() {
				*tex.mem[int32(tex.tempPtr)+1].pInt() = tex.mem[int32(tex.tempPtr)+1].int() - tex.mem[int32(p)+3].int()
			} else {
				*tex.mem[int32(tex.tempPtr)+1].pInt() = 0
			}
			p = 0
		case 8, 4, 3:
			prevP = p
			p = tex.mem[prevP].hh().rh
		case 10, 11, 12:
			q = p
			p = tex.mem[q].hh().rh
			tex.mem[q].pHh().rh = 0
			tex.mem[prevP].pHh().rh = p
			tex.flushNodeList(q)
		default:
			tex.confusion(959)
		}
	}
	ret = tex.mem[29997].hh().rh
	return ret
}

func (tex *Context) vertBreak(p uint16, h, d int32) (ret uint16) {
	var prevP uint16     // 0..65535
	var q, r uint16      // 0..65535
	var pi int32         // integer
	var b int32          // integer
	var leastCost int32  // integer
	var bestPlace uint16 // 0..65535
	var prevDp int32     // integer
	var t byte           // 0..63
	prevP = p
	leastCost = 1073741823
	tex.activeWidth[1-1] = 0
	tex.activeWidth[2-1] = 0
	tex.activeWidth[3-1] = 0
	tex.activeWidth[4-1] = 0
	tex.activeWidth[5-1] = 0
	tex.activeWidth[6-1] = 0
	prevDp = 0
	for true {
		if p == 0 {
			pi = -10000
		} else {
			switch tex.mem[p].hh().b0() {
			case 0, 1, 2:
				tex.activeWidth[1-1] = tex.activeWidth[1-1] + prevDp + tex.mem[int32(p)+3].int()
				prevDp = tex.mem[int32(p)+2].int()
				goto label45
			case 8:
				goto label45
			case 10:
				if tex.mem[prevP].hh().b0() < 9 {
					pi = 0
				} else {
					goto label90
				}
			case 11:
				if tex.mem[p].hh().rh == 0 {
					t = 12
				} else {
					t = tex.mem[tex.mem[p].hh().rh].hh().b0()
				}
				if t == 10 {
					pi = 0
				} else {
					goto label90
				}
			case 12:
				pi = tex.mem[int32(p)+1].int()
			case 4, 3:
				goto label45
			default:
				tex.confusion(960)
			}
		}
		if pi < 10000 {
			if tex.activeWidth[1-1] < h {
				if (tex.activeWidth[3-1] != 0) || (tex.activeWidth[4-1] != 0) || (tex.activeWidth[5-1] != 0) {
					b = 0
				} else {
					b = int32(tex.badness(h-tex.activeWidth[1-1], tex.activeWidth[2-1]))
				}
			} else if tex.activeWidth[1-1]-h > tex.activeWidth[6-1] {
				b = 1073741823
			} else {
				b = int32(tex.badness(tex.activeWidth[1-1]-h, tex.activeWidth[6-1]))
			}
			if b < 1073741823 {
				if pi <= -10000 {
					b = pi
				} else if b < 10000 {
					b = b + pi
				} else {
					b = 100000
				}
			}
			if b <= leastCost {
				bestPlace = p
				leastCost = b
				tex.bestHeightPlusDepth = tex.activeWidth[1-1] + prevDp
			}
			if (b == 1073741823) || (pi <= -10000) {
				goto label30
			}
		}
		if (tex.mem[p].hh().b0() < 10) || (tex.mem[p].hh().b0() > 11) {
			goto label45
		}
	label90:
		if tex.mem[p].hh().b0() == 11 {
			q = p
		} else {
			q = tex.mem[int32(p)+1].hh().lh()
			tex.activeWidth[2+int32(tex.mem[q].hh().b0())-1] = tex.activeWidth[2+int32(tex.mem[q].hh().b0())-1] + tex.mem[int32(q)+2].int()
			tex.activeWidth[6-1] = tex.activeWidth[6-1] + tex.mem[int32(q)+3].int()
			if (tex.mem[q].hh().b1() != 0) && (tex.mem[int32(q)+3].int() != 0) {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(961)
				tex.helpPtr = 4
				tex.helpLine[3] = 962
				tex.helpLine[2] = 963
				tex.helpLine[1] = 964
				tex.helpLine[0] = 922
				tex.error1()
				r = tex.newSpec(q)
				*tex.mem[r].pHh().pB1() = 0
				tex.deleteGlueRef(q)
				*tex.mem[int32(p)+1].pHh().pLh() = r
				q = r
			}
		}
		tex.activeWidth[1-1] = tex.activeWidth[1-1] + prevDp + tex.mem[int32(q)+1].int()
		prevDp = 0
	label45:
		if prevDp > d {
			tex.activeWidth[1-1] = tex.activeWidth[1-1] + prevDp - d
			prevDp = d
		}
		prevP = p
		p = tex.mem[prevP].hh().rh
	}
label30:
	ret = bestPlace
	return ret
}

func (tex *Context) vsplit(n byte, h int32) (ret uint16) {
	var v uint16 // 0..65535
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	v = tex.eqtb[3678+int32(n)-1].hh().rh
	if tex.curMark[3] != 0 {
		tex.deleteTokenRef(tex.curMark[3])
		tex.curMark[3] = 0
		tex.deleteTokenRef(tex.curMark[4])
		tex.curMark[4] = 0
	}
	if v == 0 {
		ret = 0
		goto label10
	}
	if tex.mem[v].hh().b0() != 1 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(338)
		tex.printEsc(965)
		tex.print(966)
		tex.printEsc(967)
		tex.helpPtr = 2
		tex.helpLine[1] = 968
		tex.helpLine[0] = 969
		tex.error1()
		ret = 0
		goto label10
	}
	q = tex.vertBreak(tex.mem[int32(v)+5].hh().rh, h, tex.eqtb[5836-1].int())
	p = tex.mem[int32(v)+5].hh().rh
	if p == q {
		tex.mem[int32(v)+5].pHh().rh = 0
	} else {
		for true {
			if tex.mem[p].hh().b0() == 4 {
				if tex.curMark[3] == 0 {
					tex.curMark[3] = uint16(tex.mem[int32(p)+1].int())
					tex.curMark[4] = tex.curMark[3]
					*tex.mem[tex.curMark[3]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[3]].hh().lh()) + 2)
				} else {
					tex.deleteTokenRef(tex.curMark[4])
					tex.curMark[4] = uint16(tex.mem[int32(p)+1].int())
					*tex.mem[tex.curMark[4]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[4]].hh().lh()) + 1)
				}
			}
			if tex.mem[p].hh().rh == q {
				tex.mem[p].pHh().rh = 0
				goto label30
			}
			p = tex.mem[p].hh().rh
		}
	}
label30:
	q = tex.prunePageTop(q)
	p = tex.mem[int32(v)+5].hh().rh
	tex.freeNode(v, 7)
	if q == 0 {
		tex.eqtb[3678+int32(n)-1].pHh().rh = 0
	} else {
		tex.eqtb[3678+int32(n)-1].pHh().rh = tex.vpackage(q, 0, 1, 1073741823)
	}
	ret = tex.vpackage(p, h, 0, tex.eqtb[5836-1].int())
label10:
	return ret
}

func (tex *Context) printTotals() {
	tex.printScaled(tex.pageSoFar[1])
	if tex.pageSoFar[2] != 0 {
		tex.print(312)
		tex.printScaled(tex.pageSoFar[2])
		tex.print(338)
	}
	if tex.pageSoFar[3] != 0 {
		tex.print(312)
		tex.printScaled(tex.pageSoFar[3])
		tex.print(311)
	}
	if tex.pageSoFar[4] != 0 {
		tex.print(312)
		tex.printScaled(tex.pageSoFar[4])
		tex.print(978)
	}
	if tex.pageSoFar[5] != 0 {
		tex.print(312)
		tex.printScaled(tex.pageSoFar[5])
		tex.print(979)
	}
	if tex.pageSoFar[6] != 0 {
		tex.print(313)
		tex.printScaled(tex.pageSoFar[6])
	}
}

func (tex *Context) freezePageSpecs(s byte) {
	tex.pageContents = s
	tex.pageSoFar[0] = tex.eqtb[5834-1].int()
	tex.pageMaxDepth = tex.eqtb[5835-1].int()
	tex.pageSoFar[7] = 0
	tex.pageSoFar[1] = 0
	tex.pageSoFar[2] = 0
	tex.pageSoFar[3] = 0
	tex.pageSoFar[4] = 0
	tex.pageSoFar[5] = 0
	tex.pageSoFar[6] = 0
	tex.leastPageCost = 1073741823
}

func (tex *Context) boxError(n byte) {
	tex.error1()
	tex.beginDiagnostic()
	tex.printNl(836)
	tex.showBox(tex.eqtb[3678+int32(n)-1].hh().rh)
	tex.endDiagnostic(true)
	tex.flushNodeList(tex.eqtb[3678+int32(n)-1].hh().rh)
	tex.eqtb[3678+int32(n)-1].pHh().rh = 0
}

func (tex *Context) ensureVbox(n byte) {
	var p uint16 // 0..65535
	p = tex.eqtb[3678+int32(n)-1].hh().rh
	if p != 0 {
		if tex.mem[p].hh().b0() == 0 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(989)
			tex.helpPtr = 3
			tex.helpLine[2] = 990
			tex.helpLine[1] = 991
			tex.helpLine[0] = 992
			tex.boxError(n)
		}
	}
}

func (tex *Context) fireUp(c uint16) {
	var p, q, r, s uint16       // 0..65535
	var prevP uint16            // 0..65535
	var n byte                  // 0..255
	var wait bool               // boolean
	var saveVbadness int32      // integer
	var saveVfuzz int32         // integer
	var saveSplitTopSkip uint16 // 0..65535
	if tex.mem[tex.bestPageBreak].hh().b0() == 12 {
		tex.geqWordDefine(5302, tex.mem[int32(tex.bestPageBreak)+1].int())
		*tex.mem[int32(tex.bestPageBreak)+1].pInt() = 10000
	} else {
		tex.geqWordDefine(5302, 10000)
	}
	if tex.curMark[2] != 0 {
		if tex.curMark[0] != 0 {
			tex.deleteTokenRef(tex.curMark[0])
		}
		tex.curMark[0] = tex.curMark[2]
		*tex.mem[tex.curMark[0]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[0]].hh().lh()) + 1)
		tex.deleteTokenRef(tex.curMark[1])
		tex.curMark[1] = 0
	}
	if c == tex.bestPageBreak {
		tex.bestPageBreak = 0
	}
	if tex.eqtb[3933-1].hh().rh != 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(338)
		tex.printEsc(409)
		tex.print(1003)
		tex.helpPtr = 2
		tex.helpLine[1] = 1004
		tex.helpLine[0] = 992
		tex.boxError(255)
	}
	tex.insertPenalties = 0
	saveSplitTopSkip = tex.eqtb[2892-1].hh().rh
	if tex.eqtb[5316-1].int() <= 0 {
		r = tex.mem[30000].hh().rh
		for r != 30000 {
			if tex.mem[int32(r)+2].hh().lh() != 0 {
				n = byte(int32(tex.mem[r].hh().b1()) - 0)
				tex.ensureVbox(n)
				if tex.eqtb[3678+int32(n)-1].hh().rh == 0 {
					tex.eqtb[3678+int32(n)-1].pHh().rh = tex.newNullBox()
				}
				p = uint16(int32(tex.eqtb[3678+int32(n)-1].hh().rh) + 5)
				for tex.mem[p].hh().rh != 0 {
					p = tex.mem[p].hh().rh
				}
				tex.mem[int32(r)+2].pHh().rh = p
			}
			r = tex.mem[r].hh().rh
		}
	}
	q = 29996
	tex.mem[q].pHh().rh = 0
	prevP = 29998
	p = tex.mem[prevP].hh().rh
	for p != tex.bestPageBreak {
		if tex.mem[p].hh().b0() == 3 {
			if tex.eqtb[5316-1].int() <= 0 {
				r = tex.mem[30000].hh().rh
				for tex.mem[r].hh().b1() != tex.mem[p].hh().b1() {
					r = tex.mem[r].hh().rh
				}
				if tex.mem[int32(r)+2].hh().lh() == 0 {
					wait = true
				} else {
					wait = false
					s = tex.mem[int32(r)+2].hh().rh
					tex.mem[s].pHh().rh = tex.mem[int32(p)+4].hh().lh()
					if tex.mem[int32(r)+2].hh().lh() == p {
						if tex.mem[r].hh().b0() == 1 {
							if (tex.mem[int32(r)+1].hh().lh() == p) && (tex.mem[int32(r)+1].hh().rh != 0) {
								for tex.mem[s].hh().rh != tex.mem[int32(r)+1].hh().rh {
									s = tex.mem[s].hh().rh
								}
								tex.mem[s].pHh().rh = 0
								tex.eqtb[2892-1].pHh().rh = tex.mem[int32(p)+4].hh().rh
								*tex.mem[int32(p)+4].pHh().pLh() = tex.prunePageTop(tex.mem[int32(r)+1].hh().rh)
								if tex.mem[int32(p)+4].hh().lh() != 0 {
									tex.tempPtr = tex.vpackage(tex.mem[int32(p)+4].hh().lh(), 0, 1, 1073741823)
									*tex.mem[int32(p)+3].pInt() = tex.mem[int32(tex.tempPtr)+3].int() + tex.mem[int32(tex.tempPtr)+2].int()
									tex.freeNode(tex.tempPtr, 7)
									wait = true
								}
							}
						}
						*tex.mem[int32(r)+2].pHh().pLh() = 0
						n = byte(int32(tex.mem[r].hh().b1()) - 0)
						tex.tempPtr = tex.mem[int32(tex.eqtb[3678+int32(n)-1].hh().rh)+5].hh().rh
						tex.freeNode(tex.eqtb[3678+int32(n)-1].hh().rh, 7)
						tex.eqtb[3678+int32(n)-1].pHh().rh = tex.vpackage(tex.tempPtr, 0, 1, 1073741823)
					} else {
						for tex.mem[s].hh().rh != 0 {
							s = tex.mem[s].hh().rh
						}
						tex.mem[int32(r)+2].pHh().rh = s
					}
				}
				tex.mem[prevP].pHh().rh = tex.mem[p].hh().rh
				tex.mem[p].pHh().rh = 0
				if wait {
					tex.mem[q].pHh().rh = p
					q = p
					tex.insertPenalties = tex.insertPenalties + 1
				} else {
					tex.deleteGlueRef(tex.mem[int32(p)+4].hh().rh)
					tex.freeNode(p, 5)
				}
				p = prevP
			}
		} else if tex.mem[p].hh().b0() == 4 {
			if tex.curMark[1] == 0 {
				tex.curMark[1] = uint16(tex.mem[int32(p)+1].int())
				*tex.mem[tex.curMark[1]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[1]].hh().lh()) + 1)
			}
			if tex.curMark[2] != 0 {
				tex.deleteTokenRef(tex.curMark[2])
			}
			tex.curMark[2] = uint16(tex.mem[int32(p)+1].int())
			*tex.mem[tex.curMark[2]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[2]].hh().lh()) + 1)
		}
		prevP = p
		p = tex.mem[prevP].hh().rh
	}
	tex.eqtb[2892-1].pHh().rh = saveSplitTopSkip
	if p != 0 {
		if tex.mem[29999].hh().rh == 0 {
			if tex.nestPtr == 0 {
				tex.curList.tailField = tex.pageTail
			} else {
				tex.nest[0].tailField = tex.pageTail
			}
		}
		tex.mem[tex.pageTail].pHh().rh = tex.mem[29999].hh().rh
		tex.mem[29999].pHh().rh = p
		tex.mem[prevP].pHh().rh = 0
	}
	saveVbadness = tex.eqtb[5290-1].int()
	*tex.eqtb[5290-1].pInt() = 10000
	saveVfuzz = tex.eqtb[5839-1].int()
	*tex.eqtb[5839-1].pInt() = 1073741823
	tex.eqtb[3933-1].pHh().rh = tex.vpackage(tex.mem[29998].hh().rh, tex.bestSize, 0, tex.pageMaxDepth)
	*tex.eqtb[5290-1].pInt() = saveVbadness
	*tex.eqtb[5839-1].pInt() = saveVfuzz
	if tex.lastGlue != 65535 {
		tex.deleteGlueRef(tex.lastGlue)
	}
	tex.pageContents = 0
	tex.pageTail = 29998
	tex.mem[29998].pHh().rh = 0
	tex.lastGlue = 65535
	tex.lastPenalty = 0
	tex.lastKern = 0
	tex.pageSoFar[7] = 0
	tex.pageMaxDepth = 0
	if q != 29996 {
		tex.mem[29998].pHh().rh = tex.mem[29996].hh().rh
		tex.pageTail = q
	}
	r = tex.mem[30000].hh().rh
	for r != 30000 {
		q = tex.mem[r].hh().rh
		tex.freeNode(r, 4)
		r = q
	}
	tex.mem[30000].pHh().rh = 30000
	if (tex.curMark[0] != 0) && (tex.curMark[1] == 0) {
		tex.curMark[1] = tex.curMark[0]
		*tex.mem[tex.curMark[0]].pHh().pLh() = uint16(int32(tex.mem[tex.curMark[0]].hh().lh()) + 1)
	}
	if tex.eqtb[3413-1].hh().rh != 0 {
		if tex.deadCycles >= tex.eqtb[5303-1].int() {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1005)
			tex.printInt(tex.deadCycles)
			tex.print(1006)
			tex.helpPtr = 3
			tex.helpLine[2] = 1007
			tex.helpLine[1] = 1008
			tex.helpLine[0] = 1009
			tex.error1()
		} else {
			tex.outputActive = true
			tex.deadCycles = tex.deadCycles + 1
			tex.pushNest()
			tex.curList.modeField = -1
			*tex.curList.auxField.pInt() = -65536000
			tex.curList.mlField = -tex.line
			tex.beginTokenList(tex.eqtb[3413-1].hh().rh, 6)
			tex.newSaveLevel(8)
			tex.normalParagraph()
			tex.scanLeftBrace()
			goto label10
		}
	}
	if tex.mem[29998].hh().rh != 0 {
		if tex.mem[29999].hh().rh == 0 {
			if tex.nestPtr == 0 {
				tex.curList.tailField = tex.pageTail
			} else {
				tex.nest[0].tailField = tex.pageTail
			}
		} else {
			tex.mem[tex.pageTail].pHh().rh = tex.mem[29999].hh().rh
		}
		tex.mem[29999].pHh().rh = tex.mem[29998].hh().rh
		tex.mem[29998].pHh().rh = 0
		tex.pageTail = 29998
	}
	tex.shipOut(tex.eqtb[3933-1].hh().rh)
	tex.eqtb[3933-1].pHh().rh = 0
label10:
}

func (tex *Context) buildPage() {
	var p uint16          // 0..65535
	var q, r uint16       // 0..65535
	var b, c int32        // integer
	var pi int32          // integer
	var n byte            // 0..255
	var delta, h, w int32 // integer
	if (tex.mem[29999].hh().rh == 0) || tex.outputActive {
		goto label10
	}
	for {
	label22:
		p = tex.mem[29999].hh().rh
		if tex.lastGlue != 65535 {
			tex.deleteGlueRef(tex.lastGlue)
		}
		tex.lastPenalty = 0
		tex.lastKern = 0
		if tex.mem[p].hh().b0() == 10 {
			tex.lastGlue = tex.mem[int32(p)+1].hh().lh()
			tex.mem[tex.lastGlue].pHh().rh = uint16(int32(tex.mem[tex.lastGlue].hh().rh) + 1)
		} else {
			tex.lastGlue = 65535
			if tex.mem[p].hh().b0() == 12 {
				tex.lastPenalty = tex.mem[int32(p)+1].int()
			} else if tex.mem[p].hh().b0() == 11 {
				tex.lastKern = tex.mem[int32(p)+1].int()
			}
		}
		switch tex.mem[p].hh().b0() {
		case 0, 1, 2:
			if tex.pageContents < 2 {
				if tex.pageContents == 0 {
					tex.freezePageSpecs(2)
				} else {
					tex.pageContents = 2
				}
				q = tex.newSkipParam(9)
				if tex.mem[int32(tex.tempPtr)+1].int() > tex.mem[int32(p)+3].int() {
					*tex.mem[int32(tex.tempPtr)+1].pInt() = tex.mem[int32(tex.tempPtr)+1].int() - tex.mem[int32(p)+3].int()
				} else {
					*tex.mem[int32(tex.tempPtr)+1].pInt() = 0
				}
				tex.mem[q].pHh().rh = p
				tex.mem[29999].pHh().rh = q
				goto label22
			} else {
				tex.pageSoFar[1] = tex.pageSoFar[1] + tex.pageSoFar[7] + tex.mem[int32(p)+3].int()
				tex.pageSoFar[7] = tex.mem[int32(p)+2].int()
				goto label80
			}
		case 8:
			goto label80
		case 10:
			if tex.pageContents < 2 {
				goto label31
			} else if tex.mem[tex.pageTail].hh().b0() < 9 {
				pi = 0
			} else {
				goto label90
			}
		case 11:
			if tex.pageContents < 2 {
				goto label31
			} else if tex.mem[p].hh().rh == 0 {
				goto label10
			} else if tex.mem[tex.mem[p].hh().rh].hh().b0() == 10 {
				pi = 0
			} else {
				goto label90
			}
		case 12:
			if tex.pageContents < 2 {
				goto label31
			} else {
				pi = tex.mem[int32(p)+1].int()
			}
		case 4:
			goto label80
		case 3:
			if tex.pageContents == 0 {
				tex.freezePageSpecs(1)
			}
			n = tex.mem[p].hh().b1()
			r = 30000
			for n >= tex.mem[tex.mem[r].hh().rh].hh().b1() {
				r = tex.mem[r].hh().rh
			}
			n = byte(int32(n) - 0)
			if int32(tex.mem[r].hh().b1()) != int32(n)+0 {
				q = tex.getNode(4)
				tex.mem[q].pHh().rh = tex.mem[r].hh().rh
				tex.mem[r].pHh().rh = q
				r = q
				*tex.mem[r].pHh().pB1() = byte(int32(n) + 0)
				*tex.mem[r].pHh().pB0() = 0
				tex.ensureVbox(n)
				if tex.eqtb[3678+int32(n)-1].hh().rh == 0 {
					*tex.mem[int32(r)+3].pInt() = 0
				} else {
					*tex.mem[int32(r)+3].pInt() = tex.mem[int32(tex.eqtb[3678+int32(n)-1].hh().rh)+3].int() + tex.mem[int32(tex.eqtb[3678+int32(n)-1].hh().rh)+2].int()
				}
				*tex.mem[int32(r)+2].pHh().pLh() = 0
				q = tex.eqtb[2900+int32(n)-1].hh().rh
				if tex.eqtb[5318+int32(n)-1].int() == 1000 {
					h = tex.mem[int32(r)+3].int()
				} else {
					h = (tex.xOverN(tex.mem[int32(r)+3].int(), 1000) * tex.eqtb[5318+int32(n)-1].int())
				}
				tex.pageSoFar[0] = tex.pageSoFar[0] - h - tex.mem[int32(q)+1].int()
				tex.pageSoFar[2+int32(tex.mem[q].hh().b0())] = tex.pageSoFar[2+int32(tex.mem[q].hh().b0())] + tex.mem[int32(q)+2].int()
				tex.pageSoFar[6] = tex.pageSoFar[6] + tex.mem[int32(q)+3].int()
				if (tex.mem[q].hh().b1() != 0) && (tex.mem[int32(q)+3].int() != 0) {
					if tex.interaction == 3 {
					}
					tex.printNl(262)
					tex.print(998)
					tex.printEsc(395)
					tex.printInt(int32(n))
					tex.helpPtr = 3
					tex.helpLine[2] = 999
					tex.helpLine[1] = 1000
					tex.helpLine[0] = 922
					tex.error1()
				}
			}
			if tex.mem[r].hh().b0() == 1 {
				tex.insertPenalties = tex.insertPenalties + tex.mem[int32(p)+1].int()
			} else {
				tex.mem[int32(r)+2].pHh().rh = p
				delta = tex.pageSoFar[0] - tex.pageSoFar[1] - tex.pageSoFar[7] + tex.pageSoFar[6]
				if tex.eqtb[5318+int32(n)-1].int() == 1000 {
					h = tex.mem[int32(p)+3].int()
				} else {
					h = (tex.xOverN(tex.mem[int32(p)+3].int(), 1000) * tex.eqtb[5318+int32(n)-1].int())
				}
				if ((h <= 0) || (h <= delta)) && ((tex.mem[int32(p)+3].int() + tex.mem[int32(r)+3].int()) <= tex.eqtb[5851+int32(n)-1].int()) {
					tex.pageSoFar[0] = tex.pageSoFar[0] - h
					*tex.mem[int32(r)+3].pInt() = tex.mem[int32(r)+3].int() + tex.mem[int32(p)+3].int()
				} else {
					if tex.eqtb[5318+int32(n)-1].int() <= 0 {
						w = 1073741823
					} else {
						w = tex.pageSoFar[0] - tex.pageSoFar[1] - tex.pageSoFar[7]
						if tex.eqtb[5318+int32(n)-1].int() != 1000 {
							w = (tex.xOverN(w, tex.eqtb[5318+int32(n)-1].int()) * 1000)
						}
					}
					if w > tex.eqtb[5851+int32(n)-1].int()-tex.mem[int32(r)+3].int() {
						w = tex.eqtb[5851+int32(n)-1].int() - tex.mem[int32(r)+3].int()
					}
					q = tex.vertBreak(tex.mem[int32(p)+4].hh().lh(), w, tex.mem[int32(p)+2].int())
					*tex.mem[int32(r)+3].pInt() = tex.mem[int32(r)+3].int() + tex.bestHeightPlusDepth
					if tex.eqtb[5318+int32(n)-1].int() != 1000 {
						tex.bestHeightPlusDepth = (tex.xOverN(tex.bestHeightPlusDepth, 1000) * tex.eqtb[5318+int32(n)-1].int())
					}
					tex.pageSoFar[0] = tex.pageSoFar[0] - tex.bestHeightPlusDepth
					*tex.mem[r].pHh().pB0() = 1
					tex.mem[int32(r)+1].pHh().rh = q
					*tex.mem[int32(r)+1].pHh().pLh() = p
					if q == 0 {
						tex.insertPenalties = tex.insertPenalties - 10000
					} else if tex.mem[q].hh().b0() == 12 {
						tex.insertPenalties = tex.insertPenalties + tex.mem[int32(q)+1].int()
					}
				}
			}
			goto label80
		default:
			tex.confusion(993)
		}
		if pi < 10000 {
			if tex.pageSoFar[1] < tex.pageSoFar[0] {
				if (tex.pageSoFar[3] != 0) || (tex.pageSoFar[4] != 0) || (tex.pageSoFar[5] != 0) {
					b = 0
				} else {
					b = int32(tex.badness(tex.pageSoFar[0]-tex.pageSoFar[1], tex.pageSoFar[2]))
				}
			} else if tex.pageSoFar[1]-tex.pageSoFar[0] > tex.pageSoFar[6] {
				b = 1073741823
			} else {
				b = int32(tex.badness(tex.pageSoFar[1]-tex.pageSoFar[0], tex.pageSoFar[6]))
			}
			if b < 1073741823 {
				if pi <= -10000 {
					c = pi
				} else if b < 10000 {
					c = b + pi + tex.insertPenalties
				} else {
					c = 100000
				}
			} else {
				c = b
			}
			if tex.insertPenalties >= 10000 {
				c = 1073741823
			}
			if c <= tex.leastPageCost {
				tex.bestPageBreak = p
				tex.bestSize = tex.pageSoFar[0]
				tex.leastPageCost = c
				r = tex.mem[30000].hh().rh
				for r != 30000 {
					*tex.mem[int32(r)+2].pHh().pLh() = tex.mem[int32(r)+2].hh().rh
					r = tex.mem[r].hh().rh
				}
			}
			if (c == 1073741823) || (pi <= -10000) {
				tex.fireUp(p)
				if tex.outputActive {
					goto label10
				}
				goto label30
			}
		}
		if (tex.mem[p].hh().b0() < 10) || (tex.mem[p].hh().b0() > 11) {
			goto label80
		}
	label90:
		if tex.mem[p].hh().b0() == 11 {
			q = p
		} else {
			q = tex.mem[int32(p)+1].hh().lh()
			tex.pageSoFar[2+int32(tex.mem[q].hh().b0())] = tex.pageSoFar[2+int32(tex.mem[q].hh().b0())] + tex.mem[int32(q)+2].int()
			tex.pageSoFar[6] = tex.pageSoFar[6] + tex.mem[int32(q)+3].int()
			if (tex.mem[q].hh().b1() != 0) && (tex.mem[int32(q)+3].int() != 0) {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(994)
				tex.helpPtr = 4
				tex.helpLine[3] = 995
				tex.helpLine[2] = 963
				tex.helpLine[1] = 964
				tex.helpLine[0] = 922
				tex.error1()
				r = tex.newSpec(q)
				*tex.mem[r].pHh().pB1() = 0
				tex.deleteGlueRef(q)
				*tex.mem[int32(p)+1].pHh().pLh() = r
				q = r
			}
		}
		tex.pageSoFar[1] = tex.pageSoFar[1] + tex.pageSoFar[7] + tex.mem[int32(q)+1].int()
		tex.pageSoFar[7] = 0
	label80:
		if tex.pageSoFar[7] > tex.pageMaxDepth {
			tex.pageSoFar[1] = tex.pageSoFar[1] + tex.pageSoFar[7] - tex.pageMaxDepth
			tex.pageSoFar[7] = tex.pageMaxDepth
		}
		tex.mem[tex.pageTail].pHh().rh = p
		tex.pageTail = p
		tex.mem[29999].pHh().rh = tex.mem[p].hh().rh
		tex.mem[p].pHh().rh = 0
		goto label30
	label31:
		tex.mem[29999].pHh().rh = tex.mem[p].hh().rh
		tex.mem[p].pHh().rh = 0
		tex.flushNodeList(p)
	label30:
		if tex.mem[29999].hh().rh == 0 {
			break
		}
	}
	if tex.nestPtr == 0 {
		tex.curList.tailField = 29999
	} else {
		tex.nest[0].tailField = 29999
	}
label10:
}

func (tex *Context) appSpace() {
	var q uint16 // 0..65535
	if (tex.curList.auxField.hh().lh() >= 2000) && (tex.eqtb[2895-1].hh().rh != 0) {
		q = tex.newParamGlue(13)
	} else {
		if tex.eqtb[2894-1].hh().rh != 0 {
			tex.mainP = tex.eqtb[2894-1].hh().rh
		} else {
			tex.mainP = tex.fontGlue[tex.eqtb[3934-1].hh().rh]
			if tex.mainP == 0 {
				tex.mainP = tex.newSpec(0)
				tex.mainK = uint16(tex.paramBase[tex.eqtb[3934-1].hh().rh] + 2)
				*tex.mem[int32(tex.mainP)+1].pInt() = tex.fontInfo[tex.mainK].int()
				*tex.mem[int32(tex.mainP)+2].pInt() = tex.fontInfo[int32(tex.mainK)+1].int()
				*tex.mem[int32(tex.mainP)+3].pInt() = tex.fontInfo[int32(tex.mainK)+2].int()
				tex.fontGlue[tex.eqtb[3934-1].hh().rh] = tex.mainP
			}
		}
		tex.mainP = tex.newSpec(tex.mainP)
		if tex.curList.auxField.hh().lh() >= 2000 {
			*tex.mem[int32(tex.mainP)+1].pInt() = tex.mem[int32(tex.mainP)+1].int() + tex.fontInfo[7+tex.paramBase[tex.eqtb[3934-1].hh().rh]].int()
		}
		*tex.mem[int32(tex.mainP)+2].pInt() = tex.xnOverD(tex.mem[int32(tex.mainP)+2].int(), int32(tex.curList.auxField.hh().lh()), 1000)
		*tex.mem[int32(tex.mainP)+3].pInt() = tex.xnOverD(tex.mem[int32(tex.mainP)+3].int(), 1000, int32(tex.curList.auxField.hh().lh()))
		q = tex.newGlue(tex.mainP)
		tex.mem[tex.mainP].pHh().rh = 0
	}
	tex.mem[tex.curList.tailField].pHh().rh = q
	tex.curList.tailField = q
}

func (tex *Context) insertDollarSign() {
	tex.backInput()
	tex.curTok = 804
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1017)
	tex.helpPtr = 2
	tex.helpLine[1] = 1018
	tex.helpLine[0] = 1019
	tex.insError()
}

func (tex *Context) youCant() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(685)
	tex.printCmdChr(tex.curCmd, tex.curChr)
	tex.print(1020)
	tex.printMode(int32(tex.curList.modeField))
}

func (tex *Context) reportIllegalCase() {
	tex.youCant()
	tex.helpPtr = 4
	tex.helpLine[3] = 1021
	tex.helpLine[2] = 1022
	tex.helpLine[1] = 1023
	tex.helpLine[0] = 1024
	tex.error1()
}

func (tex *Context) privileged() (ret bool) {
	if tex.curList.modeField > 0 {
		ret = true
	} else {
		tex.reportIllegalCase()
		ret = false
	}
	return ret
}

func (tex *Context) itsAllOver() (ret bool) {
	if tex.privileged() {
		if (29998 == int32(tex.pageTail)) && (tex.curList.headField == tex.curList.tailField) && (tex.deadCycles == 0) {
			ret = true
			goto label10
		}
		tex.backInput()
		tex.mem[tex.curList.tailField].pHh().rh = tex.newNullBox()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[int32(tex.curList.tailField)+1].pInt() = tex.eqtb[5833-1].int()
		tex.mem[tex.curList.tailField].pHh().rh = tex.newGlue(8)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(-1073741824)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.buildPage()
	}
	ret = false
label10:
	return ret
}

func (tex *Context) appendGlue() {
	var s byte // 0..63
	s = byte(tex.curChr)
	switch s {
	case 0:
		tex.curVal = 4
	case 1:
		tex.curVal = 8
	case 2:
		tex.curVal = 12
	case 3:
		tex.curVal = 16
	case 4:
		tex.scanGlue(2)
	case 5:
		tex.scanGlue(3)
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.newGlue(uint16(tex.curVal))
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	if s >= 4 {
		tex.mem[tex.curVal].pHh().rh = uint16(int32(tex.mem[tex.curVal].hh().rh) - 1)
		if s > 4 {
			*tex.mem[tex.curList.tailField].pHh().pB1() = 99
		}
	}
}

func (tex *Context) appendKern() {
	var s byte // 0..255
	s = byte(tex.curChr)
	tex.scanDimen(s == 99, false, false)
	tex.mem[tex.curList.tailField].pHh().rh = tex.newKern(tex.curVal)
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	*tex.mem[tex.curList.tailField].pHh().pB1() = s
}

func (tex *Context) offSave() {
	var p uint16 // 0..65535
	if tex.curGroup == 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(777)
		tex.printCmdChr(tex.curCmd, tex.curChr)
		tex.helpPtr = 1
		tex.helpLine[0] = 1043
		tex.error1()
	} else {
		tex.backInput()
		p = tex.getAvail()
		tex.mem[29997].pHh().rh = p
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(625)
		switch tex.curGroup {
		case 14:
			*tex.mem[p].pHh().pLh() = 6711
			tex.printEsc(516)
		case 15:
			*tex.mem[p].pHh().pLh() = 804
			tex.printChar(36)
		case 16:
			*tex.mem[p].pHh().pLh() = 6712
			tex.mem[p].pHh().rh = tex.getAvail()
			p = tex.mem[p].hh().rh
			*tex.mem[p].pHh().pLh() = 3118
			tex.printEsc(1042)
		default:
			*tex.mem[p].pHh().pLh() = 637
			tex.printChar(125)
		}
		tex.print(626)
		tex.beginTokenList(tex.mem[29997].hh().rh, 4)
		tex.helpPtr = 5
		tex.helpLine[4] = 1037
		tex.helpLine[3] = 1038
		tex.helpLine[2] = 1039
		tex.helpLine[1] = 1040
		tex.helpLine[0] = 1041
		tex.error1()
	}
}

func (tex *Context) extraRightBrace() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1048)
	switch tex.curGroup {
	case 14:
		tex.printEsc(516)
	case 15:
		tex.printChar(36)
	case 16:
		tex.printEsc(877)
	}
	tex.helpPtr = 5
	tex.helpLine[4] = 1049
	tex.helpLine[3] = 1050
	tex.helpLine[2] = 1051
	tex.helpLine[1] = 1052
	tex.helpLine[0] = 1053
	tex.error1()
	tex.alignState = tex.alignState + 1
}

func (tex *Context) normalParagraph() {
	if tex.eqtb[5282-1].int() != 0 {
		tex.eqWordDefine(5282, 0)
	}
	if tex.eqtb[5847-1].int() != 0 {
		tex.eqWordDefine(5847, 0)
	}
	if tex.eqtb[5304-1].int() != 1 {
		tex.eqWordDefine(5304, 1)
	}
	if tex.eqtb[3412-1].hh().rh != 0 {
		tex.eqDefine(3412, 118, 0)
	}
}

func (tex *Context) boxEnd(boxContext int32) {
	var p uint16 // 0..65535
	if boxContext < 1073741824 {
		if tex.curBox != 0 {
			*tex.mem[int32(tex.curBox)+4].pInt() = boxContext
			if iabs(int32(tex.curList.modeField)) == 1 {
				tex.appendToVlist(tex.curBox)
				if tex.adjustTail != 0 {
					if 29995 != int32(tex.adjustTail) {
						tex.mem[tex.curList.tailField].pHh().rh = tex.mem[29995].hh().rh
						tex.curList.tailField = tex.adjustTail
					}
					tex.adjustTail = 0
				}
				if tex.curList.modeField > 0 {
					tex.buildPage()
				}
			} else {
				if iabs(int32(tex.curList.modeField)) == 102 {
					*tex.curList.auxField.pHh().pLh() = 1000
				} else {
					p = tex.newNoad()
					tex.mem[int32(p)+1].pHh().rh = 2
					*tex.mem[int32(p)+1].pHh().pLh() = tex.curBox
					tex.curBox = p
				}
				tex.mem[tex.curList.tailField].pHh().rh = tex.curBox
				tex.curList.tailField = tex.curBox
			}
		}
	} else if boxContext < 1073742336 {
		if boxContext < 1073742080 {
			tex.eqDefine(uint16(-1073738146+boxContext), 119, tex.curBox)
		} else {
			tex.geqDefine(uint16(-1073738402+boxContext), 119, tex.curBox)
		}
	} else if tex.curBox != 0 {
		if boxContext > 1073742336 {
			for {
				tex.getXToken()
				if (tex.curCmd != 10) && (tex.curCmd != 0) {
					break
				}
			}
			if ((tex.curCmd == 26) && (iabs(int32(tex.curList.modeField)) != 1)) || ((tex.curCmd == 27) && (iabs(int32(tex.curList.modeField)) == 1)) {
				tex.appendGlue()
				*tex.mem[tex.curList.tailField].pHh().pB1() = byte(boxContext - 1073742237)
				tex.mem[int32(tex.curList.tailField)+1].pHh().rh = tex.curBox
			} else {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1066)
				tex.helpPtr = 3
				tex.helpLine[2] = 1067
				tex.helpLine[1] = 1068
				tex.helpLine[0] = 1069
				tex.backError()
				tex.flushNodeList(tex.curBox)
			}
		} else {
			tex.shipOut(tex.curBox)
		}
	}
}

func (tex *Context) beginBox(boxContext int32) {
	var p, q uint16 // 0..65535
	var k uint16    // 0..65535
	var n byte      // 0..255
	switch tex.curChr {
	case 0:
		tex.scanEightBitInt()
		tex.curBox = tex.eqtb[3678+tex.curVal-1].hh().rh
		tex.eqtb[3678+tex.curVal-1].pHh().rh = 0
	case 1:
		tex.scanEightBitInt()
		tex.curBox = tex.copyNodeList(tex.eqtb[3678+tex.curVal-1].hh().rh)
	case 2:
		tex.curBox = 0
		if iabs(int32(tex.curList.modeField)) == 203 {
			tex.youCant()
			tex.helpPtr = 1
			tex.helpLine[0] = 1070
			tex.error1()
		} else if (tex.curList.modeField == 1) && (tex.curList.headField == tex.curList.tailField) {
			tex.youCant()
			tex.helpPtr = 2
			tex.helpLine[1] = 1071
			tex.helpLine[0] = 1072
			tex.error1()
		} else {
			if !(tex.curList.tailField >= tex.hiMemMin) {
				if (tex.mem[tex.curList.tailField].hh().b0() == 0) || (tex.mem[tex.curList.tailField].hh().b0() == 1) {
					q = tex.curList.headField
					for {
						p = q
						if !(q >= tex.hiMemMin) {
							if tex.mem[q].hh().b0() == 7 {
								for _i := int64(1); _i <= int64(tex.mem[q].hh().b1()); _i++ {
									p = tex.mem[p].hh().rh
								}
								if p == tex.curList.tailField {
									goto label30
								}
							}
						}
						q = tex.mem[p].hh().rh
						if q == tex.curList.tailField {
							break
						}
					}
					tex.curBox = tex.curList.tailField
					*tex.mem[int32(tex.curBox)+4].pInt() = 0
					tex.curList.tailField = p
					tex.mem[p].pHh().rh = 0
				label30:
				}
			}
		}
	case 3:
		tex.scanEightBitInt()
		n = byte(tex.curVal)
		if !tex.scanKeyword(842) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1073)
			tex.helpPtr = 2
			tex.helpLine[1] = 1074
			tex.helpLine[0] = 1075
			tex.error1()
		}
		tex.scanDimen(false, false, false)
		tex.curBox = tex.vsplit(n, tex.curVal)
	default:
		k = uint16(int32(tex.curChr) - 4)
		*tex.saveStack[int32(tex.savePtr)+0].pInt() = boxContext
		if k == 102 {
			if (boxContext < 1073741824) && (iabs(int32(tex.curList.modeField)) == 1) {
				tex.scanSpec(3, true)
			} else {
				tex.scanSpec(2, true)
			}
		} else {
			if k == 1 {
				tex.scanSpec(4, true)
			} else {
				tex.scanSpec(5, true)
				k = 1
			}
			tex.normalParagraph()
		}
		tex.pushNest()
		tex.curList.modeField = int16(-k)
		if k == 1 {
			*tex.curList.auxField.pInt() = -65536000
			if tex.eqtb[3418-1].hh().rh != 0 {
				tex.beginTokenList(tex.eqtb[3418-1].hh().rh, 11)
			}
		} else {
			*tex.curList.auxField.pHh().pLh() = 1000
			if tex.eqtb[3417-1].hh().rh != 0 {
				tex.beginTokenList(tex.eqtb[3417-1].hh().rh, 10)
			}
		}
		goto label10
	}
	tex.boxEnd(boxContext)
label10:
}

func (tex *Context) scanBox(boxContext int32) {
	for {
		tex.getXToken()
		if (tex.curCmd != 10) && (tex.curCmd != 0) {
			break
		}
	}
	if tex.curCmd == 20 {
		tex.beginBox(boxContext)
	} else if (boxContext >= 1073742337) && ((tex.curCmd == 36) || (tex.curCmd == 35)) {
		tex.curBox = tex.scanRuleSpec()
		tex.boxEnd(boxContext)
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1076)
		tex.helpPtr = 3
		tex.helpLine[2] = 1077
		tex.helpLine[1] = 1078
		tex.helpLine[0] = 1079
		tex.backError()
	}
}

func (tex *Context) package1(c byte) {
	var h int32  // integer
	var p uint16 // 0..65535
	var d int32  // integer
	d = tex.eqtb[5837-1].int()
	tex.unsave()
	tex.savePtr = uint16(int32(tex.savePtr) - 3)
	if tex.curList.modeField == -102 {
		tex.curBox = tex.hpack(tex.mem[tex.curList.headField].hh().rh, tex.saveStack[int32(tex.savePtr)+2].int(), byte(tex.saveStack[int32(tex.savePtr)+1].int()))
	} else {
		tex.curBox = tex.vpackage(tex.mem[tex.curList.headField].hh().rh, tex.saveStack[int32(tex.savePtr)+2].int(), byte(tex.saveStack[int32(tex.savePtr)+1].int()), d)
		if c == 4 {
			h = 0
			p = tex.mem[int32(tex.curBox)+5].hh().rh
			if p != 0 {
				if tex.mem[p].hh().b0() <= 2 {
					h = tex.mem[int32(p)+3].int()
				}
			}
			*tex.mem[int32(tex.curBox)+2].pInt() = tex.mem[int32(tex.curBox)+2].int() - h + tex.mem[int32(tex.curBox)+3].int()
			*tex.mem[int32(tex.curBox)+3].pInt() = h
		}
	}
	tex.popNest()
	tex.boxEnd(tex.saveStack[int32(tex.savePtr)+0].int())
}

func (tex *Context) normMin(h int32) (ret byte) {
	if h <= 0 {
		ret = 1
	} else if h >= 63 {
		ret = 63
	} else {
		ret = byte(h)
	}
	return ret
}

func (tex *Context) newGraf(indented bool) {
	tex.curList.pgField = 0
	if (tex.curList.modeField == 1) || (tex.curList.headField != tex.curList.tailField) {
		tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(2)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	}
	tex.pushNest()
	tex.curList.modeField = 102
	*tex.curList.auxField.pHh().pLh() = 1000
	if tex.eqtb[5313-1].int() <= 0 {
		tex.curLang = 0
	} else if tex.eqtb[5313-1].int() > 255 {
		tex.curLang = 0
	} else {
		tex.curLang = byte(tex.eqtb[5313-1].int())
	}
	tex.curList.auxField.pHh().rh = uint16(tex.curLang)
	tex.curList.pgField = (((int32(tex.normMin(tex.eqtb[5314-1].int())) * 64) + int32(tex.normMin(tex.eqtb[5315-1].int()))) * 65536) + int32(tex.curLang)
	if indented {
		tex.curList.tailField = tex.newNullBox()
		tex.mem[tex.curList.headField].pHh().rh = tex.curList.tailField
		*tex.mem[int32(tex.curList.tailField)+1].pInt() = tex.eqtb[5830-1].int()
	}
	if tex.eqtb[3414-1].hh().rh != 0 {
		tex.beginTokenList(tex.eqtb[3414-1].hh().rh, 7)
	}
	if tex.nestPtr == 1 {
		tex.buildPage()
	}
}

func (tex *Context) indentInHmode() {
	var p, q uint16 // 0..65535
	if tex.curChr > 0 {
		p = tex.newNullBox()
		*tex.mem[int32(p)+1].pInt() = tex.eqtb[5830-1].int()
		if iabs(int32(tex.curList.modeField)) == 102 {
			*tex.curList.auxField.pHh().pLh() = 1000
		} else {
			q = tex.newNoad()
			tex.mem[int32(q)+1].pHh().rh = 2
			*tex.mem[int32(q)+1].pHh().pLh() = p
			p = q
		}
		tex.mem[tex.curList.tailField].pHh().rh = p
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	}
}

func (tex *Context) headForVmode() {
	if tex.curList.modeField < 0 {
		if tex.curCmd != 36 {
			tex.offSave()
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(685)
			tex.printEsc(521)
			tex.print(1082)
			tex.helpPtr = 2
			tex.helpLine[1] = 1083
			tex.helpLine[0] = 1084
			tex.error1()
		}
	} else {
		tex.backInput()
		tex.curTok = tex.parToken
		tex.backInput()
		tex.curInput.indexField = 4
	}
}

func (tex *Context) endGraf() {
	if tex.curList.modeField == 102 {
		if tex.curList.headField == tex.curList.tailField {
			tex.popNest()
		} else {
			tex.lineBreak(tex.eqtb[5269-1].int())
		}
		tex.normalParagraph()
		tex.errorCount = 0
	}
}

func (tex *Context) beginInsertOrAdjust() {
	if tex.curCmd == 38 {
		tex.curVal = 255
	} else {
		tex.scanEightBitInt()
		if tex.curVal == 255 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1085)
			tex.printEsc(330)
			tex.printInt(255)
			tex.helpPtr = 1
			tex.helpLine[0] = 1086
			tex.error1()
			tex.curVal = 0
		}
	}
	*tex.saveStack[int32(tex.savePtr)+0].pInt() = tex.curVal
	tex.savePtr = uint16(int32(tex.savePtr) + 1)
	tex.newSaveLevel(11)
	tex.scanLeftBrace()
	tex.normalParagraph()
	tex.pushNest()
	tex.curList.modeField = -1
	*tex.curList.auxField.pInt() = -65536000
}

func (tex *Context) makeMark() {
	var p uint16 // 0..65535
	p = tex.scanToks(false, true)
	p = tex.getNode(2)
	*tex.mem[p].pHh().pB0() = 4
	*tex.mem[p].pHh().pB1() = 0
	*tex.mem[int32(p)+1].pInt() = int32(tex.defRef)
	tex.mem[tex.curList.tailField].pHh().rh = p
	tex.curList.tailField = p
}

func (tex *Context) appendPenalty() {
	tex.scanInt()
	tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(tex.curVal)
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	if tex.curList.modeField == 1 {
		tex.buildPage()
	}
}

func (tex *Context) deleteLast() {
	var p, q uint16 // 0..65535
	if (tex.curList.modeField == 1) && (tex.curList.tailField == tex.curList.headField) {
		if (tex.curChr != 10) || (tex.lastGlue != 65535) {
			tex.youCant()
			tex.helpPtr = 2
			tex.helpLine[1] = 1071
			tex.helpLine[0] = 1087
			if tex.curChr == 11 {
				tex.helpLine[0] = uint16(1088)
			} else if tex.curChr != 10 {
				tex.helpLine[0] = uint16(1089)
			}
			tex.error1()
		}
	} else {
		if !(tex.curList.tailField >= tex.hiMemMin) {
			if uint16(tex.mem[tex.curList.tailField].hh().b0()) == tex.curChr {
				q = tex.curList.headField
				for {
					p = q
					if !(q >= tex.hiMemMin) {
						if tex.mem[q].hh().b0() == 7 {
							for _i := int64(1); _i <= int64(tex.mem[q].hh().b1()); _i++ {
								p = tex.mem[p].hh().rh
							}
							if p == tex.curList.tailField {
								goto label10
							}
						}
					}
					q = tex.mem[p].hh().rh
					if q == tex.curList.tailField {
						break
					}
				}
				tex.mem[p].pHh().rh = 0
				tex.flushNodeList(tex.curList.tailField)
				tex.curList.tailField = p
			}
		}
	}
label10:
}

func (tex *Context) unpackage() {
	var p uint16 // 0..65535
	var c byte   // 0..1
	c = byte(tex.curChr)
	tex.scanEightBitInt()
	p = tex.eqtb[3678+tex.curVal-1].hh().rh
	if p == 0 {
		goto label10
	}
	if (iabs(int32(tex.curList.modeField)) == 203) || ((iabs(int32(tex.curList.modeField)) == 1) && (tex.mem[p].hh().b0() != 1)) || ((iabs(int32(tex.curList.modeField)) == 102) && (tex.mem[p].hh().b0() != 0)) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1097)
		tex.helpPtr = 3
		tex.helpLine[2] = 1098
		tex.helpLine[1] = 1099
		tex.helpLine[0] = 1100
		tex.error1()
		goto label10
	}
	if c == 1 {
		tex.mem[tex.curList.tailField].pHh().rh = tex.copyNodeList(tex.mem[int32(p)+5].hh().rh)
	} else {
		tex.mem[tex.curList.tailField].pHh().rh = tex.mem[int32(p)+5].hh().rh
		tex.eqtb[3678+tex.curVal-1].pHh().rh = 0
		tex.freeNode(p, 7)
	}
	for tex.mem[tex.curList.tailField].hh().rh != 0 {
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	}
label10:
}

func (tex *Context) appendItalicCorrection() {
	var p uint16 // 0..65535
	var f byte   // 0..75
	if tex.curList.tailField != tex.curList.headField {
		if tex.curList.tailField >= tex.hiMemMin {
			p = tex.curList.tailField
		} else if tex.mem[tex.curList.tailField].hh().b0() == 6 {
			p = uint16(int32(tex.curList.tailField) + 1)
		} else {
			goto label10
		}
		f = tex.mem[p].hh().b0()
		tex.mem[tex.curList.tailField].pHh().rh = tex.newKern(tex.fontInfo[tex.italicBase[f]+((int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[p].hh().b1())].qqqq().b2)-0)/4)].int())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[tex.curList.tailField].pHh().pB1() = 1
	}
label10:
}

func (tex *Context) appendDiscretionary() {
	var c int32 // integer
	tex.mem[tex.curList.tailField].pHh().rh = tex.newDisc()
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	if tex.curChr == 1 {
		c = tex.hyphenChar[tex.eqtb[3934-1].hh().rh]
		if c >= 0 {
			if c < 256 {
				*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = tex.newCharacter(byte(tex.eqtb[3934-1].hh().rh), byte(c))
			}
		}
	} else {
		tex.savePtr = uint16(int32(tex.savePtr) + 1)
		*tex.saveStack[int32(tex.savePtr)-1].pInt() = 0
		tex.newSaveLevel(10)
		tex.scanLeftBrace()
		tex.pushNest()
		tex.curList.modeField = -102
		*tex.curList.auxField.pHh().pLh() = 1000
	}
}

func (tex *Context) buildDiscretionary() {
	var p, q uint16 // 0..65535
	var n int32     // integer
	tex.unsave()
	q = tex.curList.headField
	p = tex.mem[q].hh().rh
	n = 0
	for p != 0 {
		if !(p >= tex.hiMemMin) {
			if tex.mem[p].hh().b0() > 2 {
				if tex.mem[p].hh().b0() != 11 {
					if tex.mem[p].hh().b0() != 6 {
						if tex.interaction == 3 {
						}
						tex.printNl(262)
						tex.print(1107)
						tex.helpPtr = 1
						tex.helpLine[0] = 1108
						tex.error1()
						tex.beginDiagnostic()
						tex.printNl(1109)
						tex.showBox(p)
						tex.endDiagnostic(true)
						tex.flushNodeList(p)
						tex.mem[q].pHh().rh = 0
						goto label30
					}
				}
			}
		}
		q = p
		p = tex.mem[q].hh().rh
		n = n + 1
	}
label30:
	p = tex.mem[tex.curList.headField].hh().rh
	tex.popNest()
	switch tex.saveStack[int32(tex.savePtr)-1].int() {
	case 0:
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = p
	case 1:
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = p
	case 2:
		if (n > 0) && (iabs(int32(tex.curList.modeField)) == 203) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1101)
			tex.printEsc(349)
			tex.helpPtr = 2
			tex.helpLine[1] = 1102
			tex.helpLine[0] = 1103
			tex.flushNodeList(p)
			n = 0
			tex.error1()
		} else {
			tex.mem[tex.curList.tailField].pHh().rh = p
		}
		if n <= 255 {
			*tex.mem[tex.curList.tailField].pHh().pB1() = byte(n)
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1104)
			tex.helpPtr = 2
			tex.helpLine[1] = 1105
			tex.helpLine[0] = 1106
			tex.error1()
		}
		if n > 0 {
			tex.curList.tailField = q
		}
		tex.savePtr = uint16(int32(tex.savePtr) - 1)
		goto label10
	}
	*tex.saveStack[int32(tex.savePtr)-1].pInt() = tex.saveStack[int32(tex.savePtr)-1].int() + 1
	tex.newSaveLevel(10)
	tex.scanLeftBrace()
	tex.pushNest()
	tex.curList.modeField = -102
	*tex.curList.auxField.pHh().pLh() = 1000
label10:
}

func (tex *Context) makeAccent() {
	var s, t float32            // real
	var p, q, r uint16          // 0..65535
	var f byte                  // 0..75
	var a, h, x, w, delta int32 // integer
	var i fourQuarters          // record fourQuarters
	tex.scanCharNum()
	f = byte(tex.eqtb[3934-1].hh().rh)
	p = tex.newCharacter(f, byte(tex.curVal))
	if p != 0 {
		x = tex.fontInfo[5+tex.paramBase[f]].int()
		s = (float32(tex.fontInfo[1+tex.paramBase[f]].int()) / 65536)
		a = tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[p].hh().b1())].qqqq().b0)].int()
		tex.doAssignments()
		q = 0
		f = byte(tex.eqtb[3934-1].hh().rh)
		if (tex.curCmd == 11) || (tex.curCmd == 12) || (tex.curCmd == 68) {
			q = tex.newCharacter(f, byte(tex.curChr))
		} else if tex.curCmd == 16 {
			tex.scanCharNum()
			q = tex.newCharacter(f, byte(tex.curVal))
		} else {
			tex.backInput()
		}
		if q != 0 {
			t = (float32(tex.fontInfo[1+tex.paramBase[f]].int()) / 65536)
			i = tex.fontInfo[tex.charBase[f]+int32(tex.mem[q].hh().b1())].qqqq()
			w = tex.fontInfo[tex.widthBase[f]+int32(i.b0)].int()
			h = tex.fontInfo[tex.heightBase[f]+((int32(i.b1)-0)/16)].int()
			if h != x {
				p = tex.hpack(p, 0, 1)
				*tex.mem[int32(p)+4].pInt() = x - h
			}
			delta = round((float32((w - a)) / 2) + (float32(h) * t) - (float32(x) * s))
			r = tex.newKern(delta)
			*tex.mem[r].pHh().pB1() = 2
			tex.mem[tex.curList.tailField].pHh().rh = r
			tex.mem[r].pHh().rh = p
			tex.curList.tailField = tex.newKern(-a - delta)
			*tex.mem[tex.curList.tailField].pHh().pB1() = 2
			tex.mem[p].pHh().rh = tex.curList.tailField
			p = q
		}
		tex.mem[tex.curList.tailField].pHh().rh = p
		tex.curList.tailField = p
		*tex.curList.auxField.pHh().pLh() = 1000
	}
}

func (tex *Context) alignError() {
	if iabs(tex.alignState) > 2 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1114)
		tex.printCmdChr(tex.curCmd, tex.curChr)
		if tex.curTok == 1062 {
			tex.helpPtr = 6
			tex.helpLine[5] = 1115
			tex.helpLine[4] = 1116
			tex.helpLine[3] = 1117
			tex.helpLine[2] = 1118
			tex.helpLine[1] = 1119
			tex.helpLine[0] = 1120
		} else {
			tex.helpPtr = 5
			tex.helpLine[4] = 1115
			tex.helpLine[3] = 1121
			tex.helpLine[2] = 1118
			tex.helpLine[1] = 1119
			tex.helpLine[0] = 1120
		}
		tex.error1()
	} else {
		tex.backInput()
		if tex.alignState < 0 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(657)
			tex.alignState = tex.alignState + 1
			tex.curTok = 379
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1110)
			tex.alignState = tex.alignState - 1
			tex.curTok = 637
		}
		tex.helpPtr = 3
		tex.helpLine[2] = 1111
		tex.helpLine[1] = 1112
		tex.helpLine[0] = 1113
		tex.insError()
	}
}

func (tex *Context) noAlignError() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1114)
	tex.printEsc(527)
	tex.helpPtr = 2
	tex.helpLine[1] = 1122
	tex.helpLine[0] = 1123
	tex.error1()
}

func (tex *Context) omitError() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1114)
	tex.printEsc(530)
	tex.helpPtr = 2
	tex.helpLine[1] = 1124
	tex.helpLine[0] = 1123
	tex.error1()
}

func (tex *Context) doEndv() {
	tex.basePtr = tex.inputPtr
	tex.inputStack[tex.basePtr] = tex.curInput
	for (tex.inputStack[tex.basePtr].indexField != 2) && (tex.inputStack[tex.basePtr].locField == 0) && (tex.inputStack[tex.basePtr].stateField == 0) {
		tex.basePtr = byte(int32(tex.basePtr) - 1)
	}
	if (tex.inputStack[tex.basePtr].indexField != 2) || (tex.inputStack[tex.basePtr].locField != 0) || (tex.inputStack[tex.basePtr].stateField != 0) {
		tex.fatalError(595)
	}
	if tex.curGroup == 6 {
		tex.endGraf()
		if tex.finCol() {
			tex.finRow()
		}
	} else {
		tex.offSave()
	}
}

func (tex *Context) csError() {
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(777)
	tex.printEsc(505)
	tex.helpPtr = 1
	tex.helpLine[0] = 1126
	tex.error1()
}

func (tex *Context) pushMath(c byte) {
	tex.pushNest()
	tex.curList.modeField = -203
	*tex.curList.auxField.pInt() = 0
	tex.newSaveLevel(c)
}

func (tex *Context) initMath() {
	var w int32  // integer
	var l int32  // integer
	var s int32  // integer
	var p uint16 // 0..65535
	var q uint16 // 0..65535
	var f byte   // 0..75
	var n int32  // integer
	var v int32  // integer
	var d int32  // integer
	tex.getToken()
	if (tex.curCmd == 3) && (tex.curList.modeField > 0) {
		if tex.curList.headField == tex.curList.tailField {
			tex.popNest()
			w = -1073741823
		} else {
			tex.lineBreak(tex.eqtb[5270-1].int())
			v = tex.mem[int32(tex.justBox)+4].int() + (2 * tex.fontInfo[6+tex.paramBase[tex.eqtb[3934-1].hh().rh]].int())
			w = -1073741823
			p = tex.mem[int32(tex.justBox)+5].hh().rh
			for p != 0 {
			label21:
				if p >= tex.hiMemMin {
					f = tex.mem[p].hh().b0()
					d = tex.fontInfo[tex.widthBase[f]+int32(tex.fontInfo[tex.charBase[f]+int32(tex.mem[p].hh().b1())].qqqq().b0)].int()
					goto label40
				}
				switch tex.mem[p].hh().b0() {
				case 0, 1, 2:
					d = tex.mem[int32(p)+1].int()
					goto label40
				case 6:
					tex.mem[29988] = tex.mem[int32(p)+1]
					tex.mem[29988].pHh().rh = tex.mem[p].hh().rh
					p = 29988
					goto label21
				case 11, 9:
					d = tex.mem[int32(p)+1].int()
				case 10:
					q = tex.mem[int32(p)+1].hh().lh()
					d = tex.mem[int32(q)+1].int()
					if tex.mem[int32(tex.justBox)+5].hh().b0() == 1 {
						if (tex.mem[int32(tex.justBox)+5].hh().b1() == tex.mem[q].hh().b0()) && (tex.mem[int32(q)+2].int() != 0) {
							v = 1073741823
						}
					} else if tex.mem[int32(tex.justBox)+5].hh().b0() == 2 {
						if (tex.mem[int32(tex.justBox)+5].hh().b1() == tex.mem[q].hh().b1()) && (tex.mem[int32(q)+3].int() != 0) {
							v = 1073741823
						}
					}
					if tex.mem[p].hh().b1() >= 100 {
						goto label40
					}
				case 8:
					d = 0
				default:
					d = 0
				}
				if v < 1073741823 {
					v = v + d
				}
				goto label45
			label40:
				if v < 1073741823 {
					v = v + d
					w = v
				} else {
					w = 1073741823
					goto label30
				}
			label45:
				p = tex.mem[p].hh().rh
			}
		label30:
		}
		if tex.eqtb[3412-1].hh().rh == 0 {
			if (tex.eqtb[5847-1].int() != 0) && (((tex.eqtb[5304-1].int() >= 0) && ((tex.curList.pgField + 2) > tex.eqtb[5304-1].int())) || ((tex.curList.pgField + 1) < -tex.eqtb[5304-1].int())) {
				l = tex.eqtb[5833-1].int() - iabs(tex.eqtb[5847-1].int())
				if tex.eqtb[5847-1].int() > 0 {
					s = tex.eqtb[5847-1].int()
				} else {
					s = 0
				}
			} else {
				l = tex.eqtb[5833-1].int()
				s = 0
			}
		} else {
			n = int32(tex.mem[tex.eqtb[3412-1].hh().rh].hh().lh())
			if tex.curList.pgField+2 >= n {
				p = uint16(int32(tex.eqtb[3412-1].hh().rh) + (2 * n))
			} else {
				p = uint16(int32(tex.eqtb[3412-1].hh().rh) + (2 * (tex.curList.pgField + 2)))
			}
			s = tex.mem[int32(p)-1].int()
			l = tex.mem[p].int()
		}
		tex.pushMath(15)
		tex.curList.modeField = 203
		tex.eqWordDefine(5307, -1)
		tex.eqWordDefine(5843, w)
		tex.eqWordDefine(5844, l)
		tex.eqWordDefine(5845, s)
		if tex.eqtb[3416-1].hh().rh != 0 {
			tex.beginTokenList(tex.eqtb[3416-1].hh().rh, 9)
		}
		if tex.nestPtr == 1 {
			tex.buildPage()
		}
	} else {
		tex.backInput()
		tex.pushMath(15)
		tex.eqWordDefine(5307, -1)
		if tex.eqtb[3415-1].hh().rh != 0 {
			tex.beginTokenList(tex.eqtb[3415-1].hh().rh, 8)
		}
	}
}

func (tex *Context) startEqNo() {
	*tex.saveStack[int32(tex.savePtr)+0].pInt() = int32(tex.curChr)
	tex.savePtr = uint16(int32(tex.savePtr) + 1)
	tex.pushMath(15)
	tex.eqWordDefine(5307, -1)
	if tex.eqtb[3415-1].hh().rh != 0 {
		tex.beginTokenList(tex.eqtb[3415-1].hh().rh, 8)
	}
}

func (tex *Context) scanMath(p uint16) {
	var c int32 // integer
label20:
	for {
		tex.getXToken()
		if (tex.curCmd != 10) && (tex.curCmd != 0) {
			break
		}
	}
label21:
	switch tex.curCmd {
	case 11, 12, 68:
		c = int32(tex.eqtb[5007+int32(tex.curChr)-1].hh().rh) - 0
		if c == 32768 {
			tex.curCs = uint16(int32(tex.curChr) + 1)
			tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
			tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
			tex.xToken()
			tex.backInput()
			goto label20
		}
	case 16:
		tex.scanCharNum()
		tex.curChr = uint16(tex.curVal)
		tex.curCmd = 68
		goto label21
	case 17:
		tex.scanFifteenBitInt()
		c = tex.curVal
	case 69:
		c = int32(tex.curChr)
	case 15:
		tex.scanTwentySevenBitInt()
		c = (tex.curVal / 4096)
	default:
		tex.backInput()
		tex.scanLeftBrace()
		*tex.saveStack[int32(tex.savePtr)+0].pInt() = int32(p)
		tex.savePtr = uint16(int32(tex.savePtr) + 1)
		tex.pushMath(9)
		goto label10
	}
	tex.mem[p].pHh().rh = 1
	*tex.mem[p].pHh().pB1() = byte((c % 256) + 0)
	if (c >= 28672) && ((tex.eqtb[5307-1].int() >= 0) && (tex.eqtb[5307-1].int() < 16)) {
		*tex.mem[p].pHh().pB0() = byte(tex.eqtb[5307-1].int())
	} else {
		*tex.mem[p].pHh().pB0() = byte(((c / 256) % 16))
	}
label10:
}

func (tex *Context) setMathChar(c int32) {
	var p uint16 // 0..65535
	if c >= 32768 {
		tex.curCs = uint16(int32(tex.curChr) + 1)
		tex.curCmd = tex.eqtb[tex.curCs-1].hh().b0()
		tex.curChr = tex.eqtb[tex.curCs-1].hh().rh
		tex.xToken()
		tex.backInput()
	} else {
		p = tex.newNoad()
		tex.mem[int32(p)+1].pHh().rh = 1
		*tex.mem[int32(p)+1].pHh().pB1() = byte((c % 256) + 0)
		*tex.mem[int32(p)+1].pHh().pB0() = byte(((c / 256) % 16))
		if c >= 28672 {
			if (tex.eqtb[5307-1].int() >= 0) && (tex.eqtb[5307-1].int() < 16) {
				*tex.mem[int32(p)+1].pHh().pB0() = byte(tex.eqtb[5307-1].int())
			}
			*tex.mem[p].pHh().pB0() = 16
		} else {
			*tex.mem[p].pHh().pB0() = byte(16 + (c / 4096))
		}
		tex.mem[tex.curList.tailField].pHh().rh = p
		tex.curList.tailField = p
	}
}

func (tex *Context) mathLimitSwitch() {
	if tex.curList.headField != tex.curList.tailField {
		if tex.mem[tex.curList.tailField].hh().b0() == 17 {
			*tex.mem[tex.curList.tailField].pHh().pB1() = byte(tex.curChr)
			goto label10
		}
	}
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1130)
	tex.helpPtr = 1
	tex.helpLine[0] = 1131
	tex.error1()
label10:
}

func (tex *Context) scanDelimiter(p uint16, r bool) {
	if r {
		tex.scanTwentySevenBitInt()
	} else {
		for {
			tex.getXToken()
			if (tex.curCmd != 10) && (tex.curCmd != 0) {
				break
			}
		}
		switch tex.curCmd {
		case 11, 12:
			tex.curVal = tex.eqtb[5574+int32(tex.curChr)-1].int()
		case 15:
			tex.scanTwentySevenBitInt()
		default:
			tex.curVal = -1
		}
	}
	if tex.curVal < 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1132)
		tex.helpPtr = 6
		tex.helpLine[5] = 1133
		tex.helpLine[4] = 1134
		tex.helpLine[3] = 1135
		tex.helpLine[2] = 1136
		tex.helpLine[1] = 1137
		tex.helpLine[0] = 1138
		tex.backError()
		tex.curVal = 0
	}
	tex.mem[p].pQqqq().b0 = byte(((tex.curVal / 1048576) % 16))
	tex.mem[p].pQqqq().b1 = byte(((tex.curVal / 4096) % 256) + 0)
	tex.mem[p].pQqqq().b2 = byte(((tex.curVal / 256) % 16))
	tex.mem[p].pQqqq().b3 = byte((tex.curVal % 256) + 0)
}

func (tex *Context) mathRadical() {
	tex.mem[tex.curList.tailField].pHh().rh = tex.getNode(5)
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	*tex.mem[tex.curList.tailField].pHh().pB0() = 24
	*tex.mem[tex.curList.tailField].pHh().pB1() = 0
	*tex.mem[int32(tex.curList.tailField)+1].pHh() = tex.emptyField
	*tex.mem[int32(tex.curList.tailField)+3].pHh() = tex.emptyField
	*tex.mem[int32(tex.curList.tailField)+2].pHh() = tex.emptyField
	tex.scanDelimiter(uint16(int32(tex.curList.tailField)+4), true)
	tex.scanMath(uint16(int32(tex.curList.tailField) + 1))
}

func (tex *Context) mathAc() {
	if tex.curCmd == 45 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1139)
		tex.printEsc(523)
		tex.print(1140)
		tex.helpPtr = 2
		tex.helpLine[1] = 1141
		tex.helpLine[0] = 1142
		tex.error1()
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.getNode(5)
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	*tex.mem[tex.curList.tailField].pHh().pB0() = 28
	*tex.mem[tex.curList.tailField].pHh().pB1() = 0
	*tex.mem[int32(tex.curList.tailField)+1].pHh() = tex.emptyField
	*tex.mem[int32(tex.curList.tailField)+3].pHh() = tex.emptyField
	*tex.mem[int32(tex.curList.tailField)+2].pHh() = tex.emptyField
	tex.mem[int32(tex.curList.tailField)+4].pHh().rh = 1
	tex.scanFifteenBitInt()
	*tex.mem[int32(tex.curList.tailField)+4].pHh().pB1() = byte((tex.curVal % 256) + 0)
	if (tex.curVal >= 28672) && ((tex.eqtb[5307-1].int() >= 0) && (tex.eqtb[5307-1].int() < 16)) {
		*tex.mem[int32(tex.curList.tailField)+4].pHh().pB0() = byte(tex.eqtb[5307-1].int())
	} else {
		*tex.mem[int32(tex.curList.tailField)+4].pHh().pB0() = byte(((tex.curVal / 256) % 16))
	}
	tex.scanMath(uint16(int32(tex.curList.tailField) + 1))
}

func (tex *Context) appendChoices() {
	tex.mem[tex.curList.tailField].pHh().rh = tex.newChoice()
	tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	tex.savePtr = uint16(int32(tex.savePtr) + 1)
	*tex.saveStack[int32(tex.savePtr)-1].pInt() = 0
	tex.pushMath(13)
	tex.scanLeftBrace()
}

func (tex *Context) finMlist(p uint16) (ret uint16) {
	var q uint16 // 0..65535
	if tex.curList.auxField.int() != 0 {
		tex.mem[tex.curList.auxField.int()+3].pHh().rh = 3
		*tex.mem[tex.curList.auxField.int()+3].pHh().pLh() = tex.mem[tex.curList.headField].hh().rh
		if p == 0 {
			q = uint16(tex.curList.auxField.int())
		} else {
			q = tex.mem[tex.curList.auxField.int()+2].hh().lh()
			if tex.mem[q].hh().b0() != 30 {
				tex.confusion(877)
			}
			*tex.mem[tex.curList.auxField.int()+2].pHh().pLh() = tex.mem[q].hh().rh
			tex.mem[q].pHh().rh = uint16(tex.curList.auxField.int())
			tex.mem[tex.curList.auxField.int()].pHh().rh = p
		}
	} else {
		tex.mem[tex.curList.tailField].pHh().rh = p
		q = tex.mem[tex.curList.headField].hh().rh
	}
	tex.popNest()
	ret = q
	return ret
}

func (tex *Context) buildChoices() {
	var p uint16 // 0..65535
	tex.unsave()
	p = tex.finMlist(0)
	switch tex.saveStack[int32(tex.savePtr)-1].int() {
	case 0:
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = p
	case 1:
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = p
	case 2:
		*tex.mem[int32(tex.curList.tailField)+2].pHh().pLh() = p
	case 3:
		tex.mem[int32(tex.curList.tailField)+2].pHh().rh = p
		tex.savePtr = uint16(int32(tex.savePtr) - 1)
		goto label10
	}
	*tex.saveStack[int32(tex.savePtr)-1].pInt() = tex.saveStack[int32(tex.savePtr)-1].int() + 1
	tex.pushMath(13)
	tex.scanLeftBrace()
label10:
}

func (tex *Context) subSup() {
	var t byte   // 0..63
	var p uint16 // 0..65535
	t = 0
	p = 0
	if tex.curList.tailField != tex.curList.headField {
		if (tex.mem[tex.curList.tailField].hh().b0() >= 16) && (tex.mem[tex.curList.tailField].hh().b0() < 30) {
			p = uint16(int32(tex.curList.tailField) + 2 + int32(tex.curCmd) - 7)
			t = byte(tex.mem[p].hh().rh)
		}
	}
	if (p == 0) || (t != 0) {
		tex.mem[tex.curList.tailField].pHh().rh = tex.newNoad()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		p = uint16(int32(tex.curList.tailField) + 2 + int32(tex.curCmd) - 7)
		if t != 0 {
			if tex.curCmd == 7 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1143)
				tex.helpPtr = 1
				tex.helpLine[0] = 1144
			} else {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1145)
				tex.helpPtr = 1
				tex.helpLine[0] = 1146
			}
			tex.error1()
		}
	}
	tex.scanMath(p)
}

func (tex *Context) mathFraction() {
	var c byte // 0..63
	c = byte(tex.curChr)
	if tex.curList.auxField.int() != 0 {
		if c >= 3 {
			tex.scanDelimiter(29988, false)
			tex.scanDelimiter(29988, false)
		}
		if (int32(c) % 3) == 0 {
			tex.scanDimen(false, false, false)
		}
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1153)
		tex.helpPtr = 3
		tex.helpLine[2] = 1154
		tex.helpLine[1] = 1155
		tex.helpLine[0] = 1156
		tex.error1()
	} else {
		*tex.curList.auxField.pInt() = int32(tex.getNode(6))
		*tex.mem[tex.curList.auxField.int()].pHh().pB0() = 25
		*tex.mem[tex.curList.auxField.int()].pHh().pB1() = 0
		tex.mem[tex.curList.auxField.int()+2].pHh().rh = 3
		*tex.mem[tex.curList.auxField.int()+2].pHh().pLh() = tex.mem[tex.curList.headField].hh().rh
		*tex.mem[tex.curList.auxField.int()+3].pHh() = tex.emptyField
		*tex.mem[tex.curList.auxField.int()+4].pQqqq() = tex.nullDelimiter
		*tex.mem[tex.curList.auxField.int()+5].pQqqq() = tex.nullDelimiter
		tex.mem[tex.curList.headField].pHh().rh = 0
		tex.curList.tailField = tex.curList.headField
		if c >= 3 {
			tex.scanDelimiter(uint16(tex.curList.auxField.int()+4), false)
			tex.scanDelimiter(uint16(tex.curList.auxField.int()+5), false)
		}
		switch int32(c) % 3 {
		case 0:
			tex.scanDimen(false, false, false)
			*tex.mem[tex.curList.auxField.int()+1].pInt() = tex.curVal
		case 1:
			*tex.mem[tex.curList.auxField.int()+1].pInt() = 1073741824
		case 2:
			*tex.mem[tex.curList.auxField.int()+1].pInt() = 0
		}
	}
}

func (tex *Context) mathLeftRight() {
	var t byte   // 0..63
	var p uint16 // 0..65535
	t = byte(tex.curChr)
	if (t == 31) && (tex.curGroup != 16) {
		if tex.curGroup == 15 {
			tex.scanDelimiter(29988, false)
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(777)
			tex.printEsc(877)
			tex.helpPtr = 1
			tex.helpLine[0] = 1157
			tex.error1()
		} else {
			tex.offSave()
		}
	} else {
		p = tex.newNoad()
		*tex.mem[p].pHh().pB0() = t
		tex.scanDelimiter(uint16(int32(p)+1), false)
		if t == 30 {
			tex.pushMath(16)
			tex.mem[tex.curList.headField].pHh().rh = p
			tex.curList.tailField = p
		} else {
			p = tex.finMlist(p)
			tex.unsave()
			tex.mem[tex.curList.tailField].pHh().rh = tex.newNoad()
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
			*tex.mem[tex.curList.tailField].pHh().pB0() = 23
			tex.mem[int32(tex.curList.tailField)+1].pHh().rh = 3
			*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = p
		}
	}
}

func (tex *Context) afterMath() {
	var l bool      // boolean
	var danger bool // boolean
	var m int32     // integer
	var p uint16    // 0..65535
	var a uint16    // 0..65535
	var b uint16    // 0..65535
	var w int32     // integer
	var z int32     // integer
	var e int32     // integer
	var q int32     // integer
	var d int32     // integer
	var s int32     // integer
	var g1, g2 byte // 0..63
	var r uint16    // 0..65535
	var t uint16    // 0..65535
	danger = false
	if (tex.fontParams[tex.eqtb[3937-1].hh().rh] < 22) || (tex.fontParams[tex.eqtb[3953-1].hh().rh] < 22) || (tex.fontParams[tex.eqtb[3969-1].hh().rh] < 22) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1158)
		tex.helpPtr = 3
		tex.helpLine[2] = 1159
		tex.helpLine[1] = 1160
		tex.helpLine[0] = 1161
		tex.error1()
		tex.flushMath()
		danger = true
	} else if (tex.fontParams[tex.eqtb[3938-1].hh().rh] < 13) || (tex.fontParams[tex.eqtb[3954-1].hh().rh] < 13) || (tex.fontParams[tex.eqtb[3970-1].hh().rh] < 13) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1162)
		tex.helpPtr = 3
		tex.helpLine[2] = 1163
		tex.helpLine[1] = 1164
		tex.helpLine[0] = 1165
		tex.error1()
		tex.flushMath()
		danger = true
	}
	m = int32(tex.curList.modeField)
	l = false
	p = tex.finMlist(0)
	if int32(tex.curList.modeField) == -m {
		tex.getXToken()
		if tex.curCmd != 3 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1166)
			tex.helpPtr = 2
			tex.helpLine[1] = 1167
			tex.helpLine[0] = 1168
			tex.backError()
		}
		tex.curMlist = p
		tex.curStyle = 2
		tex.mlistPenalties = false
		tex.mlistToHlist()
		a = tex.hpack(tex.mem[29997].hh().rh, 0, 1)
		tex.unsave()
		tex.savePtr = uint16(int32(tex.savePtr) - 1)
		if tex.saveStack[int32(tex.savePtr)+0].int() == 1 {
			l = true
		}
		danger = false
		if (tex.fontParams[tex.eqtb[3937-1].hh().rh] < 22) || (tex.fontParams[tex.eqtb[3953-1].hh().rh] < 22) || (tex.fontParams[tex.eqtb[3969-1].hh().rh] < 22) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1158)
			tex.helpPtr = 3
			tex.helpLine[2] = 1159
			tex.helpLine[1] = 1160
			tex.helpLine[0] = 1161
			tex.error1()
			tex.flushMath()
			danger = true
		} else if (tex.fontParams[tex.eqtb[3938-1].hh().rh] < 13) || (tex.fontParams[tex.eqtb[3954-1].hh().rh] < 13) || (tex.fontParams[tex.eqtb[3970-1].hh().rh] < 13) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1162)
			tex.helpPtr = 3
			tex.helpLine[2] = 1163
			tex.helpLine[1] = 1164
			tex.helpLine[0] = 1165
			tex.error1()
			tex.flushMath()
			danger = true
		}
		m = int32(tex.curList.modeField)
		p = tex.finMlist(0)
	} else {
		a = 0
	}
	if m < 0 {
		tex.mem[tex.curList.tailField].pHh().rh = tex.newMath(tex.eqtb[5831-1].int(), 0)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.curMlist = p
		tex.curStyle = 2
		tex.mlistPenalties = (tex.curList.modeField > 0)
		tex.mlistToHlist()
		tex.mem[tex.curList.tailField].pHh().rh = tex.mem[29997].hh().rh
		for tex.mem[tex.curList.tailField].hh().rh != 0 {
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		}
		tex.mem[tex.curList.tailField].pHh().rh = tex.newMath(tex.eqtb[5831-1].int(), 1)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.curList.auxField.pHh().pLh() = 1000
		tex.unsave()
	} else {
		if a == 0 {
			tex.getXToken()
			if tex.curCmd != 3 {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1166)
				tex.helpPtr = 2
				tex.helpLine[1] = 1167
				tex.helpLine[0] = 1168
				tex.backError()
			}
		}
		tex.curMlist = p
		tex.curStyle = 0
		tex.mlistPenalties = false
		tex.mlistToHlist()
		p = tex.mem[29997].hh().rh
		tex.adjustTail = 29995
		b = tex.hpack(p, 0, 1)
		p = tex.mem[int32(b)+5].hh().rh
		t = tex.adjustTail
		tex.adjustTail = 0
		w = tex.mem[int32(b)+1].int()
		z = tex.eqtb[5844-1].int()
		s = tex.eqtb[5845-1].int()
		if (a == 0) || danger {
			e = 0
			q = 0
		} else {
			e = tex.mem[int32(a)+1].int()
			q = e + tex.fontInfo[6+tex.paramBase[tex.eqtb[3937-1].hh().rh]].int()
		}
		if w+q > z {
			if (e != 0) && (((w - tex.totalShrink[0] + q) <= z) || (tex.totalShrink[1] != 0) || (tex.totalShrink[2] != 0) || (tex.totalShrink[3] != 0)) {
				tex.freeNode(b, 7)
				b = tex.hpack(p, z-q, 0)
			} else {
				e = 0
				if w > z {
					tex.freeNode(b, 7)
					b = tex.hpack(p, z, 0)
				}
			}
			w = tex.mem[int32(b)+1].int()
		}
		d = tex.half(z - w)
		if (e > 0) && (d < (2 * e)) {
			d = tex.half(z - w - e)
			if p != 0 {
				if !(p >= tex.hiMemMin) {
					if tex.mem[p].hh().b0() == 10 {
						d = 0
					}
				}
			}
		}
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(tex.eqtb[5274-1].int())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		if ((d + s) <= tex.eqtb[5843-1].int()) || l {
			g1 = 3
			g2 = 4
		} else {
			g1 = 5
			g2 = 6
		}
		if l && (e == 0) {
			*tex.mem[int32(a)+4].pInt() = s
			tex.appendToVlist(a)
			tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(10000)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		} else {
			tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(g1)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		}
		if e != 0 {
			r = tex.newKern(z - w - e - d)
			if l {
				tex.mem[a].pHh().rh = r
				tex.mem[r].pHh().rh = b
				b = a
				d = 0
			} else {
				tex.mem[b].pHh().rh = r
				tex.mem[r].pHh().rh = a
			}
			b = tex.hpack(b, 0, 1)
		}
		*tex.mem[int32(b)+4].pInt() = s + d
		tex.appendToVlist(b)
		if (a != 0) && (e == 0) && !l {
			tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(10000)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
			*tex.mem[int32(a)+4].pInt() = s + z - tex.mem[int32(a)+1].int()
			tex.appendToVlist(a)
			g2 = 0
		}
		if t != 29995 {
			tex.mem[tex.curList.tailField].pHh().rh = tex.mem[29995].hh().rh
			tex.curList.tailField = t
		}
		tex.mem[tex.curList.tailField].pHh().rh = tex.newPenalty(tex.eqtb[5275-1].int())
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		if g2 > 0 {
			tex.mem[tex.curList.tailField].pHh().rh = tex.newParamGlue(g2)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		}
		tex.resumeAfterDisplay()
	}
}

func (tex *Context) resumeAfterDisplay() {
	if tex.curGroup != 15 {
		tex.confusion(1169)
	}
	tex.unsave()
	tex.curList.pgField = tex.curList.pgField + 3
	tex.pushNest()
	tex.curList.modeField = 102
	*tex.curList.auxField.pHh().pLh() = 1000
	if tex.eqtb[5313-1].int() <= 0 {
		tex.curLang = 0
	} else if tex.eqtb[5313-1].int() > 255 {
		tex.curLang = 0
	} else {
		tex.curLang = byte(tex.eqtb[5313-1].int())
	}
	tex.curList.auxField.pHh().rh = uint16(tex.curLang)
	tex.curList.pgField = (((int32(tex.normMin(tex.eqtb[5314-1].int())) * 64) + int32(tex.normMin(tex.eqtb[5315-1].int()))) * 65536) + int32(tex.curLang)
	tex.getXToken()
	if tex.curCmd != 10 {
		tex.backInput()
	}
	if tex.nestPtr == 1 {
		tex.buildPage()
	}
}

func (tex *Context) getRToken() {
label20:
	for {
		tex.getToken()
		if tex.curTok != 2592 {
			break
		}
	}
	if (tex.curCs == 0) || (tex.curCs > 2614) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1184)
		tex.helpPtr = 5
		tex.helpLine[4] = 1185
		tex.helpLine[3] = 1186
		tex.helpLine[2] = 1187
		tex.helpLine[1] = 1188
		tex.helpLine[0] = 1189
		if tex.curCs == 0 {
			tex.backInput()
		}
		tex.curTok = 6709
		tex.insError()
		goto label20
	}
}

func (tex *Context) trapZeroGlue() {
	if (tex.mem[tex.curVal+1].int() == 0) && (tex.mem[tex.curVal+2].int() == 0) && (tex.mem[tex.curVal+3].int() == 0) {
		tex.mem[0].pHh().rh = uint16(int32(tex.mem[0].hh().rh) + 1)
		tex.deleteGlueRef(uint16(tex.curVal))
		tex.curVal = 0
	}
}

func (tex *Context) doRegisterCommand(a byte) {
	var l, q, r, s uint16 // 0..65535
	var p byte            // 0..3
	q = uint16(tex.curCmd)
	if q != 89 {
		tex.getXToken()
		if (tex.curCmd >= 73) && (tex.curCmd <= 76) {
			l = tex.curChr
			p = byte(int32(tex.curCmd) - 73)
			goto label40
		}
		if tex.curCmd != 89 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(685)
			tex.printCmdChr(tex.curCmd, tex.curChr)
			tex.print(686)
			tex.printCmdChr(byte(q), 0)
			tex.helpPtr = 1
			tex.helpLine[0] = 1210
			tex.error1()
			goto label10
		}
	}
	p = byte(tex.curChr)
	tex.scanEightBitInt()
	switch p {
	case 0:
		l = uint16(tex.curVal + 5318)
	case 1:
		l = uint16(tex.curVal + 5851)
	case 2:
		l = uint16(tex.curVal + 2900)
	case 3:
		l = uint16(tex.curVal + 3156)
	}
label40:
	if q == 89 {
		tex.scanOptionalEquals()
	} else if tex.scanKeyword(1206) {
	}
	tex.arithError = false
	if q < 91 {
		if p < 2 {
			if p == 0 {
				tex.scanInt()
			} else {
				tex.scanDimen(false, false, false)
			}
			if q == 90 {
				tex.curVal = tex.curVal + tex.eqtb[l-1].int()
			}
		} else {
			tex.scanGlue(p)
			if q == 90 {
				q = tex.newSpec(uint16(tex.curVal))
				r = tex.eqtb[l-1].hh().rh
				tex.deleteGlueRef(uint16(tex.curVal))
				*tex.mem[int32(q)+1].pInt() = tex.mem[int32(q)+1].int() + tex.mem[int32(r)+1].int()
				if tex.mem[int32(q)+2].int() == 0 {
					*tex.mem[q].pHh().pB0() = 0
				}
				if tex.mem[q].hh().b0() == tex.mem[r].hh().b0() {
					*tex.mem[int32(q)+2].pInt() = tex.mem[int32(q)+2].int() + tex.mem[int32(r)+2].int()
				} else if (tex.mem[q].hh().b0() < tex.mem[r].hh().b0()) && (tex.mem[int32(r)+2].int() != 0) {
					*tex.mem[int32(q)+2].pInt() = tex.mem[int32(r)+2].int()
					*tex.mem[q].pHh().pB0() = tex.mem[r].hh().b0()
				}
				if tex.mem[int32(q)+3].int() == 0 {
					*tex.mem[q].pHh().pB1() = 0
				}
				if tex.mem[q].hh().b1() == tex.mem[r].hh().b1() {
					*tex.mem[int32(q)+3].pInt() = tex.mem[int32(q)+3].int() + tex.mem[int32(r)+3].int()
				} else if (tex.mem[q].hh().b1() < tex.mem[r].hh().b1()) && (tex.mem[int32(r)+3].int() != 0) {
					*tex.mem[int32(q)+3].pInt() = tex.mem[int32(r)+3].int()
					*tex.mem[q].pHh().pB1() = tex.mem[r].hh().b1()
				}
				tex.curVal = int32(q)
			}
		}
	} else {
		tex.scanInt()
		if p < 2 {
			if q == 91 {
				if p == 0 {
					tex.curVal = tex.multAndAdd(tex.eqtb[l-1].int(), tex.curVal, 0, 2147483647)
				} else {
					tex.curVal = tex.multAndAdd(tex.eqtb[l-1].int(), tex.curVal, 0, 1073741823)
				}
			} else {
				tex.curVal = tex.xOverN(tex.eqtb[l-1].int(), tex.curVal)
			}
		} else {
			s = tex.eqtb[l-1].hh().rh
			r = tex.newSpec(s)
			if q == 91 {
				*tex.mem[int32(r)+1].pInt() = tex.multAndAdd(tex.mem[int32(s)+1].int(), tex.curVal, 0, 1073741823)
				*tex.mem[int32(r)+2].pInt() = tex.multAndAdd(tex.mem[int32(s)+2].int(), tex.curVal, 0, 1073741823)
				*tex.mem[int32(r)+3].pInt() = tex.multAndAdd(tex.mem[int32(s)+3].int(), tex.curVal, 0, 1073741823)
			} else {
				*tex.mem[int32(r)+1].pInt() = tex.xOverN(tex.mem[int32(s)+1].int(), tex.curVal)
				*tex.mem[int32(r)+2].pInt() = tex.xOverN(tex.mem[int32(s)+2].int(), tex.curVal)
				*tex.mem[int32(r)+3].pInt() = tex.xOverN(tex.mem[int32(s)+3].int(), tex.curVal)
			}
			tex.curVal = int32(r)
		}
	}
	if tex.arithError {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1207)
		tex.helpPtr = 2
		tex.helpLine[1] = 1208
		tex.helpLine[0] = 1209
		if p >= 2 {
			tex.deleteGlueRef(uint16(tex.curVal))
		}
		tex.error1()
		goto label10
	}
	if p < 2 {
		if a >= 4 {
			tex.geqWordDefine(l, tex.curVal)
		} else {
			tex.eqWordDefine(l, tex.curVal)
		}
	} else {
		tex.trapZeroGlue()
		if a >= 4 {
			tex.geqDefine(l, 117, uint16(tex.curVal))
		} else {
			tex.eqDefine(l, 117, uint16(tex.curVal))
		}
	}
label10:
}

func (tex *Context) alterAux() {
	var c uint16 // 0..65535
	if int32(tex.curChr) != iabs(int32(tex.curList.modeField)) {
		tex.reportIllegalCase()
	} else {
		c = tex.curChr
		tex.scanOptionalEquals()
		if c == 1 {
			tex.scanDimen(false, false, false)
			*tex.curList.auxField.pInt() = tex.curVal
		} else {
			tex.scanInt()
			if (tex.curVal <= 0) || (tex.curVal > 32767) {
				if tex.interaction == 3 {
				}
				tex.printNl(262)
				tex.print(1213)
				tex.helpPtr = 1
				tex.helpLine[0] = 1214
				tex.intError(tex.curVal)
			} else {
				*tex.curList.auxField.pHh().pLh() = uint16(tex.curVal)
			}
		}
	}
}

func (tex *Context) alterPrevGraf() {
	var p byte // 0..40
	tex.nest[tex.nestPtr] = tex.curList
	p = tex.nestPtr
	for iabs(int32(tex.nest[p].modeField)) != 1 {
		p = byte(int32(p) - 1)
	}
	tex.scanOptionalEquals()
	tex.scanInt()
	if tex.curVal < 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(955)
		tex.printEsc(532)
		tex.helpPtr = 1
		tex.helpLine[0] = 1215
		tex.intError(tex.curVal)
	} else {
		tex.nest[p].pgField = tex.curVal
		tex.curList = tex.nest[tex.nestPtr]
	}
}

func (tex *Context) alterPageSoFar() {
	var c byte // 0..7
	c = byte(tex.curChr)
	tex.scanOptionalEquals()
	tex.scanDimen(false, false, false)
	tex.pageSoFar[c] = tex.curVal
}

func (tex *Context) alterInteger() {
	var c byte // 0..1
	c = byte(tex.curChr)
	tex.scanOptionalEquals()
	tex.scanInt()
	if c == 0 {
		tex.deadCycles = tex.curVal
	} else {
		tex.insertPenalties = tex.curVal
	}
}

func (tex *Context) alterBoxDimen() {
	var c byte // 0..63
	var b byte // 0..255
	c = byte(tex.curChr)
	tex.scanEightBitInt()
	b = byte(tex.curVal)
	tex.scanOptionalEquals()
	tex.scanDimen(false, false, false)
	if tex.eqtb[3678+int32(b)-1].hh().rh != 0 {
		*tex.mem[int32(tex.eqtb[3678+int32(b)-1].hh().rh)+int32(c)].pInt() = tex.curVal
	}
}

func (tex *Context) newFont(a byte) {
	var u uint16               // 0..65535
	var s int32                // integer
	var f byte                 // 0..75
	var t uint16               // 0..3000
	var oldSetting byte        // 0..21
	var flushableString uint16 // 0..3000
	if tex.jobName == 0 {
		tex.openLogFile()
	}
	tex.getRToken()
	u = tex.curCs
	if u >= 514 {
		t = tex.hash[u-514].rh
	} else if u >= 257 {
		if u == 513 {
			t = 1219
		} else {
			t = uint16(int32(u) - 257)
		}
	} else {
		oldSetting = tex.selector
		tex.selector = 21
		tex.print(1219)
		tex.print(int32(u) - 1)
		tex.selector = oldSetting
		if int32(tex.poolPtr)+1 > poolSize {
			tex.overflow(257, poolSize-int32(tex.initPoolPtr))
		}
		t = tex.makeString()
	}
	if a >= 4 {
		tex.geqDefine(u, 87, 0)
	} else {
		tex.eqDefine(u, 87, 0)
	}
	tex.scanOptionalEquals()
	tex.scanFileName()
	tex.nameInProgress = true
	if tex.scanKeyword(1220) {
		tex.scanDimen(false, false, false)
		s = tex.curVal
		if (s <= 0) || (s >= 134217728) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1222)
			tex.printScaled(s)
			tex.print(1223)
			tex.helpPtr = 2
			tex.helpLine[1] = 1224
			tex.helpLine[0] = 1225
			tex.error1()
			s = (10 * 65536)
		}
	} else if tex.scanKeyword(1221) {
		tex.scanInt()
		s = -tex.curVal
		if (tex.curVal <= 0) || (tex.curVal > 32768) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(552)
			tex.helpPtr = 1
			tex.helpLine[0] = 553
			tex.intError(tex.curVal)
			s = -1000
		}
	} else {
		s = -1000
	}
	tex.nameInProgress = false
	flushableString = uint16(int32(tex.strPtr) - 1)
	for _i := int64(1); _i <= int64(tex.fontPtr); _i++ {
		f = byte(_i)
		if tex.strEqStr(tex.fontName[f], tex.curName) && tex.strEqStr(tex.fontArea[f], tex.curArea) {
			if tex.curName == flushableString {
				tex.strPtr = uint16(int32(tex.strPtr) - 1)
				tex.poolPtr = tex.strStart[tex.strPtr]
				tex.curName = tex.fontName[f]
			}
			if s > 0 {
				if s == tex.fontSize[f] {
					goto label50
				}
			} else if tex.fontSize[f] == tex.xnOverD(tex.fontDsize[f], -s, 1000) {
				goto label50
			}
		}
	}
	f = tex.readFontInfo(u, tex.curName, tex.curArea, s)
label50:
	tex.eqtb[u-1].pHh().rh = uint16(f)
	tex.eqtb[2624+int32(f)-1] = tex.eqtb[u-1]
	tex.hash[2624+int32(f)-514].rh = t
}

func (tex *Context) newInteraction() {
	tex.printLn()
	tex.interaction = byte(tex.curChr)
	if tex.interaction == 0 {
		tex.selector = 16
	} else {
		tex.selector = 17
	}
	if tex.logOpened {
		tex.selector = byte(int32(tex.selector) + 2)
	}
}

func (tex *Context) prefixedCommand() {
	var a byte      // 0..63
	var f byte      // 0..75
	var j uint16    // 0..65535
	var k uint16    // 0..20000
	var p, q uint16 // 0..65535
	var n int32     // integer
	var e bool      // boolean
	a = 0
	for tex.curCmd == 93 {
		if !odd((int32(a) / int32(tex.curChr))) {
			a = byte(int32(a) + int32(tex.curChr))
		}
		for {
			tex.getXToken()
			if (tex.curCmd != 10) && (tex.curCmd != 0) {
				break
			}
		}
		if tex.curCmd <= 70 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1179)
			tex.printCmdChr(tex.curCmd, tex.curChr)
			tex.printChar(39)
			tex.helpPtr = 1
			tex.helpLine[0] = 1180
			tex.backError()
			goto label10
		}
	}
	if (tex.curCmd != 97) && ((int32(a) % 4) != 0) {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(685)
		tex.printEsc(1171)
		tex.print(1181)
		tex.printEsc(1172)
		tex.print(1182)
		tex.printCmdChr(tex.curCmd, tex.curChr)
		tex.printChar(39)
		tex.helpPtr = 1
		tex.helpLine[0] = 1183
		tex.error1()
	}
	if tex.eqtb[5306-1].int() != 0 {
		if tex.eqtb[5306-1].int() < 0 {
			if a >= 4 {
				a = byte(int32(a) - 4)
			}
		} else {
			if !(a >= 4) {
				a = byte(int32(a) + 4)
			}
		}
	}
	switch tex.curCmd {
	case 87:
		if a >= 4 {
			tex.geqDefine(3934, 120, tex.curChr)
		} else {
			tex.eqDefine(3934, 120, tex.curChr)
		}
	case 97:
		if odd(int32(tex.curChr)) && !(a >= 4) && (tex.eqtb[5306-1].int() >= 0) {
			a = byte(int32(a) + 4)
		}
		e = (tex.curChr >= 2)
		tex.getRToken()
		p = tex.curCs
		q = tex.scanToks(true, e)
		if a >= 4 {
			tex.geqDefine(p, byte(111+(int32(a)%4)), tex.defRef)
		} else {
			tex.eqDefine(p, byte(111+(int32(a)%4)), tex.defRef)
		}
	case 94:
		n = int32(tex.curChr)
		tex.getRToken()
		p = tex.curCs
		if n == 0 {
			for {
				tex.getToken()
				if tex.curCmd != 10 {
					break
				}
			}
			if tex.curTok == 3133 {
				tex.getToken()
				if tex.curCmd == 10 {
					tex.getToken()
				}
			}
		} else {
			tex.getToken()
			q = tex.curTok
			tex.getToken()
			tex.backInput()
			tex.curTok = q
			tex.backInput()
		}
		if tex.curCmd >= 111 {
			*tex.mem[tex.curChr].pHh().pLh() = uint16(int32(tex.mem[tex.curChr].hh().lh()) + 1)
		}
		if a >= 4 {
			tex.geqDefine(p, tex.curCmd, tex.curChr)
		} else {
			tex.eqDefine(p, tex.curCmd, tex.curChr)
		}
	case 95:
		n = int32(tex.curChr)
		tex.getRToken()
		p = tex.curCs
		if a >= 4 {
			tex.geqDefine(p, 0, 256)
		} else {
			tex.eqDefine(p, 0, 256)
		}
		tex.scanOptionalEquals()
		switch n {
		case 0:
			tex.scanCharNum()
			if a >= 4 {
				tex.geqDefine(p, 68, uint16(tex.curVal))
			} else {
				tex.eqDefine(p, 68, uint16(tex.curVal))
			}
		case 1:
			tex.scanFifteenBitInt()
			if a >= 4 {
				tex.geqDefine(p, 69, uint16(tex.curVal))
			} else {
				tex.eqDefine(p, 69, uint16(tex.curVal))
			}
		default:
			tex.scanEightBitInt()
			switch n {
			case 2:
				if a >= 4 {
					tex.geqDefine(p, 73, uint16(5318+tex.curVal))
				} else {
					tex.eqDefine(p, 73, uint16(5318+tex.curVal))
				}
			case 3:
				if a >= 4 {
					tex.geqDefine(p, 74, uint16(5851+tex.curVal))
				} else {
					tex.eqDefine(p, 74, uint16(5851+tex.curVal))
				}
			case 4:
				if a >= 4 {
					tex.geqDefine(p, 75, uint16(2900+tex.curVal))
				} else {
					tex.eqDefine(p, 75, uint16(2900+tex.curVal))
				}
			case 5:
				if a >= 4 {
					tex.geqDefine(p, 76, uint16(3156+tex.curVal))
				} else {
					tex.eqDefine(p, 76, uint16(3156+tex.curVal))
				}
			case 6:
				if a >= 4 {
					tex.geqDefine(p, 72, uint16(3422+tex.curVal))
				} else {
					tex.eqDefine(p, 72, uint16(3422+tex.curVal))
				}
			}
		}
	case 96:
		tex.scanInt()
		n = tex.curVal
		if !tex.scanKeyword(842) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1073)
			tex.helpPtr = 2
			tex.helpLine[1] = 1200
			tex.helpLine[0] = 1201
			tex.error1()
		}
		tex.getRToken()
		p = tex.curCs
		tex.readToks(n, p)
		if a >= 4 {
			tex.geqDefine(p, 111, uint16(tex.curVal))
		} else {
			tex.eqDefine(p, 111, uint16(tex.curVal))
		}
	case 71, 72:
		q = tex.curCs
		if tex.curCmd == 71 {
			tex.scanEightBitInt()
			p = uint16(3422 + tex.curVal)
		} else {
			p = tex.curChr
		}
		tex.scanOptionalEquals()
		for {
			tex.getXToken()
			if (tex.curCmd != 10) && (tex.curCmd != 0) {
				break
			}
		}
		if tex.curCmd != 1 {
			if tex.curCmd == 71 {
				tex.scanEightBitInt()
				tex.curCmd = 72
				tex.curChr = uint16(3422 + tex.curVal)
			}
			if tex.curCmd == 72 {
				q = tex.eqtb[tex.curChr-1].hh().rh
				if q == 0 {
					if a >= 4 {
						tex.geqDefine(p, 101, 0)
					} else {
						tex.eqDefine(p, 101, 0)
					}
				} else {
					*tex.mem[q].pHh().pLh() = uint16(int32(tex.mem[q].hh().lh()) + 1)
					if a >= 4 {
						tex.geqDefine(p, 111, q)
					} else {
						tex.eqDefine(p, 111, q)
					}
				}
				goto label30
			}
		}
		tex.backInput()
		tex.curCs = q
		q = tex.scanToks(false, false)
		if tex.mem[tex.defRef].hh().rh == 0 {
			if a >= 4 {
				tex.geqDefine(p, 101, 0)
			} else {
				tex.eqDefine(p, 101, 0)
			}
			tex.mem[tex.defRef].pHh().rh = tex.avail
			tex.avail = tex.defRef
		} else {
			if p == 3413 {
				tex.mem[q].pHh().rh = tex.getAvail()
				q = tex.mem[q].hh().rh
				*tex.mem[q].pHh().pLh() = 637
				q = tex.getAvail()
				*tex.mem[q].pHh().pLh() = 379
				tex.mem[q].pHh().rh = tex.mem[tex.defRef].hh().rh
				tex.mem[tex.defRef].pHh().rh = q
			}
			if a >= 4 {
				tex.geqDefine(p, 111, tex.defRef)
			} else {
				tex.eqDefine(p, 111, tex.defRef)
			}
		}
	case 73:
		p = tex.curChr
		tex.scanOptionalEquals()
		tex.scanInt()
		if a >= 4 {
			tex.geqWordDefine(p, tex.curVal)
		} else {
			tex.eqWordDefine(p, tex.curVal)
		}
	case 74:
		p = tex.curChr
		tex.scanOptionalEquals()
		tex.scanDimen(false, false, false)
		if a >= 4 {
			tex.geqWordDefine(p, tex.curVal)
		} else {
			tex.eqWordDefine(p, tex.curVal)
		}
	case 75, 76:
		p = tex.curChr
		n = int32(tex.curCmd)
		tex.scanOptionalEquals()
		if n == 76 {
			tex.scanGlue(3)
		} else {
			tex.scanGlue(2)
		}
		tex.trapZeroGlue()
		if a >= 4 {
			tex.geqDefine(p, 117, uint16(tex.curVal))
		} else {
			tex.eqDefine(p, 117, uint16(tex.curVal))
		}
	case 85:
		if tex.curChr == 3983 {
			n = 15
		} else if tex.curChr == 5007 {
			n = 32768
		} else if tex.curChr == 4751 {
			n = 32767
		} else if tex.curChr == 5574 {
			n = 16777215
		} else {
			n = 255
		}
		p = tex.curChr
		tex.scanCharNum()
		p = uint16(int32(p) + tex.curVal)
		tex.scanOptionalEquals()
		tex.scanInt()
		if ((tex.curVal < 0) && (p < 5574)) || (tex.curVal > n) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1202)
			tex.printInt(tex.curVal)
			if p < 5574 {
				tex.print(1203)
			} else {
				tex.print(1204)
			}
			tex.printInt(n)
			tex.helpPtr = 1
			tex.helpLine[0] = 1205
			tex.error1()
			tex.curVal = 0
		}
		if p < 5007 {
			if a >= 4 {
				tex.geqDefine(p, 120, uint16(tex.curVal))
			} else {
				tex.eqDefine(p, 120, uint16(tex.curVal))
			}
		} else if p < 5574 {
			if a >= 4 {
				tex.geqDefine(p, 120, uint16(tex.curVal+0))
			} else {
				tex.eqDefine(p, 120, uint16(tex.curVal+0))
			}
		} else if a >= 4 {
			tex.geqWordDefine(p, tex.curVal)
		} else {
			tex.eqWordDefine(p, tex.curVal)
		}
	case 86:
		p = tex.curChr
		tex.scanFourBitInt()
		p = uint16(int32(p) + tex.curVal)
		tex.scanOptionalEquals()
		tex.scanFontIdent()
		if a >= 4 {
			tex.geqDefine(p, 120, uint16(tex.curVal))
		} else {
			tex.eqDefine(p, 120, uint16(tex.curVal))
		}
	case 89, 90, 91, 92:
		tex.doRegisterCommand(a)
	case 98:
		tex.scanEightBitInt()
		if a >= 4 {
			n = 256 + tex.curVal
		} else {
			n = tex.curVal
		}
		tex.scanOptionalEquals()
		if tex.setBoxAllowed {
			tex.scanBox(1073741824 + n)
		} else {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(680)
			tex.printEsc(536)
			tex.helpPtr = 2
			tex.helpLine[1] = 1211
			tex.helpLine[0] = 1212
			tex.error1()
		}
	case 79:
		tex.alterAux()
	case 80:
		tex.alterPrevGraf()
	case 81:
		tex.alterPageSoFar()
	case 82:
		tex.alterInteger()
	case 83:
		tex.alterBoxDimen()
	case 84:
		tex.scanOptionalEquals()
		tex.scanInt()
		n = tex.curVal
		if n <= 0 {
			p = 0
		} else {
			p = tex.getNode((2 * n) + 1)
			*tex.mem[p].pHh().pLh() = uint16(n)
			for _i := int64(1); _i <= int64(n); _i++ {
				j = uint16(_i)
				tex.scanDimen(false, false, false)
				*tex.mem[int32(p)+(2*int32(j))-1].pInt() = tex.curVal
				tex.scanDimen(false, false, false)
				*tex.mem[int32(p)+(2*int32(j))].pInt() = tex.curVal
			}
		}
		if a >= 4 {
			tex.geqDefine(3412, 118, p)
		} else {
			tex.eqDefine(3412, 118, p)
		}
	case 99:
		if tex.curChr == 1 {
			tex.newPatterns()
			goto label30
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1216)
			tex.helpPtr = 0
			tex.error1()
			for {
				tex.getToken()
				if tex.curCmd == 2 {
					break
				}
			}
			goto label10
		} else {
			tex.newHyphExceptions()
			goto label30
		}
	case 77:
		tex.findFontDimen(true)
		k = uint16(tex.curVal)
		tex.scanOptionalEquals()
		tex.scanDimen(false, false, false)
		*tex.fontInfo[k].pInt() = tex.curVal
	case 78:
		n = int32(tex.curChr)
		tex.scanFontIdent()
		f = byte(tex.curVal)
		tex.scanOptionalEquals()
		tex.scanInt()
		if n == 0 {
			tex.hyphenChar[f] = tex.curVal
		} else {
			tex.skewChar[f] = tex.curVal
		}
	case 88:
		tex.newFont(a)
	case 100:
		tex.newInteraction()
	default:
		tex.confusion(1178)
	}
label30:
	if tex.afterToken != 0 {
		tex.curTok = tex.afterToken
		tex.backInput()
		tex.afterToken = 0
	}
label10:
}

func (tex *Context) doAssignments() {
	for true {
		for {
			tex.getXToken()
			if (tex.curCmd != 10) && (tex.curCmd != 0) {
				break
			}
		}
		if tex.curCmd <= 70 {
			goto label10
		}
		tex.setBoxAllowed = false
		tex.prefixedCommand()
		tex.setBoxAllowed = true
	}
label10:
}

func (tex *Context) openOrCloseIn() {
	var c byte // 0..1
	var n byte // 0..15
	c = byte(tex.curChr)
	tex.scanFourBitInt()
	n = byte(tex.curVal)
	if tex.readOpen[n] != 2 {
		tex.aClose(&tex.readFile[n])
		tex.readOpen[n] = 2
	}
	if c != 0 {
		tex.scanOptionalEquals()
		tex.scanFileName()
		if tex.curExt == 338 {
			tex.curExt = 791
		}
		tex.packFileName(tex.curName, tex.curArea, tex.curExt)
		if tex.aOpenIn(&tex.readFile[n]) {
			tex.readOpen[n] = 1
		}
	}
}

func (tex *Context) issueMessage() {
	var oldSetting byte // 0..21
	var c byte          // 0..1
	var s uint16        // 0..3000
	c = byte(tex.curChr)
	tex.mem[29988].pHh().rh = tex.scanToks(false, true)
	oldSetting = tex.selector
	tex.selector = 21
	tex.tokenShow(tex.defRef)
	tex.selector = oldSetting
	tex.flushList(tex.defRef)
	if int32(tex.poolPtr)+1 > poolSize {
		tex.overflow(257, poolSize-int32(tex.initPoolPtr))
	}
	s = tex.makeString()
	if c == 0 {
		if int32(tex.termOffset)+(int32(tex.strStart[int32(s)+1])-int32(tex.strStart[s])) > maxPrintLine-2 {
			tex.printLn()
		} else if (tex.termOffset > 0) || (tex.fileOffset > 0) {
			tex.printChar(32)
		}
		tex.slowPrint(int32(s))
		break1(&tex.termOut)
	} else {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(338)
		tex.slowPrint(int32(s))
		if tex.eqtb[3421-1].hh().rh != 0 {
			tex.useErrHelp = true
		} else if tex.longHelpSeen {
			tex.helpPtr = 1
			tex.helpLine[0] = 1232
		} else {
			if tex.interaction < 3 {
				tex.longHelpSeen = true
			}
			tex.helpPtr = 4
			tex.helpLine[3] = 1233
			tex.helpLine[2] = 1234
			tex.helpLine[1] = 1235
			tex.helpLine[0] = 1236
		}
		tex.error1()
		tex.useErrHelp = false
	}
	tex.strPtr = uint16(int32(tex.strPtr) - 1)
	tex.poolPtr = tex.strStart[tex.strPtr]
}

func (tex *Context) shiftCase() {
	var b uint16 // 0..65535
	var p uint16 // 0..65535
	var t uint16 // 0..65535
	var c byte   // 0..255
	b = tex.curChr
	p = tex.scanToks(false, false)
	p = tex.mem[tex.defRef].hh().rh
	for p != 0 {
		t = tex.mem[p].hh().lh()
		if t < 4352 {
			c = byte((int32(t) % 256))
			if tex.eqtb[int32(b)+int32(c)-1].hh().rh != 0 {
				*tex.mem[p].pHh().pLh() = uint16(int32(t) - int32(c) + int32(tex.eqtb[int32(b)+int32(c)-1].hh().rh))
			}
		}
		p = tex.mem[p].hh().rh
	}
	tex.beginTokenList(tex.mem[tex.defRef].hh().rh, 3)
	tex.mem[tex.defRef].pHh().rh = tex.avail
	tex.avail = tex.defRef
}

func (tex *Context) showWhatever() {
	switch tex.curChr {
	case 3:
		tex.beginDiagnostic()
		tex.showActivities()
	case 1:
		tex.scanEightBitInt()
		tex.beginDiagnostic()
		tex.printNl(1254)
		tex.printInt(tex.curVal)
		tex.printChar(61)
		if tex.eqtb[3678+tex.curVal-1].hh().rh == 0 {
			tex.print(410)
		} else {
			tex.showBox(tex.eqtb[3678+tex.curVal-1].hh().rh)
		}
	case 0:
		tex.getToken()
		if tex.interaction == 3 {
		}
		tex.printNl(1248)
		if tex.curCs != 0 {
			tex.sprintCs(tex.curCs)
			tex.printChar(61)
		}
		tex.printMeaning()
		goto label50
	default:
		tex.theToks()
		if tex.interaction == 3 {
		}
		tex.printNl(1248)
		tex.tokenShow(29997)
		tex.flushList(tex.mem[29997].hh().rh)
		goto label50
	}
	tex.endDiagnostic(true)
	if tex.interaction == 3 {
	}
	tex.printNl(262)
	tex.print(1255)
	if tex.selector == 19 {
		if tex.eqtb[5292-1].int() <= 0 {
			tex.selector = 17
			tex.print(1256)
			tex.selector = 19
		}
	}
label50:
	if tex.interaction < 3 {
		tex.helpPtr = 0
		tex.errorCount = int8(int32(tex.errorCount) - 1)
	} else if tex.eqtb[5292-1].int() > 0 {
		tex.helpPtr = 3
		tex.helpLine[2] = 1243
		tex.helpLine[1] = 1244
		tex.helpLine[0] = 1245
	} else {
		tex.helpPtr = 5
		tex.helpLine[4] = 1243
		tex.helpLine[3] = 1244
		tex.helpLine[2] = 1245
		tex.helpLine[1] = 1246
		tex.helpLine[0] = 1247
	}
	tex.error1()
}

func (tex *Context) storeFmtFile() {
	var j, k, l int32  // integer
	var p, q uint16    // 0..65535
	var x int32        // integer
	var w fourQuarters // record fourQuarters
	if tex.savePtr != 0 {
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1258)
		tex.helpPtr = 1
		tex.helpLine[0] = 1259
		if tex.interaction == 3 {
			tex.interaction = 2
		}
		if tex.logOpened {
			tex.error1()
		}
		tex.history = 3
		tex.jumpOut()
	}
	tex.selector = 21
	tex.print(1272)
	tex.print(int32(tex.jobName))
	tex.printChar(32)
	tex.printInt(tex.eqtb[5286-1].int())
	tex.printChar(46)
	tex.printInt(tex.eqtb[5285-1].int())
	tex.printChar(46)
	tex.printInt(tex.eqtb[5284-1].int())
	tex.printChar(41)
	if tex.interaction == 0 {
		tex.selector = 18
	} else {
		tex.selector = 19
	}
	if int32(tex.poolPtr)+1 > poolSize {
		tex.overflow(257, poolSize-int32(tex.initPoolPtr))
	}
	tex.formatIdent = tex.makeString()
	tex.packJobName(786)
	for !tex.wOpenOut(&tex.fmtFile) {
		tex.promptFileName(1273, 786)
	}
	tex.printNl(1274)
	tex.slowPrint(int32(tex.wMakeNameString(&tex.fmtFile)))
	tex.strPtr = uint16(int32(tex.strPtr) - 1)
	tex.poolPtr = tex.strStart[tex.strPtr]
	tex.printNl(338)
	tex.slowPrint(int32(tex.formatIdent))
	*tex.fmtFile.pMemoryWord().pInt() = 504454778
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 0
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 30000
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 6106
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 1777
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 307
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.poolPtr)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.strPtr)
	put(&tex.fmtFile)
	for _i := int64(0); _i <= int64(tex.strPtr); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.strStart[k])
		put(&tex.fmtFile)
	}
	k = 0
	for k+4 < int32(tex.poolPtr) {
		w.b0 = byte(int32(tex.strPool[k]) + 0)
		w.b1 = byte(int32(tex.strPool[k+1]) + 0)
		w.b2 = byte(int32(tex.strPool[k+2]) + 0)
		w.b3 = byte(int32(tex.strPool[k+3]) + 0)
		*tex.fmtFile.pMemoryWord().pQqqq() = w
		put(&tex.fmtFile)
		k = k + 4
	}
	k = int32(tex.poolPtr) - 4
	w.b0 = byte(int32(tex.strPool[k]) + 0)
	w.b1 = byte(int32(tex.strPool[k+1]) + 0)
	w.b2 = byte(int32(tex.strPool[k+2]) + 0)
	w.b3 = byte(int32(tex.strPool[k+3]) + 0)
	*tex.fmtFile.pMemoryWord().pQqqq() = w
	put(&tex.fmtFile)
	tex.printLn()
	tex.printInt(int32(tex.strPtr))
	tex.print(1260)
	tex.printInt(int32(tex.poolPtr))
	tex.sortAvail()
	tex.varUsed = 0
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.loMemMax)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.rover)
	put(&tex.fmtFile)
	p = 0
	q = tex.rover
	x = 0
	for {
		for _i := int64(p); _i <= int64(int32(q)+1); _i++ {
			k = int32(_i)
			*tex.fmtFile.pMemoryWord() = tex.mem[k]
			put(&tex.fmtFile)
		}
		x = x + int32(q) + 2 - int32(p)
		tex.varUsed = tex.varUsed + int32(q) - int32(p)
		p = uint16(int32(q) + int32(tex.mem[q].hh().lh()))
		q = tex.mem[int32(q)+1].hh().rh
		if q == tex.rover {
			break
		}
	}
	tex.varUsed = tex.varUsed + int32(tex.loMemMax) - int32(p)
	tex.dynUsed = int32(tex.memEnd) + 1 - int32(tex.hiMemMin)
	for _i := int64(p); _i <= int64(tex.loMemMax); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord() = tex.mem[k]
		put(&tex.fmtFile)
	}
	x = x + int32(tex.loMemMax) + 1 - int32(p)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hiMemMin)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.avail)
	put(&tex.fmtFile)
	for _i := int64(tex.hiMemMin); _i <= int64(tex.memEnd); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord() = tex.mem[k]
		put(&tex.fmtFile)
	}
	x = x + int32(tex.memEnd) + 1 - int32(tex.hiMemMin)
	p = tex.avail
	for p != 0 {
		tex.dynUsed = tex.dynUsed - 1
		p = tex.mem[p].hh().rh
	}
	*tex.fmtFile.pMemoryWord().pInt() = tex.varUsed
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = tex.dynUsed
	put(&tex.fmtFile)
	tex.printLn()
	tex.printInt(x)
	tex.print(1261)
	tex.printInt(tex.varUsed)
	tex.printChar(38)
	tex.printInt(tex.dynUsed)
	k = 1
	for {
		j = k
		for j < 5262 {
			if (tex.eqtb[j-1].hh().rh == tex.eqtb[j+1-1].hh().rh) && (tex.eqtb[j-1].hh().b0() == tex.eqtb[j+1-1].hh().b0()) && (tex.eqtb[j-1].hh().b1() == tex.eqtb[j+1-1].hh().b1()) {
				goto label41
			}
			j = j + 1
		}
		l = 5263
		goto label31
	label41:
		j = j + 1
		l = j
		for j < 5262 {
			if (tex.eqtb[j-1].hh().rh != tex.eqtb[j+1-1].hh().rh) || (tex.eqtb[j-1].hh().b0() != tex.eqtb[j+1-1].hh().b0()) || (tex.eqtb[j-1].hh().b1() != tex.eqtb[j+1-1].hh().b1()) {
				goto label31
			}
			j = j + 1
		}
	label31:
		{
			*tex.fmtFile.pMemoryWord().pInt() = l - k
			put(&tex.fmtFile)
		}
		for k < l {
			*tex.fmtFile.pMemoryWord() = tex.eqtb[k-1]
			put(&tex.fmtFile)
			k = k + 1
		}
		k = j + 1

		{
			*tex.fmtFile.pMemoryWord().pInt() = k - l
			put(&tex.fmtFile)
		}
		if k == 5263 {
			break
		}
	}
	for {
		j = k
		for j < 6106 {
			if tex.eqtb[j-1].int() == tex.eqtb[j+1-1].int() {
				goto label42
			}
			j = j + 1
		}
		l = 6107
		goto label32
	label42:
		j = j + 1
		l = j
		for j < 6106 {
			if tex.eqtb[j-1].int() != tex.eqtb[j+1-1].int() {
				goto label32
			}
			j = j + 1
		}
	label32:
		{
			*tex.fmtFile.pMemoryWord().pInt() = l - k
			put(&tex.fmtFile)
		}
		for k < l {
			*tex.fmtFile.pMemoryWord() = tex.eqtb[k-1]
			put(&tex.fmtFile)
			k = k + 1
		}
		k = j + 1

		{
			*tex.fmtFile.pMemoryWord().pInt() = k - l
			put(&tex.fmtFile)
		}
		if k > 6106 {
			break
		}
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.parLoc)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.writeLoc)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hashUsed)
	put(&tex.fmtFile)
	tex.csCount = 2613 - int32(tex.hashUsed)
	for _i := int64(514); _i <= int64(tex.hashUsed); _i++ {
		p = uint16(_i)
		if tex.hash[p-514].rh != 0 {
			*tex.fmtFile.pMemoryWord().pInt() = int32(p)
			put(&tex.fmtFile)
			*tex.fmtFile.pMemoryWord().pHh() = tex.hash[p-514]
			put(&tex.fmtFile)
			tex.csCount = tex.csCount + 1
		}
	}
	for _i := int64(int32(tex.hashUsed) + 1); _i <= int64(2880); _i++ {
		p = uint16(_i)
		*tex.fmtFile.pMemoryWord().pHh() = tex.hash[p-514]
		put(&tex.fmtFile)
	}
	*tex.fmtFile.pMemoryWord().pInt() = tex.csCount
	put(&tex.fmtFile)
	tex.printLn()
	tex.printInt(tex.csCount)
	tex.print(1262)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fmemPtr)
	put(&tex.fmtFile)
	for _i := int64(0); _i <= int64(int32(tex.fmemPtr)-1); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord() = tex.fontInfo[k]
		put(&tex.fmtFile)
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontPtr)
	put(&tex.fmtFile)
	for _i := int64(0); _i <= int64(tex.fontPtr); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord().pQqqq() = tex.fontCheck[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.fontSize[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.fontDsize[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontParams[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.hyphenChar[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.skewChar[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontName[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontArea[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontBc[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontEc[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.charBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.widthBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.heightBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.depthBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.italicBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.ligKernBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.kernBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.extenBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = tex.paramBase[k]
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontGlue[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.bcharLabel[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontBchar[k])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.fontFalseBchar[k])
		put(&tex.fmtFile)
		tex.printNl(1265)
		tex.printEsc(tex.hash[2624+k-514].rh)
		tex.printChar(61)
		tex.printFileName(int32(tex.fontName[k]), int32(tex.fontArea[k]), 338)
		if tex.fontSize[k] != tex.fontDsize[k] {
			tex.print(741)
			tex.printScaled(tex.fontSize[k])
			tex.print(397)
		}
	}
	tex.printLn()
	tex.printInt(int32(tex.fmemPtr) - 7)
	tex.print(1263)
	tex.printInt(int32(tex.fontPtr) - 0)
	tex.print(1264)
	if tex.fontPtr != 1 {
		tex.printChar(115)
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyphCount)
	put(&tex.fmtFile)
	for _i := int64(0); _i <= int64(307); _i++ {
		k = int32(_i)
		if tex.hyphWord[k] != 0 {
			*tex.fmtFile.pMemoryWord().pInt() = k
			put(&tex.fmtFile)
			*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyphWord[k])
			put(&tex.fmtFile)
			*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyphList[k])
			put(&tex.fmtFile)
		}
	}
	tex.printLn()
	tex.printInt(int32(tex.hyphCount))
	tex.print(1266)
	if tex.hyphCount != 1 {
		tex.printChar(115)
	}
	if tex.trieNotReady {
		tex.initTrie()
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.trieMax)
	put(&tex.fmtFile)
	for _i := int64(0); _i <= int64(tex.trieMax); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord().pHh() = tex.trie[k]
		put(&tex.fmtFile)
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.trieOpPtr)
	put(&tex.fmtFile)
	for _i := int64(1); _i <= int64(tex.trieOpPtr); _i++ {
		k = int32(_i)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyfDistance[k-1])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyfNum[k-1])
		put(&tex.fmtFile)
		*tex.fmtFile.pMemoryWord().pInt() = int32(tex.hyfNext[k-1])
		put(&tex.fmtFile)
	}
	tex.printNl(1267)
	tex.printInt(int32(tex.trieMax))
	tex.print(1268)
	tex.printInt(int32(tex.trieOpPtr))
	tex.print(1269)
	if tex.trieOpPtr != 1 {
		tex.printChar(115)
	}
	tex.print(1270)
	tex.printInt(trieOpSize)
	for _i := int64(255); _i >= int64(0); _i-- {
		k = int32(_i)
		if tex.trieUsed[k] > 0 {
			tex.printNl(800)
			tex.printInt(int32(tex.trieUsed[k]) - 0)
			tex.print(1271)
			tex.printInt(k)
			*tex.fmtFile.pMemoryWord().pInt() = k
			put(&tex.fmtFile)
			*tex.fmtFile.pMemoryWord().pInt() = int32(tex.trieUsed[k]) - 0
			put(&tex.fmtFile)
		}
	}
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.interaction)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = int32(tex.formatIdent)
	put(&tex.fmtFile)
	*tex.fmtFile.pMemoryWord().pInt() = 69069
	put(&tex.fmtFile)
	*tex.eqtb[5294-1].pInt() = 0
	tex.wClose(&tex.fmtFile)
}

func (tex *Context) newWhatsit(s byte, w byte) {
	var p uint16 // 0..65535
	p = tex.getNode(int32(w))
	*tex.mem[p].pHh().pB0() = 8
	*tex.mem[p].pHh().pB1() = s
	tex.mem[tex.curList.tailField].pHh().rh = p
	tex.curList.tailField = p
}

func (tex *Context) newWriteWhatsit(w byte) {
	tex.newWhatsit(byte(tex.curChr), w)
	if w != 2 {
		tex.scanFourBitInt()
	} else {
		tex.scanInt()
		if tex.curVal < 0 {
			tex.curVal = 17
		} else if tex.curVal > 15 {
			tex.curVal = 16
		}
	}
	*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = uint16(tex.curVal)
}

func (tex *Context) doExtension() {
	var k int32  // integer
	var p uint16 // 0..65535
	switch tex.curChr {
	case 0:
		tex.newWriteWhatsit(3)
		tex.scanOptionalEquals()
		tex.scanFileName()
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = tex.curName
		*tex.mem[int32(tex.curList.tailField)+2].pHh().pLh() = tex.curArea
		tex.mem[int32(tex.curList.tailField)+2].pHh().rh = tex.curExt
	case 1:
		k = int32(tex.curCs)
		tex.newWriteWhatsit(2)
		tex.curCs = uint16(k)
		p = tex.scanToks(false, false)
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = tex.defRef
	case 2:
		tex.newWriteWhatsit(2)
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = 0
	case 3:
		tex.newWhatsit(3, 2)
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = 0
		p = tex.scanToks(false, true)
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = tex.defRef
	case 4:
		tex.getXToken()
		if (tex.curCmd == 59) && (tex.curChr <= 2) {
			p = tex.curList.tailField
			tex.doExtension()
			tex.outWhat(tex.curList.tailField)
			tex.flushNodeList(tex.curList.tailField)
			tex.curList.tailField = p
			tex.mem[p].pHh().rh = 0
		} else {
			tex.backInput()
		}
	case 5:
		if iabs(int32(tex.curList.modeField)) != 102 {
			tex.reportIllegalCase()
		} else {
			tex.newWhatsit(4, 2)
			tex.scanInt()
			if tex.curVal <= 0 {
				tex.curList.auxField.pHh().rh = 0
			} else if tex.curVal > 255 {
				tex.curList.auxField.pHh().rh = 0
			} else {
				tex.curList.auxField.pHh().rh = uint16(tex.curVal)
			}
			tex.mem[int32(tex.curList.tailField)+1].pHh().rh = tex.curList.auxField.hh().rh
			*tex.mem[int32(tex.curList.tailField)+1].pHh().pB0() = tex.normMin(tex.eqtb[5314-1].int())
			*tex.mem[int32(tex.curList.tailField)+1].pHh().pB1() = tex.normMin(tex.eqtb[5315-1].int())
		}
	default:
		tex.confusion(1291)
	}
}

func (tex *Context) fixLanguage() {
	var l byte // 0..255
	if tex.eqtb[5313-1].int() <= 0 {
		l = 0
	} else if tex.eqtb[5313-1].int() > 255 {
		l = 0
	} else {
		l = byte(tex.eqtb[5313-1].int())
	}
	if uint16(l) != tex.curList.auxField.hh().rh {
		tex.newWhatsit(4, 2)
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = uint16(l)
		tex.curList.auxField.pHh().rh = uint16(l)
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pB0() = tex.normMin(tex.eqtb[5314-1].int())
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pB1() = tex.normMin(tex.eqtb[5315-1].int())
	}
}

func (tex *Context) handleRightBrace() {
	var p, q uint16 // 0..65535
	var d int32     // integer
	var f int32     // integer
	switch tex.curGroup {
	case 1:
		tex.unsave()
	case 0:
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(1044)
		tex.helpPtr = 2
		tex.helpLine[1] = 1045
		tex.helpLine[0] = 1046
		tex.error1()
	case 14, 15, 16:
		tex.extraRightBrace()
	case 2:
		tex.package1(0)
	case 3:
		tex.adjustTail = 29995
		tex.package1(0)
	case 4:
		tex.endGraf()
		tex.package1(0)
	case 5:
		tex.endGraf()
		tex.package1(4)
	case 11:
		tex.endGraf()
		q = tex.eqtb[2892-1].hh().rh
		tex.mem[q].pHh().rh = uint16(int32(tex.mem[q].hh().rh) + 1)
		d = tex.eqtb[5836-1].int()
		f = tex.eqtb[5305-1].int()
		tex.unsave()
		tex.savePtr = uint16(int32(tex.savePtr) - 1)
		p = tex.vpackage(tex.mem[tex.curList.headField].hh().rh, 0, 1, 1073741823)
		tex.popNest()
		if tex.saveStack[int32(tex.savePtr)+0].int() < 255 {
			tex.mem[tex.curList.tailField].pHh().rh = tex.getNode(5)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
			*tex.mem[tex.curList.tailField].pHh().pB0() = 3
			*tex.mem[tex.curList.tailField].pHh().pB1() = byte(tex.saveStack[int32(tex.savePtr)+0].int() + 0)
			*tex.mem[int32(tex.curList.tailField)+3].pInt() = tex.mem[int32(p)+3].int() + tex.mem[int32(p)+2].int()
			*tex.mem[int32(tex.curList.tailField)+4].pHh().pLh() = tex.mem[int32(p)+5].hh().rh
			tex.mem[int32(tex.curList.tailField)+4].pHh().rh = q
			*tex.mem[int32(tex.curList.tailField)+2].pInt() = d
			*tex.mem[int32(tex.curList.tailField)+1].pInt() = f
		} else {
			tex.mem[tex.curList.tailField].pHh().rh = tex.getNode(2)
			tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
			*tex.mem[tex.curList.tailField].pHh().pB0() = 5
			*tex.mem[tex.curList.tailField].pHh().pB1() = 0
			*tex.mem[int32(tex.curList.tailField)+1].pInt() = int32(tex.mem[int32(p)+5].hh().rh)
			tex.deleteGlueRef(q)
		}
		tex.freeNode(p, 7)
		if tex.nestPtr == 0 {
			tex.buildPage()
		}
	case 8:
		if (tex.curInput.locField != 0) || ((tex.curInput.indexField != 6) && (tex.curInput.indexField != 3)) {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1010)
			tex.helpPtr = 2
			tex.helpLine[1] = 1011
			tex.helpLine[0] = 1012
			tex.error1()
			for {
				tex.getToken()
				if tex.curInput.locField == 0 {
					break
				}
			}
		}
		tex.endTokenList()
		tex.endGraf()
		tex.unsave()
		tex.outputActive = false
		tex.insertPenalties = 0
		if tex.eqtb[3933-1].hh().rh != 0 {
			if tex.interaction == 3 {
			}
			tex.printNl(262)
			tex.print(1013)
			tex.printEsc(409)
			tex.printInt(255)
			tex.helpPtr = 3
			tex.helpLine[2] = 1014
			tex.helpLine[1] = 1015
			tex.helpLine[0] = 1016
			tex.boxError(255)
		}
		if tex.curList.tailField != tex.curList.headField {
			tex.mem[tex.pageTail].pHh().rh = tex.mem[tex.curList.headField].hh().rh
			tex.pageTail = tex.curList.tailField
		}
		if tex.mem[29998].hh().rh != 0 {
			if tex.mem[29999].hh().rh == 0 {
				tex.nest[0].tailField = tex.pageTail
			}
			tex.mem[tex.pageTail].pHh().rh = tex.mem[29999].hh().rh
			tex.mem[29999].pHh().rh = tex.mem[29998].hh().rh
			tex.mem[29998].pHh().rh = 0
			tex.pageTail = 29998
		}
		tex.popNest()
		tex.buildPage()
	case 10:
		tex.buildDiscretionary()
	case 6:
		tex.backInput()
		tex.curTok = 6710
		if tex.interaction == 3 {
		}
		tex.printNl(262)
		tex.print(625)
		tex.printEsc(899)
		tex.print(626)
		tex.helpPtr = 1
		tex.helpLine[0] = 1125
		tex.insError()
	case 7:
		tex.endGraf()
		tex.unsave()
		tex.alignPeek()
	case 12:
		tex.endGraf()
		tex.unsave()
		tex.savePtr = uint16(int32(tex.savePtr) - 2)
		p = tex.vpackage(tex.mem[tex.curList.headField].hh().rh, tex.saveStack[int32(tex.savePtr)+1].int(), byte(tex.saveStack[int32(tex.savePtr)+0].int()), 1073741823)
		tex.popNest()
		tex.mem[tex.curList.tailField].pHh().rh = tex.newNoad()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[tex.curList.tailField].pHh().pB0() = 29
		tex.mem[int32(tex.curList.tailField)+1].pHh().rh = 2
		*tex.mem[int32(tex.curList.tailField)+1].pHh().pLh() = p
	case 13:
		tex.buildChoices()
	case 9:
		tex.unsave()
		tex.savePtr = uint16(int32(tex.savePtr) - 1)
		tex.mem[tex.saveStack[int32(tex.savePtr)+0].int()].pHh().rh = 3
		p = tex.finMlist(0)
		*tex.mem[tex.saveStack[int32(tex.savePtr)+0].int()].pHh().pLh() = p
		if p != 0 {
			if tex.mem[p].hh().rh == 0 {
				if tex.mem[p].hh().b0() == 16 {
					if tex.mem[int32(p)+3].hh().rh == 0 {
						if tex.mem[int32(p)+2].hh().rh == 0 {
							*tex.mem[tex.saveStack[int32(tex.savePtr)+0].int()].pHh() = tex.mem[int32(p)+1].hh()
							tex.freeNode(p, 4)
						}
					}
				} else if tex.mem[p].hh().b0() == 28 {
					if tex.saveStack[int32(tex.savePtr)+0].int() == int32(tex.curList.tailField)+1 {
						if tex.mem[tex.curList.tailField].hh().b0() == 16 {
							q = tex.curList.headField
							for tex.mem[q].hh().rh != tex.curList.tailField {
								q = tex.mem[q].hh().rh
							}
							tex.mem[q].pHh().rh = p
							tex.freeNode(tex.curList.tailField, 4)
							tex.curList.tailField = p
						}
					}
				}
			}
		}
	default:
		tex.confusion(1047)
	}
}

func (tex *Context) mainControl() {
	var t int32 // integer
	if tex.eqtb[3419-1].hh().rh != 0 {
		tex.beginTokenList(tex.eqtb[3419-1].hh().rh, 12)
	}
label60:
	tex.getXToken()
label21:
	if tex.interrupt != 0 {
		if tex.OKToInterrupt {
			tex.backInput()
			if tex.interrupt != 0 {
				tex.pauseForInstructions()
			}
			goto label60
		}
	}
	if tex.eqtb[5299-1].int() > 0 {
		tex.showCurCmdChr()
	}
	switch iabs(int32(tex.curList.modeField)) + int32(tex.curCmd) {
	case 113, 114, 170:
		goto label70
	case 118:
		tex.scanCharNum()
		tex.curChr = uint16(tex.curVal)
		goto label70
	case 167:
		tex.getXToken()
		if (tex.curCmd == 11) || (tex.curCmd == 12) || (tex.curCmd == 68) || (tex.curCmd == 16) {
			tex.cancelBoundary = true
		}
		goto label21
	case 112:
		if tex.curList.auxField.hh().lh() == 1000 {
			goto label120
		} else {
			tex.appSpace()
		}
	case 166, 267:
		goto label120
	case 1, 102, 203, 11, 213, 268:
	case 40, 141, 242:
		for {
			tex.getXToken()
			if tex.curCmd != 10 {
				break
			}
		}
		goto label21
	case 15:
		if tex.itsAllOver() {
			goto label10
		}
	case 23, 123, 224, 71, 172, 273, 39, 45, 49, 150, 7, 108, 209:
		tex.reportIllegalCase()
	case 8, 109, 9, 110, 18, 119, 70, 171, 51, 152, 16, 117, 50, 151, 53, 154, 67, 168, 54, 155, 55, 156, 57, 158, 56, 157, 31, 132, 52, 153, 29, 130, 47, 148, 212, 216, 217, 230, 227, 236, 239:
		tex.insertDollarSign()
	case 37, 137, 238:
		tex.mem[tex.curList.tailField].pHh().rh = tex.scanRuleSpec()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		if iabs(int32(tex.curList.modeField)) == 1 {
			*tex.curList.auxField.pInt() = -65536000
		} else if iabs(int32(tex.curList.modeField)) == 102 {
			*tex.curList.auxField.pHh().pLh() = 1000
		}
	case 28, 128, 229, 231:
		tex.appendGlue()
	case 30, 131, 232, 233:
		tex.appendKern()
	case 2, 103:
		tex.newSaveLevel(1)
	case 62, 163, 264:
		tex.newSaveLevel(14)
	case 63, 164, 265:
		if tex.curGroup == 14 {
			tex.unsave()
		} else {
			tex.offSave()
		}
	case 3, 104, 205:
		tex.handleRightBrace()
	case 22, 124, 225:
		t = int32(tex.curChr)
		tex.scanDimen(false, false, false)
		if t == 0 {
			tex.scanBox(tex.curVal)
		} else {
			tex.scanBox(-tex.curVal)
		}
	case 32, 133, 234:
		tex.scanBox(1073742237 + int32(tex.curChr))
	case 21, 122, 223:
		tex.beginBox(0)
	case 44:
		tex.newGraf(tex.curChr > 0)
	case 12, 13, 17, 69, 4, 24, 36, 46, 48, 27, 34, 65, 66:
		tex.backInput()
		tex.newGraf(true)
	case 145, 246:
		tex.indentInHmode()
	case 14:
		tex.normalParagraph()
		if tex.curList.modeField > 0 {
			tex.buildPage()
		}
	case 115:
		if tex.alignState < 0 {
			tex.offSave()
		}
		tex.endGraf()
		if tex.curList.modeField == 1 {
			tex.buildPage()
		}
	case 116, 129, 138, 126, 134:
		tex.headForVmode()
	case 38, 139, 240, 140, 241:
		tex.beginInsertOrAdjust()
	case 19, 120, 221:
		tex.makeMark()
	case 43, 144, 245:
		tex.appendPenalty()
	case 26, 127, 228:
		tex.deleteLast()
	case 25, 125, 226:
		tex.unpackage()
	case 146:
		tex.appendItalicCorrection()
	case 247:
		tex.mem[tex.curList.tailField].pHh().rh = tex.newKern(0)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	case 149, 250:
		tex.appendDiscretionary()
	case 147:
		tex.makeAccent()
	case 6, 107, 208, 5, 106, 207:
		tex.alignError()
	case 35, 136, 237:
		tex.noAlignError()
	case 64, 165, 266:
		tex.omitError()
	case 33, 135:
		tex.initAlign()
	case 235:
		if tex.privileged() {
			if tex.curGroup == 15 {
				tex.initAlign()
			} else {
				tex.offSave()
			}
		}
	case 10, 111:
		tex.doEndv()
	case 68, 169, 270:
		tex.csError()
	case 105:
		tex.initMath()
	case 251:
		if tex.privileged() {
			if tex.curGroup == 15 {
				tex.startEqNo()
			} else {
				tex.offSave()
			}
		}
	case 204:
		tex.mem[tex.curList.tailField].pHh().rh = tex.newNoad()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		tex.backInput()
		tex.scanMath(uint16(int32(tex.curList.tailField) + 1))
	case 214, 215, 271:
		tex.setMathChar(int32(tex.eqtb[5007+int32(tex.curChr)-1].hh().rh) - 0)
	case 219:
		tex.scanCharNum()
		tex.curChr = uint16(tex.curVal)
		tex.setMathChar(int32(tex.eqtb[5007+int32(tex.curChr)-1].hh().rh) - 0)
	case 220:
		tex.scanFifteenBitInt()
		tex.setMathChar(tex.curVal)
	case 272:
		tex.setMathChar(int32(tex.curChr))
	case 218:
		tex.scanTwentySevenBitInt()
		tex.setMathChar((tex.curVal / 4096))
	case 253:
		tex.mem[tex.curList.tailField].pHh().rh = tex.newNoad()
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[tex.curList.tailField].pHh().pB0() = byte(tex.curChr)
		tex.scanMath(uint16(int32(tex.curList.tailField) + 1))
	case 254:
		tex.mathLimitSwitch()
	case 269:
		tex.mathRadical()
	case 248, 249:
		tex.mathAc()
	case 259:
		tex.scanSpec(12, false)
		tex.normalParagraph()
		tex.pushNest()
		tex.curList.modeField = -1
		*tex.curList.auxField.pInt() = -65536000
		if tex.eqtb[3418-1].hh().rh != 0 {
			tex.beginTokenList(tex.eqtb[3418-1].hh().rh, 11)
		}
	case 256:
		tex.mem[tex.curList.tailField].pHh().rh = tex.newStyle(byte(tex.curChr))
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	case 258:
		tex.mem[tex.curList.tailField].pHh().rh = tex.newGlue(0)
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
		*tex.mem[tex.curList.tailField].pHh().pB1() = 98
	case 257:
		tex.appendChoices()
	case 211, 210:
		tex.subSup()
	case 255:
		tex.mathFraction()
	case 252:
		tex.mathLeftRight()
	case 206:
		if tex.curGroup == 15 {
			tex.afterMath()
		} else {
			tex.offSave()
		}
	case 72, 173, 274, 73, 174, 275, 74, 175, 276, 75, 176, 277, 76, 177, 278, 77, 178, 279, 78, 179, 280, 79, 180, 281, 80, 181, 282, 81, 182, 283, 82, 183, 284, 83, 184, 285, 84, 185, 286, 85, 186, 287, 86, 187, 288, 87, 188, 289, 88, 189, 290, 89, 190, 291, 90, 191, 292, 91, 192, 293, 92, 193, 294, 93, 194, 295, 94, 195, 296, 95, 196, 297, 96, 197, 298, 97, 198, 299, 98, 199, 300, 99, 200, 301, 100, 201, 302, 101, 202, 303:
		tex.prefixedCommand()
	case 41, 142, 243:
		tex.getToken()
		tex.afterToken = tex.curTok
	case 42, 143, 244:
		tex.getToken()
		tex.saveForAfter(tex.curTok)
	case 61, 162, 263:
		tex.openOrCloseIn()
	case 59, 160, 261:
		tex.issueMessage()
	case 58, 159, 260:
		tex.shiftCase()
	case 20, 121, 222:
		tex.showWhatever()
	case 60, 161, 262:
		tex.doExtension()
	}
	goto label60
label70:
	tex.mainS = int32(tex.eqtb[4751+int32(tex.curChr)-1].hh().rh)
	if tex.mainS == 1000 {
		*tex.curList.auxField.pHh().pLh() = 1000
	} else if tex.mainS < 1000 {
		if tex.mainS > 0 {
			*tex.curList.auxField.pHh().pLh() = uint16(tex.mainS)
		}
	} else if tex.curList.auxField.hh().lh() < 1000 {
		*tex.curList.auxField.pHh().pLh() = 1000
	} else {
		*tex.curList.auxField.pHh().pLh() = uint16(tex.mainS)
	}
	tex.mainF = byte(tex.eqtb[3934-1].hh().rh)
	tex.bchar = tex.fontBchar[tex.mainF]
	tex.falseBchar = tex.fontFalseBchar[tex.mainF]
	if tex.curList.modeField > 0 {
		if tex.eqtb[5313-1].int() != int32(tex.curList.auxField.hh().rh) {
			tex.fixLanguage()
		}
	}
	tex.ligStack = tex.avail
	if tex.ligStack == 0 {
		tex.ligStack = tex.getAvail()
	} else {
		tex.avail = tex.mem[tex.ligStack].hh().rh
		tex.mem[tex.ligStack].pHh().rh = 0
	}
	*tex.mem[tex.ligStack].pHh().pB0() = tex.mainF
	tex.curL = uint16(int32(tex.curChr) + 0)
	*tex.mem[tex.ligStack].pHh().pB1() = byte(tex.curL)
	tex.curQ = tex.curList.tailField
	if tex.cancelBoundary {
		tex.cancelBoundary = false
		tex.mainK = 0
	} else {
		tex.mainK = tex.bcharLabel[tex.mainF]
	}
	if tex.mainK == 0 {
		goto label92
	}
	tex.curR = tex.curL
	tex.curL = 256
	goto label111
label80:
	if tex.curL < 256 {
		if tex.mem[tex.curQ].hh().rh > 0 {
			if int32(tex.mem[tex.curList.tailField].hh().b1()) == tex.hyphenChar[tex.mainF]+0 {
				tex.insDisc = true
			}
		}
		if tex.ligaturePresent {
			tex.mainP = tex.newLigature(tex.mainF, byte(tex.curL), tex.mem[tex.curQ].hh().rh)
			if tex.lftHit {
				*tex.mem[tex.mainP].pHh().pB1() = 2
				tex.lftHit = false
			}
			if tex.rtHit {
				if tex.ligStack == 0 {
					*tex.mem[tex.mainP].pHh().pB1() = byte(int32(tex.mem[tex.mainP].hh().b1()) + 1)
					tex.rtHit = false
				}
			}
			tex.mem[tex.curQ].pHh().rh = tex.mainP
			tex.curList.tailField = tex.mainP
			tex.ligaturePresent = false
		}
		if tex.insDisc {
			tex.insDisc = false
			if tex.curList.modeField > 0 {
				tex.mem[tex.curList.tailField].pHh().rh = tex.newDisc()
				tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
			}
		}
	}
label90:
	if tex.ligStack == 0 {
		goto label21
	}
	tex.curQ = tex.curList.tailField
	tex.curL = uint16(tex.mem[tex.ligStack].hh().b1())
label91:
	if !(tex.ligStack >= tex.hiMemMin) {
		goto label95
	}
label92:
	if (tex.curChr < uint16(tex.fontBc[tex.mainF])) || (tex.curChr > uint16(tex.fontEc[tex.mainF])) {
		tex.charWarning(tex.mainF, byte(tex.curChr))
		tex.mem[tex.ligStack].pHh().rh = tex.avail
		tex.avail = tex.ligStack
		goto label60
	}
	tex.mainI = tex.fontInfo[tex.charBase[tex.mainF]+int32(tex.curL)].qqqq()
	if !(tex.mainI.b0 > 0) {
		tex.charWarning(tex.mainF, byte(tex.curChr))
		tex.mem[tex.ligStack].pHh().rh = tex.avail
		tex.avail = tex.ligStack
		goto label60
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.ligStack
	tex.curList.tailField = tex.ligStack
label100:
	tex.getNext()
	if tex.curCmd == 11 {
		goto label101
	}
	if tex.curCmd == 12 {
		goto label101
	}
	if tex.curCmd == 68 {
		goto label101
	}
	tex.xToken()
	if tex.curCmd == 11 {
		goto label101
	}
	if tex.curCmd == 12 {
		goto label101
	}
	if tex.curCmd == 68 {
		goto label101
	}
	if tex.curCmd == 16 {
		tex.scanCharNum()
		tex.curChr = uint16(tex.curVal)
		goto label101
	}
	if tex.curCmd == 65 {
		tex.bchar = 256
	}
	tex.curR = tex.bchar
	tex.ligStack = 0
	goto label110
label101:
	tex.mainS = int32(tex.eqtb[4751+int32(tex.curChr)-1].hh().rh)
	if tex.mainS == 1000 {
		*tex.curList.auxField.pHh().pLh() = 1000
	} else if tex.mainS < 1000 {
		if tex.mainS > 0 {
			*tex.curList.auxField.pHh().pLh() = uint16(tex.mainS)
		}
	} else if tex.curList.auxField.hh().lh() < 1000 {
		*tex.curList.auxField.pHh().pLh() = 1000
	} else {
		*tex.curList.auxField.pHh().pLh() = uint16(tex.mainS)
	}
	tex.ligStack = tex.avail
	if tex.ligStack == 0 {
		tex.ligStack = tex.getAvail()
	} else {
		tex.avail = tex.mem[tex.ligStack].hh().rh
		tex.mem[tex.ligStack].pHh().rh = 0
	}
	*tex.mem[tex.ligStack].pHh().pB0() = tex.mainF
	tex.curR = uint16(int32(tex.curChr) + 0)
	*tex.mem[tex.ligStack].pHh().pB1() = byte(tex.curR)
	if tex.curR == tex.falseBchar {
		tex.curR = 256
	}
label110:
	if ((int32(tex.mainI.b2) - 0) % 4) != 1 {
		goto label80
	}
	if tex.curR == 256 {
		goto label80
	}
	tex.mainK = uint16(tex.ligKernBase[tex.mainF] + int32(tex.mainI.b3))
	tex.mainJ = tex.fontInfo[tex.mainK].qqqq()
	if tex.mainJ.b0 <= 128 {
		goto label112
	}
	tex.mainK = uint16(tex.ligKernBase[tex.mainF] + (256 * int32(tex.mainJ.b2)) + int32(tex.mainJ.b3) + 32768 - (256 * 128))
label111:
	tex.mainJ = tex.fontInfo[tex.mainK].qqqq()
label112:
	if uint16(tex.mainJ.b1) == tex.curR {
		if tex.mainJ.b0 <= 128 {
			if tex.mainJ.b2 >= 128 {
				if tex.curL < 256 {
					if tex.mem[tex.curQ].hh().rh > 0 {
						if int32(tex.mem[tex.curList.tailField].hh().b1()) == tex.hyphenChar[tex.mainF]+0 {
							tex.insDisc = true
						}
					}
					if tex.ligaturePresent {
						tex.mainP = tex.newLigature(tex.mainF, byte(tex.curL), tex.mem[tex.curQ].hh().rh)
						if tex.lftHit {
							*tex.mem[tex.mainP].pHh().pB1() = 2
							tex.lftHit = false
						}
						if tex.rtHit {
							if tex.ligStack == 0 {
								*tex.mem[tex.mainP].pHh().pB1() = byte(int32(tex.mem[tex.mainP].hh().b1()) + 1)
								tex.rtHit = false
							}
						}
						tex.mem[tex.curQ].pHh().rh = tex.mainP
						tex.curList.tailField = tex.mainP
						tex.ligaturePresent = false
					}
					if tex.insDisc {
						tex.insDisc = false
						if tex.curList.modeField > 0 {
							tex.mem[tex.curList.tailField].pHh().rh = tex.newDisc()
							tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
						}
					}
				}
				tex.mem[tex.curList.tailField].pHh().rh = tex.newKern(tex.fontInfo[tex.kernBase[tex.mainF]+(256*int32(tex.mainJ.b2))+int32(tex.mainJ.b3)].int())
				tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
				goto label90
			}
			if tex.curL == 256 {
				tex.lftHit = true
			} else if tex.ligStack == 0 {
				tex.rtHit = true
			}
			if tex.interrupt != 0 {
				tex.pauseForInstructions()
			}
			switch tex.mainJ.b2 {
			case 1, 5:
				tex.curL = uint16(tex.mainJ.b3)
				tex.mainI = tex.fontInfo[tex.charBase[tex.mainF]+int32(tex.curL)].qqqq()
				tex.ligaturePresent = true
			case 2, 6:
				tex.curR = uint16(tex.mainJ.b3)
				if tex.ligStack == 0 {
					tex.ligStack = tex.newLigItem(byte(tex.curR))
					tex.bchar = 256
				} else if tex.ligStack >= tex.hiMemMin {
					tex.mainP = tex.ligStack
					tex.ligStack = tex.newLigItem(byte(tex.curR))
					tex.mem[int32(tex.ligStack)+1].pHh().rh = tex.mainP
				} else {
					*tex.mem[tex.ligStack].pHh().pB1() = byte(tex.curR)
				}
			case 3:
				tex.curR = uint16(tex.mainJ.b3)
				tex.mainP = tex.ligStack
				tex.ligStack = tex.newLigItem(byte(tex.curR))
				tex.mem[tex.ligStack].pHh().rh = tex.mainP
			case 7, 11:
				if tex.curL < 256 {
					if tex.mem[tex.curQ].hh().rh > 0 {
						if int32(tex.mem[tex.curList.tailField].hh().b1()) == tex.hyphenChar[tex.mainF]+0 {
							tex.insDisc = true
						}
					}
					if tex.ligaturePresent {
						tex.mainP = tex.newLigature(tex.mainF, byte(tex.curL), tex.mem[tex.curQ].hh().rh)
						if tex.lftHit {
							*tex.mem[tex.mainP].pHh().pB1() = 2
							tex.lftHit = false
						}
						if false {
							if tex.ligStack == 0 {
								*tex.mem[tex.mainP].pHh().pB1() = byte(int32(tex.mem[tex.mainP].hh().b1()) + 1)
								tex.rtHit = false
							}
						}
						tex.mem[tex.curQ].pHh().rh = tex.mainP
						tex.curList.tailField = tex.mainP
						tex.ligaturePresent = false
					}
					if tex.insDisc {
						tex.insDisc = false
						if tex.curList.modeField > 0 {
							tex.mem[tex.curList.tailField].pHh().rh = tex.newDisc()
							tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
						}
					}
				}
				tex.curQ = tex.curList.tailField
				tex.curL = uint16(tex.mainJ.b3)
				tex.mainI = tex.fontInfo[tex.charBase[tex.mainF]+int32(tex.curL)].qqqq()
				tex.ligaturePresent = true
			default:
				tex.curL = uint16(tex.mainJ.b3)
				tex.ligaturePresent = true
				if tex.ligStack == 0 {
					goto label80
				} else {
					goto label91
				}
			}
			if tex.mainJ.b2 > 4 {
				if tex.mainJ.b2 != 7 {
					goto label80
				}
			}
			if tex.curL < 256 {
				goto label110
			}
			tex.mainK = tex.bcharLabel[tex.mainF]
			goto label111
		}
	}
	if tex.mainJ.b0 == 0 {
		tex.mainK = uint16(int32(tex.mainK) + 1)
	} else {
		if tex.mainJ.b0 >= 128 {
			goto label80
		}
		tex.mainK = uint16(int32(tex.mainK) + int32(tex.mainJ.b0) + 1)
	}
	goto label111
label95:
	tex.mainP = tex.mem[int32(tex.ligStack)+1].hh().rh
	if tex.mainP > 0 {
		tex.mem[tex.curList.tailField].pHh().rh = tex.mainP
		tex.curList.tailField = tex.mem[tex.curList.tailField].hh().rh
	}
	tex.tempPtr = tex.ligStack
	tex.ligStack = tex.mem[tex.tempPtr].hh().rh
	tex.freeNode(tex.tempPtr, 2)
	tex.mainI = tex.fontInfo[tex.charBase[tex.mainF]+int32(tex.curL)].qqqq()
	tex.ligaturePresent = true
	if tex.ligStack == 0 {
		if tex.mainP > 0 {
			goto label100
		} else {
			tex.curR = tex.bchar
		}
	} else {
		tex.curR = uint16(tex.mem[tex.ligStack].hh().b1())
	}
	goto label110
label120:
	if tex.eqtb[2894-1].hh().rh == 0 {
		tex.mainP = tex.fontGlue[tex.eqtb[3934-1].hh().rh]
		if tex.mainP == 0 {
			tex.mainP = tex.newSpec(0)
			tex.mainK = uint16(tex.paramBase[tex.eqtb[3934-1].hh().rh] + 2)
			*tex.mem[int32(tex.mainP)+1].pInt() = tex.fontInfo[tex.mainK].int()
			*tex.mem[int32(tex.mainP)+2].pInt() = tex.fontInfo[int32(tex.mainK)+1].int()
			*tex.mem[int32(tex.mainP)+3].pInt() = tex.fontInfo[int32(tex.mainK)+2].int()
			tex.fontGlue[tex.eqtb[3934-1].hh().rh] = tex.mainP
		}
		tex.tempPtr = tex.newGlue(tex.mainP)
	} else {
		tex.tempPtr = tex.newParamGlue(12)
	}
	tex.mem[tex.curList.tailField].pHh().rh = tex.tempPtr
	tex.curList.tailField = tex.tempPtr
	goto label60
label10:
}

func (tex *Context) giveErrHelp() {
	tex.tokenShow(tex.eqtb[3421-1].hh().rh)
}

func (tex *Context) openFmtFile() (ret bool) {
	var j uint16 // 0..500
	j = tex.curInput.locField
	if tex.buffer[tex.curInput.locField] == 38 {
		tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
		j = tex.curInput.locField
		tex.buffer[tex.last] = 32
		for tex.buffer[j] != 32 {
			j = uint16(int32(j) + 1)
		}
		tex.packBufferedName(0, int32(tex.curInput.locField), int32(j)-1)
		if tex.wOpenIn(&tex.fmtFile) {
			goto label40
		}
		tex.packBufferedName(11, int32(tex.curInput.locField), int32(j)-1)
		if tex.wOpenIn(&tex.fmtFile) {
			goto label40
		}
		writeLn(&tex.termOut, "Sorry, I can't find that format;", " will try PLAIN.")
		break1(&tex.termOut)
	}
	tex.packBufferedName(16, 1, 0)
	if !tex.wOpenIn(&tex.fmtFile) {
		writeLn(&tex.termOut, "I can't find the PLAIN format file!")
		ret = false
		goto label10
	}
label40:
	tex.curInput.locField = j
	ret = true
label10:
	return ret
}

func (tex *Context) loadFmtFile() (ret bool) {
	var j, k int32     // integer
	var p, q uint16    // 0..65535
	var x int32        // integer
	var w fourQuarters // record fourQuarters
	x = tex.fmtFile.memoryWord().int()
	if x != 504454778 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x != 0 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x != 30000 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x != 6106 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x != 1777 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x != 307 {
		goto label6666
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 0 {
		goto label6666
	}
	if x > poolSize {
		writeLn(&tex.termOut, "---! Must increase the ", "string pool size")
		goto label6666
	} else {
		tex.poolPtr = uint16(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 0 {
		goto label6666
	}
	if x > maxStrings {
		writeLn(&tex.termOut, "---! Must increase the ", "max strings")
		goto label6666
	} else {
		tex.strPtr = uint16(x)
	}
	for _i := int64(0); _i <= int64(tex.strPtr); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > int32(tex.poolPtr)) {
			goto label6666
		} else {
			tex.strStart[k] = uint16(x)
		}
	}
	k = 0
	for k+4 < int32(tex.poolPtr) {
		get(&tex.fmtFile)
		w = tex.fmtFile.memoryWord().qqqq()
		tex.strPool[k] = byte(int32(w.b0) - 0)
		tex.strPool[k+1] = byte(int32(w.b1) - 0)
		tex.strPool[k+2] = byte(int32(w.b2) - 0)
		tex.strPool[k+3] = byte(int32(w.b3) - 0)
		k = k + 4
	}
	k = int32(tex.poolPtr) - 4
	get(&tex.fmtFile)
	w = tex.fmtFile.memoryWord().qqqq()
	tex.strPool[k] = byte(int32(w.b0) - 0)
	tex.strPool[k+1] = byte(int32(w.b1) - 0)
	tex.strPool[k+2] = byte(int32(w.b2) - 0)
	tex.strPool[k+3] = byte(int32(w.b3) - 0)
	tex.initStrPtr = tex.strPtr
	tex.initPoolPtr = tex.poolPtr
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 1019) || (x > 29986) {
		goto label6666
	} else {
		tex.loMemMax = uint16(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 20) || (x > int32(tex.loMemMax)) {
		goto label6666
	} else {
		tex.rover = uint16(x)
	}
	p = 0
	q = tex.rover
	for {
		for _i := int64(p); _i <= int64(int32(q)+1); _i++ {
			k = int32(_i)
			get(&tex.fmtFile)
			tex.mem[k] = tex.fmtFile.memoryWord()
		}
		p = uint16(int32(q) + int32(tex.mem[q].hh().lh()))
		if (p > tex.loMemMax) || ((q >= tex.mem[int32(q)+1].hh().rh) && (tex.mem[int32(q)+1].hh().rh != tex.rover)) {
			goto label6666
		}
		q = tex.mem[int32(q)+1].hh().rh
		if q == tex.rover {
			break
		}
	}
	for _i := int64(p); _i <= int64(tex.loMemMax); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		tex.mem[k] = tex.fmtFile.memoryWord()
	}
	if memMin < -2 {
		p = tex.mem[int32(tex.rover)+1].hh().lh()
		q = uint16(memMin + 1)
		tex.mem[memMin].pHh().rh = 0
		*tex.mem[memMin].pHh().pLh() = 0
		tex.mem[int32(p)+1].pHh().rh = q
		*tex.mem[int32(tex.rover)+1].pHh().pLh() = q
		tex.mem[int32(q)+1].pHh().rh = tex.rover
		*tex.mem[int32(q)+1].pHh().pLh() = p
		tex.mem[q].pHh().rh = 65535
		*tex.mem[q].pHh().pLh() = uint16(-0 - int32(q))
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < (int32(tex.loMemMax) + 1)) || (x > 29987) {
		goto label6666
	} else {
		tex.hiMemMin = uint16(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 0) || (x > 30000) {
		goto label6666
	} else {
		tex.avail = uint16(x)
	}
	tex.memEnd = 30000
	for _i := int64(tex.hiMemMin); _i <= int64(tex.memEnd); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		tex.mem[k] = tex.fmtFile.memoryWord()
	}
	get(&tex.fmtFile)
	tex.varUsed = tex.fmtFile.memoryWord().int()
	get(&tex.fmtFile)
	tex.dynUsed = tex.fmtFile.memoryWord().int()
	k = 1
	for {

		{
			get(&tex.fmtFile)
			x = tex.fmtFile.memoryWord().int()
		}
		if (x < 1) || ((k + x) > 6107) {
			goto label6666
		}
		for _i := int64(k); _i <= int64(k+x-1); _i++ {
			j = int32(_i)
			get(&tex.fmtFile)
			tex.eqtb[j-1] = tex.fmtFile.memoryWord()
		}
		k = k + x

		{
			get(&tex.fmtFile)
			x = tex.fmtFile.memoryWord().int()
		}
		if (x < 0) || ((k + x) > 6107) {
			goto label6666
		}
		for _i := int64(k); _i <= int64(k+x-1); _i++ {
			j = int32(_i)
			tex.eqtb[j-1] = tex.eqtb[k-1-1]
		}
		k = k + x
		if k > 6106 {
			break
		}
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 514) || (x > 2614) {
		goto label6666
	} else {
		tex.parLoc = uint16(x)
	}
	tex.parToken = uint16(4095 + int32(tex.parLoc))
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 514) || (x > 2614) {
		goto label6666
	} else {
		tex.writeLoc = uint16(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 514) || (x > 2614) {
		goto label6666
	} else {
		tex.hashUsed = uint16(x)
	}
	p = 513
	for {

		{

			{
				get(&tex.fmtFile)
				x = tex.fmtFile.memoryWord().int()
			}
			if (x < (int32(p) + 1)) || (x > int32(tex.hashUsed)) {
				goto label6666
			} else {
				p = uint16(x)
			}
		}

		{
			get(&tex.fmtFile)
			tex.hash[p-514] = tex.fmtFile.memoryWord().hh()
		}
		if p == tex.hashUsed {
			break
		}
	}
	for _i := int64(int32(tex.hashUsed) + 1); _i <= int64(2880); _i++ {
		p = uint16(_i)
		get(&tex.fmtFile)
		tex.hash[p-514] = tex.fmtFile.memoryWord().hh()
	}
	get(&tex.fmtFile)
	tex.csCount = tex.fmtFile.memoryWord().int()
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 7 {
		goto label6666
	}
	if x > fontMemSize {
		writeLn(&tex.termOut, "---! Must increase the ", "font mem size")
		goto label6666
	} else {
		tex.fmemPtr = uint16(x)
	}
	for _i := int64(0); _i <= int64(int32(tex.fmemPtr)-1); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		tex.fontInfo[k] = tex.fmtFile.memoryWord()
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 0 {
		goto label6666
	}
	if x > fontMax {
		writeLn(&tex.termOut, "---! Must increase the ", "font max")
		goto label6666
	} else {
		tex.fontPtr = byte(x)
	}
	for _i := int64(0); _i <= int64(tex.fontPtr); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		tex.fontCheck[k] = tex.fmtFile.memoryWord().qqqq()
		get(&tex.fmtFile)
		tex.fontSize[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.fontDsize[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 65535) {
			goto label6666
		} else {
			tex.fontParams[k] = uint16(x)
		}
		get(&tex.fmtFile)
		tex.hyphenChar[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.skewChar[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > int32(tex.strPtr)) {
			goto label6666
		} else {
			tex.fontName[k] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > int32(tex.strPtr)) {
			goto label6666
		} else {
			tex.fontArea[k] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 255) {
			goto label6666
		} else {
			tex.fontBc[k] = byte(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 255) {
			goto label6666
		} else {
			tex.fontEc[k] = byte(x)
		}
		get(&tex.fmtFile)
		tex.charBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.widthBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.heightBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.depthBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.italicBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.ligKernBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.kernBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.extenBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		tex.paramBase[k] = tex.fmtFile.memoryWord().int()
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > int32(tex.loMemMax)) {
			goto label6666
		} else {
			tex.fontGlue[k] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > (int32(tex.fmemPtr) - 1)) {
			goto label6666
		} else {
			tex.bcharLabel[k] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 256) {
			goto label6666
		} else {
			tex.fontBchar[k] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 256) {
			goto label6666
		} else {
			tex.fontFalseBchar[k] = uint16(x)
		}
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 0) || (x > 307) {
		goto label6666
	} else {
		tex.hyphCount = uint16(x)
	}
	for _i := int64(1); _i <= int64(tex.hyphCount); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 307) {
			goto label6666
		} else {
			j = x
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > int32(tex.strPtr)) {
			goto label6666
		} else {
			tex.hyphWord[j] = uint16(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 65535) {
			goto label6666
		} else {
			tex.hyphList[j] = uint16(x)
		}
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 0 {
		goto label6666
	}
	if x > trieSize {
		writeLn(&tex.termOut, "---! Must increase the ", "trie size")
		goto label6666
	} else {
		j = x
	}
	tex.trieMax = uint16(j)
	for _i := int64(0); _i <= int64(j); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		tex.trie[k] = tex.fmtFile.memoryWord().hh()
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if x < 0 {
		goto label6666
	}
	if x > trieOpSize {
		writeLn(&tex.termOut, "---! Must increase the ", "trie op size")
		goto label6666
	} else {
		j = x
	}
	tex.trieOpPtr = uint16(j)
	for _i := int64(1); _i <= int64(j); _i++ {
		k = int32(_i)
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 63) {
			goto label6666
		} else {
			tex.hyfDistance[k-1] = byte(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 63) {
			goto label6666
		} else {
			tex.hyfNum[k-1] = byte(x)
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > 255) {
			goto label6666
		} else {
			tex.hyfNext[k-1] = byte(x)
		}
	}
	for _i := int64(0); _i <= int64(255); _i++ {
		k = int32(_i)
		tex.trieUsed[k] = 0
	}
	k = 256
	for j > 0 {
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 0) || (x > (k - 1)) {
			goto label6666
		} else {
			k = x
		}
		get(&tex.fmtFile)
		x = tex.fmtFile.memoryWord().int()
		if (x < 1) || (x > j) {
			goto label6666
		} else {
			x = x
		}
		tex.trieUsed[k] = byte(x + 0)
		j = j - x
		tex.opStart[k] = uint16(j - 0)
	}
	tex.trieNotReady = false
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 0) || (x > 3) {
		goto label6666
	} else {
		tex.interaction = byte(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x < 0) || (x > int32(tex.strPtr)) {
		goto label6666
	} else {
		tex.formatIdent = uint16(x)
	}
	get(&tex.fmtFile)
	x = tex.fmtFile.memoryWord().int()
	if (x != 69069) || eof(&tex.fmtFile) {
		goto label6666
	}
	ret = true
	goto label10
label6666:
	writeLn(&tex.termOut, "(Fatal format file error; I'm stymied)")
	ret = false
label10:
	return ret
}

func (tex *Context) closeFilesAndTerminate() {
	var k int32 // integer
	for _i := int64(0); _i <= int64(15); _i++ {
		k = int32(_i)
		if tex.writeOpen[k] {
			tex.aClose(&tex.writeFile[k])
		}
	}
	*tex.eqtb[5312-1].pInt() = -1
	for tex.curS > -1 {
		if tex.curS > 0 {
			tex.dviBuf[tex.dviPtr] = 142
			tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
			if tex.dviPtr == tex.dviLimit {
				tex.dviSwap()
			}
		} else {
			tex.dviBuf[tex.dviPtr] = 140
			tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
			if tex.dviPtr == tex.dviLimit {
				tex.dviSwap()
			}
			tex.totalPages = tex.totalPages + 1
		}
		tex.curS = tex.curS - 1
	}
	if tex.totalPages == 0 {
		tex.printNl(837)
	} else {
		tex.dviBuf[tex.dviPtr] = 248
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviFour(tex.lastBop)
		tex.lastBop = tex.dviOffset + int32(tex.dviPtr) - 5
		tex.dviFour(25400000)
		tex.dviFour(473628672)
		tex.prepareMag()
		tex.dviFour(tex.eqtb[5280-1].int())
		tex.dviFour(tex.maxV)
		tex.dviFour(tex.maxH)
		tex.dviBuf[tex.dviPtr] = byte((tex.maxPush / 256))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviBuf[tex.dviPtr] = byte((tex.maxPush % 256))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviBuf[tex.dviPtr] = byte(((tex.totalPages / 256) % 256))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviBuf[tex.dviPtr] = byte((tex.totalPages % 256))
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		for tex.fontPtr > 0 {
			if tex.fontUsed[tex.fontPtr] {
				tex.dviFontDef(tex.fontPtr)
			}
			tex.fontPtr = byte(int32(tex.fontPtr) - 1)
		}
		tex.dviBuf[tex.dviPtr] = 249
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		tex.dviFour(tex.lastBop)
		tex.dviBuf[tex.dviPtr] = 2
		tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
		if tex.dviPtr == tex.dviLimit {
			tex.dviSwap()
		}
		k = 4 + ((dviBufSize - int32(tex.dviPtr)) % 4)
		for k > 0 {
			tex.dviBuf[tex.dviPtr] = 223
			tex.dviPtr = uint16(int32(tex.dviPtr) + 1)
			if tex.dviPtr == tex.dviLimit {
				tex.dviSwap()
			}
			k = k - 1
		}
		if tex.dviLimit == tex.halfBuf {
			tex.writeDvi(tex.halfBuf, uint16(dviBufSize-1))
		}
		if tex.dviPtr > 0 {
			tex.writeDvi(0, uint16(int32(tex.dviPtr)-1))
		}
		tex.printNl(838)
		tex.slowPrint(int32(tex.outputFileName))
		tex.print(286)
		tex.printInt(tex.totalPages)
		tex.print(839)
		if tex.totalPages != 1 {
			tex.printChar(115)
		}
		tex.print(840)
		tex.printInt(tex.dviOffset + int32(tex.dviPtr))
		tex.print(841)
		tex.bClose(&tex.dviFile)
	}
	if tex.logOpened {
		writeLn(&tex.logFile)
		tex.aClose(&tex.logFile)
		tex.selector = byte(int32(tex.selector) - 2)
		if tex.selector == 17 {
			tex.printNl(1275)
			tex.slowPrint(int32(tex.logName))
			tex.printChar(46)
		}
	}
}

func (tex *Context) finalCleanup() {
	var c byte // 0..63
	c = byte(tex.curChr)
	if c != 1 {
		*tex.eqtb[5312-1].pInt() = -1
	}
	if tex.jobName == 0 {
		tex.openLogFile()
	}
	for tex.inputPtr > 0 {
		if tex.curInput.stateField == 0 {
			tex.endTokenList()
		} else {
			tex.endFileReading()
		}
	}
	for tex.openParens > 0 {
		tex.print(1276)
		tex.openParens = byte(int32(tex.openParens) - 1)
	}
	if tex.curLevel > 1 {
		tex.printNl(40)
		tex.printEsc(1277)
		tex.print(1278)
		tex.printInt(int32(tex.curLevel) - 1)
		tex.printChar(41)
	}
	for tex.condPtr != 0 {
		tex.printNl(40)
		tex.printEsc(1277)
		tex.print(1279)
		tex.printCmdChr(105, uint16(tex.curIf))
		if tex.ifLine != 0 {
			tex.print(1280)
			tex.printInt(tex.ifLine)
		}
		tex.print(1281)
		tex.ifLine = tex.mem[int32(tex.condPtr)+1].int()
		tex.curIf = tex.mem[tex.condPtr].hh().b1()
		tex.tempPtr = tex.condPtr
		tex.condPtr = tex.mem[tex.condPtr].hh().rh
		tex.freeNode(tex.tempPtr, 2)
	}
	if tex.history != 0 {
		if (tex.history == 1) || (tex.interaction < 3) {
			if tex.selector == 19 {
				tex.selector = 17
				tex.printNl(1282)
				tex.selector = 19
			}
		}
	}
	if c == 1 {
		for _i := int64(0); _i <= int64(4); _i++ {
			c = byte(_i)
			if tex.curMark[c] != 0 {
				tex.deleteTokenRef(tex.curMark[c])
			}
		}
		if tex.lastGlue != 65535 {
			tex.deleteGlueRef(tex.lastGlue)
		}
		tex.storeFmtFile()
		goto label10
		tex.printNl(1283)
		goto label10
	}
label10:
}

func (tex *Context) initPrim() {
	tex.noNewControlSequence = false
	tex.primitive(376, 75, 2882)
	tex.primitive(377, 75, 2883)
	tex.primitive(378, 75, 2884)
	tex.primitive(379, 75, 2885)
	tex.primitive(380, 75, 2886)
	tex.primitive(381, 75, 2887)
	tex.primitive(382, 75, 2888)
	tex.primitive(383, 75, 2889)
	tex.primitive(384, 75, 2890)
	tex.primitive(385, 75, 2891)
	tex.primitive(386, 75, 2892)
	tex.primitive(387, 75, 2893)
	tex.primitive(388, 75, 2894)
	tex.primitive(389, 75, 2895)
	tex.primitive(390, 75, 2896)
	tex.primitive(391, 76, 2897)
	tex.primitive(392, 76, 2898)
	tex.primitive(393, 76, 2899)
	tex.primitive(398, 72, 3413)
	tex.primitive(399, 72, 3414)
	tex.primitive(400, 72, 3415)
	tex.primitive(401, 72, 3416)
	tex.primitive(402, 72, 3417)
	tex.primitive(403, 72, 3418)
	tex.primitive(404, 72, 3419)
	tex.primitive(405, 72, 3420)
	tex.primitive(406, 72, 3421)
	tex.primitive(420, 73, 5263)
	tex.primitive(421, 73, 5264)
	tex.primitive(422, 73, 5265)
	tex.primitive(423, 73, 5266)
	tex.primitive(424, 73, 5267)
	tex.primitive(425, 73, 5268)
	tex.primitive(426, 73, 5269)
	tex.primitive(427, 73, 5270)
	tex.primitive(428, 73, 5271)
	tex.primitive(429, 73, 5272)
	tex.primitive(430, 73, 5273)
	tex.primitive(431, 73, 5274)
	tex.primitive(432, 73, 5275)
	tex.primitive(433, 73, 5276)
	tex.primitive(434, 73, 5277)
	tex.primitive(435, 73, 5278)
	tex.primitive(436, 73, 5279)
	tex.primitive(437, 73, 5280)
	tex.primitive(438, 73, 5281)
	tex.primitive(439, 73, 5282)
	tex.primitive(440, 73, 5283)
	tex.primitive(441, 73, 5284)
	tex.primitive(442, 73, 5285)
	tex.primitive(443, 73, 5286)
	tex.primitive(444, 73, 5287)
	tex.primitive(445, 73, 5288)
	tex.primitive(446, 73, 5289)
	tex.primitive(447, 73, 5290)
	tex.primitive(448, 73, 5291)
	tex.primitive(449, 73, 5292)
	tex.primitive(450, 73, 5293)
	tex.primitive(451, 73, 5294)
	tex.primitive(452, 73, 5295)
	tex.primitive(453, 73, 5296)
	tex.primitive(454, 73, 5297)
	tex.primitive(455, 73, 5298)
	tex.primitive(456, 73, 5299)
	tex.primitive(457, 73, 5300)
	tex.primitive(458, 73, 5301)
	tex.primitive(459, 73, 5302)
	tex.primitive(460, 73, 5303)
	tex.primitive(461, 73, 5304)
	tex.primitive(462, 73, 5305)
	tex.primitive(463, 73, 5306)
	tex.primitive(464, 73, 5307)
	tex.primitive(465, 73, 5308)
	tex.primitive(466, 73, 5309)
	tex.primitive(467, 73, 5310)
	tex.primitive(468, 73, 5311)
	tex.primitive(469, 73, 5312)
	tex.primitive(470, 73, 5313)
	tex.primitive(471, 73, 5314)
	tex.primitive(472, 73, 5315)
	tex.primitive(473, 73, 5316)
	tex.primitive(474, 73, 5317)
	tex.primitive(478, 74, 5830)
	tex.primitive(479, 74, 5831)
	tex.primitive(480, 74, 5832)
	tex.primitive(481, 74, 5833)
	tex.primitive(482, 74, 5834)
	tex.primitive(483, 74, 5835)
	tex.primitive(484, 74, 5836)
	tex.primitive(485, 74, 5837)
	tex.primitive(486, 74, 5838)
	tex.primitive(487, 74, 5839)
	tex.primitive(488, 74, 5840)
	tex.primitive(489, 74, 5841)
	tex.primitive(490, 74, 5842)
	tex.primitive(491, 74, 5843)
	tex.primitive(492, 74, 5844)
	tex.primitive(493, 74, 5845)
	tex.primitive(494, 74, 5846)
	tex.primitive(495, 74, 5847)
	tex.primitive(496, 74, 5848)
	tex.primitive(497, 74, 5849)
	tex.primitive(498, 74, 5850)
	tex.primitive(32, 64, 0)
	tex.primitive(47, 44, 0)
	tex.primitive(508, 45, 0)
	tex.primitive(509, 90, 0)
	tex.primitive(510, 40, 0)
	tex.primitive(511, 41, 0)
	tex.primitive(512, 61, 0)
	tex.primitive(513, 16, 0)
	tex.primitive(504, 107, 0)
	tex.primitive(514, 15, 0)
	tex.primitive(515, 92, 0)
	tex.primitive(505, 67, 0)
	tex.primitive(516, 62, 0)
	tex.hash[2616-514].rh = 516
	tex.eqtb[2616-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(517, 102, 0)
	tex.primitive(518, 88, 0)
	tex.primitive(519, 77, 0)
	tex.primitive(520, 32, 0)
	tex.primitive(521, 36, 0)
	tex.primitive(522, 39, 0)
	tex.primitive(330, 37, 0)
	tex.primitive(351, 18, 0)
	tex.primitive(523, 46, 0)
	tex.primitive(524, 17, 0)
	tex.primitive(525, 54, 0)
	tex.primitive(526, 91, 0)
	tex.primitive(527, 34, 0)
	tex.primitive(528, 65, 0)
	tex.primitive(529, 103, 0)
	tex.primitive(335, 55, 0)
	tex.primitive(530, 63, 0)
	tex.primitive(408, 84, 0)
	tex.primitive(531, 42, 0)
	tex.primitive(532, 80, 0)
	tex.primitive(533, 66, 0)
	tex.primitive(534, 96, 0)
	tex.primitive(535, 0, 256)
	tex.hash[2621-514].rh = 535
	tex.eqtb[2621-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(536, 98, 0)
	tex.primitive(537, 109, 0)
	tex.primitive(407, 71, 0)
	tex.primitive(352, 38, 0)
	tex.primitive(538, 33, 0)
	tex.primitive(539, 56, 0)
	tex.primitive(540, 35, 0)
	tex.primitive(597, 13, 256)
	tex.parLoc = uint16(tex.curVal)
	tex.parToken = uint16(4095 + int32(tex.parLoc))
	tex.primitive(629, 104, 0)
	tex.primitive(630, 104, 1)
	tex.primitive(631, 110, 0)
	tex.primitive(632, 110, 1)
	tex.primitive(633, 110, 2)
	tex.primitive(634, 110, 3)
	tex.primitive(635, 110, 4)
	tex.primitive(476, 89, 0)
	tex.primitive(500, 89, 1)
	tex.primitive(395, 89, 2)
	tex.primitive(396, 89, 3)
	tex.primitive(668, 79, 102)
	tex.primitive(669, 79, 1)
	tex.primitive(670, 82, 0)
	tex.primitive(671, 82, 1)
	tex.primitive(672, 83, 1)
	tex.primitive(673, 83, 3)
	tex.primitive(674, 83, 2)
	tex.primitive(675, 70, 0)
	tex.primitive(676, 70, 1)
	tex.primitive(677, 70, 2)
	tex.primitive(678, 70, 3)
	tex.primitive(679, 70, 4)
	tex.primitive(735, 108, 0)
	tex.primitive(736, 108, 1)
	tex.primitive(737, 108, 2)
	tex.primitive(738, 108, 3)
	tex.primitive(739, 108, 4)
	tex.primitive(740, 108, 5)
	tex.primitive(757, 105, 0)
	tex.primitive(758, 105, 1)
	tex.primitive(759, 105, 2)
	tex.primitive(760, 105, 3)
	tex.primitive(761, 105, 4)
	tex.primitive(762, 105, 5)
	tex.primitive(763, 105, 6)
	tex.primitive(764, 105, 7)
	tex.primitive(765, 105, 8)
	tex.primitive(766, 105, 9)
	tex.primitive(767, 105, 10)
	tex.primitive(768, 105, 11)
	tex.primitive(769, 105, 12)
	tex.primitive(770, 105, 13)
	tex.primitive(771, 105, 14)
	tex.primitive(772, 105, 15)
	tex.primitive(773, 105, 16)
	tex.primitive(774, 106, 2)
	tex.hash[2618-514].rh = 774
	tex.eqtb[2618-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(775, 106, 4)
	tex.primitive(776, 106, 3)
	tex.primitive(801, 87, 0)
	tex.hash[2624-514].rh = 801
	tex.eqtb[2624-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(898, 4, 256)
	tex.primitive(899, 5, 257)
	tex.hash[2615-514].rh = 899
	tex.eqtb[2615-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(900, 5, 258)
	tex.hash[2619-514].rh = 901
	tex.hash[2620-514].rh = 901
	*tex.eqtb[2620-1].pHh().pB0() = 9
	tex.eqtb[2620-1].pHh().rh = 29989
	*tex.eqtb[2620-1].pHh().pB1() = 1
	tex.eqtb[2619-1] = tex.eqtb[2620-1]
	*tex.eqtb[2619-1].pHh().pB0() = 115
	tex.primitive(970, 81, 0)
	tex.primitive(971, 81, 1)
	tex.primitive(972, 81, 2)
	tex.primitive(973, 81, 3)
	tex.primitive(974, 81, 4)
	tex.primitive(975, 81, 5)
	tex.primitive(976, 81, 6)
	tex.primitive(977, 81, 7)
	tex.primitive(1025, 14, 0)
	tex.primitive(1026, 14, 1)
	tex.primitive(1027, 26, 4)
	tex.primitive(1028, 26, 0)
	tex.primitive(1029, 26, 1)
	tex.primitive(1030, 26, 2)
	tex.primitive(1031, 26, 3)
	tex.primitive(1032, 27, 4)
	tex.primitive(1033, 27, 0)
	tex.primitive(1034, 27, 1)
	tex.primitive(1035, 27, 2)
	tex.primitive(1036, 27, 3)
	tex.primitive(336, 28, 5)
	tex.primitive(340, 29, 1)
	tex.primitive(342, 30, 99)
	tex.primitive(1054, 21, 1)
	tex.primitive(1055, 21, 0)
	tex.primitive(1056, 22, 1)
	tex.primitive(1057, 22, 0)
	tex.primitive(409, 20, 0)
	tex.primitive(1058, 20, 1)
	tex.primitive(1059, 20, 2)
	tex.primitive(965, 20, 3)
	tex.primitive(1060, 20, 4)
	tex.primitive(967, 20, 5)
	tex.primitive(1061, 20, 106)
	tex.primitive(1062, 31, 99)
	tex.primitive(1063, 31, 100)
	tex.primitive(1064, 31, 101)
	tex.primitive(1065, 31, 102)
	tex.primitive(1080, 43, 1)
	tex.primitive(1081, 43, 0)
	tex.primitive(1090, 25, 12)
	tex.primitive(1091, 25, 11)
	tex.primitive(1092, 25, 10)
	tex.primitive(1093, 23, 0)
	tex.primitive(1094, 23, 1)
	tex.primitive(1095, 24, 0)
	tex.primitive(1096, 24, 1)
	tex.primitive(45, 47, 1)
	tex.primitive(349, 47, 0)
	tex.primitive(1127, 48, 0)
	tex.primitive(1128, 48, 1)
	tex.primitive(866, 50, 16)
	tex.primitive(867, 50, 17)
	tex.primitive(868, 50, 18)
	tex.primitive(869, 50, 19)
	tex.primitive(870, 50, 20)
	tex.primitive(871, 50, 21)
	tex.primitive(872, 50, 22)
	tex.primitive(873, 50, 23)
	tex.primitive(875, 50, 26)
	tex.primitive(874, 50, 27)
	tex.primitive(1129, 51, 0)
	tex.primitive(878, 51, 1)
	tex.primitive(879, 51, 2)
	tex.primitive(861, 53, 0)
	tex.primitive(862, 53, 2)
	tex.primitive(863, 53, 4)
	tex.primitive(864, 53, 6)
	tex.primitive(1147, 52, 0)
	tex.primitive(1148, 52, 1)
	tex.primitive(1149, 52, 2)
	tex.primitive(1150, 52, 3)
	tex.primitive(1151, 52, 4)
	tex.primitive(1152, 52, 5)
	tex.primitive(876, 49, 30)
	tex.primitive(877, 49, 31)
	tex.hash[2617-514].rh = 877
	tex.eqtb[2617-1] = tex.eqtb[tex.curVal-1]
	tex.primitive(1171, 93, 1)
	tex.primitive(1172, 93, 2)
	tex.primitive(1173, 93, 4)
	tex.primitive(1174, 97, 0)
	tex.primitive(1175, 97, 1)
	tex.primitive(1176, 97, 2)
	tex.primitive(1177, 97, 3)
	tex.primitive(1191, 94, 0)
	tex.primitive(1192, 94, 1)
	tex.primitive(1193, 95, 0)
	tex.primitive(1194, 95, 1)
	tex.primitive(1195, 95, 2)
	tex.primitive(1196, 95, 3)
	tex.primitive(1197, 95, 4)
	tex.primitive(1198, 95, 5)
	tex.primitive(1199, 95, 6)
	tex.primitive(415, 85, 3983)
	tex.primitive(419, 85, 5007)
	tex.primitive(416, 85, 4239)
	tex.primitive(417, 85, 4495)
	tex.primitive(418, 85, 4751)
	tex.primitive(477, 85, 5574)
	tex.primitive(412, 86, 3935)
	tex.primitive(413, 86, 3951)
	tex.primitive(414, 86, 3967)
	tex.primitive(941, 99, 0)
	tex.primitive(953, 99, 1)
	tex.primitive(1217, 78, 0)
	tex.primitive(1218, 78, 1)
	tex.primitive(274, 100, 0)
	tex.primitive(275, 100, 1)
	tex.primitive(276, 100, 2)
	tex.primitive(1227, 100, 3)
	tex.primitive(1228, 60, 1)
	tex.primitive(1229, 60, 0)
	tex.primitive(1230, 58, 0)
	tex.primitive(1231, 58, 1)
	tex.primitive(1237, 57, 4239)
	tex.primitive(1238, 57, 4495)
	tex.primitive(1239, 19, 0)
	tex.primitive(1240, 19, 1)
	tex.primitive(1241, 19, 2)
	tex.primitive(1242, 19, 3)
	tex.primitive(1285, 59, 0)
	tex.primitive(594, 59, 1)
	tex.writeLoc = uint16(tex.curVal)
	tex.primitive(1286, 59, 2)
	tex.primitive(1287, 59, 3)
	tex.primitive(1288, 59, 4)
	tex.primitive(1289, 59, 5)
	tex.noNewControlSequence = true
}

func (tex *Context) main() {
	tex.history = 3
	rewrite1(tex, &tex.termOut, "TTY:", "/O")
	if tex.readyAlready == 314159 {
		goto label1
	}
	tex.bad = 0
	if (halfErrorLine < 30) || (halfErrorLine > (errorLine - 15)) {
		tex.bad = 1
	}
	if maxPrintLine < 60 {
		tex.bad = 2
	}
	if (dviBufSize % 8) != 0 {
		tex.bad = 3
	}
	if 1100 > 30000 {
		tex.bad = 4
	}
	if 1777 > 2100 {
		tex.bad = 5
	}
	if maxInOpen >= 128 {
		tex.bad = 6
	}
	if 30000 < 267 {
		tex.bad = 7
	}
	if (memMin != 0) || (memMax != 30000) {
		tex.bad = 10
	}
	if (memMin > 0) || (memMax < 30000) {
		tex.bad = 10
	}
	if (0 > 0) || (255 < 127) {
		tex.bad = 11
	}
	if (0 > 0) || (65535 < 32767) {
		tex.bad = 12
	}
	if (0 < 0) || (255 > 65535) {
		tex.bad = 13
	}
	if (memMin < 0) || (memMax >= 65535) || ((-0 - memMin) > 65536) {
		tex.bad = 14
	}
	if (0 < 0) || (fontMax > 255) {
		tex.bad = 15
	}
	if fontMax > 256 {
		tex.bad = 16
	}
	if (saveSize > 65535) || (maxStrings > 65535) {
		tex.bad = 17
	}
	if bufSize > 65535 {
		tex.bad = 18
	}
	if 255 < 255 {
		tex.bad = 19
	}
	if 6976 > 65535 {
		tex.bad = 21
	}
	if 20 > fileNameSize {
		tex.bad = 31
	}
	if (2 * 65535) < 30000-memMin {
		tex.bad = 41
	}
	if tex.bad > 0 {
		writeLn(&tex.termOut, "Ouch---my internal constants have been clobbered!", "---case ", tex.bad, vaWidth(1))
		panic(pasFinalEnd)
	}
	tex.initialize()
	if !tex.getStringsStarted() {
		panic(pasFinalEnd)
	}
	tex.initPrim()
	tex.initStrPtr = tex.strPtr
	tex.initPoolPtr = tex.poolPtr
	tex.fixDateAndTime()
	tex.readyAlready = 314159
label1:
	tex.selector = 17
	tex.tally = 0
	tex.termOffset = 0
	tex.fileOffset = 0
	write(&tex.termOut, "This is TeX, Version 3.141592653")
	if tex.formatIdent == 0 {
		writeLn(&tex.termOut, " (no format preloaded)")
	} else {
		tex.slowPrint(int32(tex.formatIdent))
		tex.printLn()
	}
	break1(&tex.termOut)
	tex.jobName = 0
	tex.nameInProgress = false
	tex.logOpened = false
	tex.outputFileName = 0
	tex.inputPtr = 0
	tex.maxInStack = 0
	tex.inOpen = 0
	tex.openParens = 0
	tex.maxBufStack = 0
	tex.paramPtr = 0
	tex.maxParamStack = 0
	tex.first = bufSize
	for {
		tex.buffer[tex.first] = 0
		tex.first = uint16(int32(tex.first) - 1)
		if tex.first == 0 {
			break
		}
	}
	tex.scannerStatus = 0
	tex.warningIndex = 0
	tex.first = 1
	tex.curInput.stateField = 33
	tex.curInput.startField = 1
	tex.curInput.indexField = 0
	tex.line = 0
	tex.curInput.nameField = 0
	tex.forceEof = false
	tex.alignState = 1000000
	if !tex.initTerminal() {
		panic(pasFinalEnd)
	}
	tex.curInput.limitField = tex.last
	tex.first = uint16(int32(tex.last) + 1)
	if (tex.formatIdent == 0) || (tex.buffer[tex.curInput.locField] == 38) {
		if tex.formatIdent != 0 {
			tex.initialize()
		}
		if !tex.openFmtFile() {
			panic(pasFinalEnd)
		}
		if !tex.loadFmtFile() {
			tex.wClose(&tex.fmtFile)
			panic(pasFinalEnd)
		}
		tex.wClose(&tex.fmtFile)
		for (tex.curInput.locField < tex.curInput.limitField) && (tex.buffer[tex.curInput.locField] == 32) {
			tex.curInput.locField = uint16(int32(tex.curInput.locField) + 1)
		}
	}
	if (tex.eqtb[5311-1].int() < 0) || (tex.eqtb[5311-1].int() > 255) {
		tex.curInput.limitField = uint16(int32(tex.curInput.limitField) - 1)
	} else {
		tex.buffer[tex.curInput.limitField] = byte(tex.eqtb[5311-1].int())
	}
	tex.fixDateAndTime()
	tex.magicOffset = int32(tex.strStart[892]) - (9 * 16)
	if tex.interaction == 0 {
		tex.selector = 16
	} else {
		tex.selector = 17
	}
	if (tex.curInput.locField < tex.curInput.limitField) && (tex.eqtb[3983+int32(tex.buffer[tex.curInput.locField])-1].hh().rh != 0) {
		tex.startInput()
	}
	tex.history = 0
	tex.mainControl()
	tex.finalCleanup()
	tex.closeFilesAndTerminate()
	tex.readyAlready = 0
}

// Run time library

var (
	_ error = pasError(0)

	isMain bool
)

const (
	pasEndOfTeX pasError = -iota - 1
	pasFinalEnd
)

const (
	modeNoIOPanic = "/O"
	stdioDev      = "TTY:"
	texArea       = "TeXinputs:"
	texFontArea   = "TeXfonts:"
	texPool       = "TeXformats:TEX.POOL"
)

func origin(skip int) string {
	pc, fn, fl, _ := runtime.Caller(skip)
	fn = filepath.Base(fn)
	f := runtime.FuncForPC(pc)
	var fns string
	if f != nil {
		fns = f.Name()
		if x := strings.LastIndex(fns, "."); x > 0 {
			fns = fns[x+1:]
		}
	}
	return fmt.Sprintf("%s:%d:%s", fn, fl, fns)
}

func todo(s string, args ...interface{}) string { //TODO-
	switch {
	case s == "":
		s = fmt.Sprintf(strings.Repeat("%v ", len(args)), args...)
	default:
		s = fmt.Sprintf(s, args...)
	}
	pc, fn, fl, _ := runtime.Caller(1)
	f := runtime.FuncForPC(pc)
	var fns string
	if f != nil {
		fns = f.Name()
		if x := strings.LastIndex(fns, "."); x > 0 {
			fns = fns[x+1:]
		}
	}
	r := fmt.Sprintf("%s:%d:%s: TODOTODO %s", fn, fl, fns, s) //TODOOK
	fmt.Fprintf(os.Stdout, "%s\n", r)
	os.Stdout.Sync()
	return r
}

func trc(s string, args ...interface{}) string { //TODO-
	switch {
	case s == "":
		s = fmt.Sprintf(strings.Repeat("%v ", len(args)), args...)
	default:
		s = fmt.Sprintf(s, args...)
	}
	_, fn, fl, _ := runtime.Caller(1)
	r := fmt.Sprintf("%s:%d: TRC %s", fn, fl, s)
	fmt.Fprintf(os.Stdout, "%s\n", r)
	os.Stdout.Sync()
	return r
}

type pasError int

func (err pasError) Error() string { return fmt.Sprintf("%T(%[1]d)", err) }

func pasJumpOut() { panic(pasEndOfTeX) }

func abs(n float32) float32       { return float32(math.Abs(float64(n))) }
func chr(i int32) byte            { return byte(i) }
func odd(i int32) bool            { return i&1 != 0 }
func pasSysDay() int32            { return int32(time.Now().Day()) }
func pasSysMonth() int32          { return int32(time.Now().Month()) }
func pasSysTime() int32           { return int32(time.Now().Hour()*60 + time.Now().Minute()) }
func pasSysYear() int32           { return int32(time.Now().Year()) }
func read(args ...interface{})    { args[0].(*pasFile).read(args[1:], false) }
func readLn(args ...interface{})  { args[0].(*pasFile).read(args[1:], true) }
func write(args ...interface{})   { args[0].(*pasFile).write(args[1:], false) }
func writeLn(args ...interface{}) { args[0].(*pasFile).write(args[1:], true) }

func iabs(n int32) int32 {
	if n >= 0 {
		return n
	}

	if n == math.MinInt32 {
		panic("overflow")
	}

	return -n
}

// [0] page 193
//
// round (r) yields a value such that if r >= 0 then round (r) =
// trunc(r + 0.5), and if r < 0 then round(r) =
// trunc (r - 0.5). It is an error if no such value exists.
func round(r float32) int32 {
	if r >= 0 {
		return int32(r + 0.5)
	}

	return int32(r - 0.5)
}

func setString(dst []byte, src string) {
	for i := range dst {
		dst[i] = ' '
	}
	copy(dst, src)
}
